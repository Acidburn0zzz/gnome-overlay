diff --git a/daemon/main.c b/daemon/main.c
index 9d7ab5e..aef3adf 100644
--- a/daemon/main.c
+++ b/daemon/main.c
@@ -495,6 +495,63 @@ signal_cb (int      signo,
         return ret;
 }
 
+static void
+gdm_signal_ignore (int signal)
+{
+        struct sigaction ign_signal;
+
+        ign_signal.sa_handler = SIG_IGN;
+        ign_signal.sa_flags = SA_RESTART;
+        sigemptyset (&ign_signal.sa_mask);
+
+        if G_UNLIKELY (sigaction (signal, &ign_signal, NULL) < 0)
+                gdm_error (_("%s: Error setting signal %d to %s"),
+                           "gdm_signal_ignore", signal, "SIG_IGN");
+}
+
+static void
+gdm_open_dev_null (mode_t mode)
+{
+        int ret;
+        VE_IGNORE_EINTR (ret = open ("/dev/null", mode));
+        if G_UNLIKELY (ret < 0) {
+                /*
+                 * Never output anything, we're likely in some
+                 * strange state right now
+                 */
+                gdm_signal_ignore (SIGPIPE);
+                VE_IGNORE_EINTR (close (2));
+                gdm_fail ("Cannot open /dev/null!");
+        }
+}
+
+static void
+gdm_daemonify (void)
+{
+        pid_t pid;
+
+        pid = fork ();
+
+        /* terminate the parent */
+        if (pid > 0)
+                exit (EXIT_SUCCESS);
+
+        if G_UNLIKELY (pid < 0)
+                gdm_fail (_("%s: fork () failed!"), "gdm_daemonify");
+
+        if G_UNLIKELY (setsid () < 0)
+                gdm_fail (_("%s: setsid () failed: %s!"), "gdm_daemonify",
+                          strerror (errno));
+
+        /* reopen stdin, stdout, stderr with /dev/null */
+        VE_IGNORE_EINTR (close (0));
+        VE_IGNORE_EINTR (close (1));
+        VE_IGNORE_EINTR (close (2));
+        gdm_open_dev_null (O_RDONLY);
+        gdm_open_dev_null (O_RDWR);
+        gdm_open_dev_null (O_RDWR);
+}
+
 int
 main (int    argc,
       char **argv)
@@ -505,6 +562,7 @@ main (int    argc,
         DBusGConnection    *connection;
         GError             *error;
         int                 ret;
+        int                 i;
         gboolean            res;
         gboolean            xdmcp_enabled;
         GdmSignalHandler   *signal_handler;
@@ -512,9 +570,11 @@ main (int    argc,
         static gboolean     do_timed_exit    = FALSE;
         static gboolean     print_version    = FALSE;
         static gboolean     fatal_warnings   = FALSE;
+        static gboolean     no_daemon        = FALSE;
         static GOptionEntry entries []   = {
                 { "debug", 0, 0, G_OPTION_ARG_NONE, &debug, N_("Enable debugging code"), NULL },
                 { "fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &fatal_warnings, N_("Make all warnings fatal"), NULL },
+                { "nodaemon", 0, 0, G_OPTION_ARG_NONE, &no_daemon, N_("Do not fork into the background"), NULL },
                 { "timed-exit", 0, 0, G_OPTION_ARG_NONE, &do_timed_exit, N_("Exit after a time - for debugging"), NULL },
                 { "version", 0, 0, G_OPTION_ARG_NONE, &print_version, N_("Print GDM version"), NULL },
 
@@ -531,6 +591,14 @@ main (int    argc,
 
         g_type_init ();
 
+        /* preprocess the arguments to support the xdm style -nodaemon
+         * option
+         */
+        for (i = 0; i < argc; i++) {
+                if (strcmp (argv[i], "-nodaemon") == 0)
+                        argv[i] = "--nodaemon";
+        }
+
         context = g_option_context_new (_("GNOME Display Manager"));
         g_option_context_add_main_entries (context, entries, NULL);
         g_option_context_set_ignore_unknown_options (context, TRUE);
@@ -600,6 +668,12 @@ main (int    argc,
         delete_pid ();
         write_pid ();
 
+        if (!no_daemon) {
+                /* fork and write pid file with child's pid */
+                gdm_daemonify ();
+                write_pid ();
+        }
+
         g_chdir (AUTHDIR);
 
         manager = gdm_manager_new ();
-- 
1.5.5.1

