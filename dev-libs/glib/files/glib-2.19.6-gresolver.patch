diff --git a/ChangeLog b/ChangeLog
index 9cbcbca..b6b7924 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,23 @@
+2999-02-11  Matthias Clasen  <mclasen@redhat.com>
+
+	Bug 523742 – Use noinst for non-installable libraries
+
+	* tests/Makefile.am: use noninst_LTLIBRARIES for noninstalled 
+	libraries.Patch by Björn Lindqvist
+
+2009-02-06  Murray Cumming  <murrayc@murrayc.com>
+
+	* gio/gfilterinputstream.c:
+	* gio/gfilteroutputstream.c: Correct the grammar in some property 
+	documentation.
+	* gio/gdatainputstream.c:
+	* glib/gregex.c: Correct the spelling of 
+	occurrence in documentation.
+
+2009-02-02  Matthias Clasen  <mclasen@redhat.com>
+
+	* configure.in: Bump version
+
 2009-02-02  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.6 ===
diff --git a/configure.in b/configure.in
index 818ae17..01d91c9 100644
--- a/configure.in
+++ b/configure.in
@@ -23,7 +23,7 @@ m4_define(glib_configure_in)
 #
 m4_define([glib_major_version], [2])
 m4_define([glib_minor_version], [19])
-m4_define([glib_micro_version], [6])
+m4_define([glib_micro_version], [7])
 m4_define([glib_interface_age], [0])
 m4_define([glib_binary_age],
           [m4_eval(100 * glib_minor_version + glib_micro_version)])
@@ -953,6 +953,50 @@ AC_CHECK_FUNCS(_NSGetEnviron)
 AC_FUNC_VSNPRINTF_C99
 AC_FUNC_PRINTF_UNIX98
 
+# Internet address families
+if test $glib_native_win32 = yes; then
+  glib_inet_includes=["
+#include <winsock2.h>
+  "]
+else
+  glib_inet_includes=["
+#include <sys/socket.h>
+  "]
+fi
+
+glib_failed=false
+GLIB_CHECK_VALUE(AF_INET, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(AF_INET6, $glib_inet_includes, glib_failed=true)
+# winsock defines this even though it doesn't support it
+GLIB_CHECK_VALUE(AF_UNIX, $glib_inet_includes, glib_failed=true)
+if $glib_failed ; then
+  AC_MSG_ERROR([Could not determine values for AF_INET* constants])
+fi
+
+# For gio/libasyncns
+if test $glib_native_win32 = no; then
+  AC_CHECK_FUNCS(strndup setresuid setreuid)
+  AC_CHECK_HEADERS(sys/prctl.h arpa/nameser_compat.h)
+  AC_CHECK_FUNC(res_query, ,
+    [AC_CHECK_LIB(resolv, res_query, [ LIBASYNCNS_LIBADD="-lresolv" ],
+      [ save_libs="$LIBS"
+        LIBS="-lresolv $LIBS"
+        AC_MSG_CHECKING([for res_query in -lresolv (alternate version)])
+        AC_LINK_IFELSE(
+          [AC_LANG_PROGRAM([[#include <resolv.h>]], [[res_query(0,0,0,0,0)]])],
+          [ AC_MSG_RESULT(yes)
+  	  LIBASYNCNS_LIBADD="-lresolv" ],
+          [ AC_MSG_RESULT(no)
+            AC_CHECK_LIB(bind, res_query,
+              [ LIBASYNCNS_LIBADD="-lbind" ],
+  	    [ AC_MSG_ERROR(res_query not found) ] ) ] )
+        LIBS="$save_libs"
+      ] )
+    ]
+  )
+  AC_SUBST(LIBASYNCNS_LIBADD)
+fi
+
 dnl
 dnl if statfs() takes 2 arguments (Posix) or 4 (Solaris)
 dnl
@@ -2985,6 +3029,10 @@ _______EOF
  */
 typedef $g_pid_type GPid;
 
+#define GLIB_SYSDEF_AF_UNIX $g_af_unix
+#define GLIB_SYSDEF_AF_INET $g_af_inet
+#define GLIB_SYSDEF_AF_INET6 $g_af_inet6
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
@@ -3271,6 +3319,10 @@ g_pollhup=$glib_cv_value_POLLHUP
 g_pollerr=$glib_cv_value_POLLERR
 g_pollnval=$glib_cv_value_POLLNVAL
 
+g_af_unix=$glib_cv_value_AF_UNIX
+g_af_inet=$glib_cv_value_AF_INET
+g_af_inet6=$glib_cv_value_AF_INET6
+
 g_stack_grows=$glib_cv_stack_grows
 
 g_have_eilseq=$have_eilseq
@@ -3355,6 +3407,7 @@ gthread/Makefile
 gio/Makefile
 gio/xdgmime/Makefile
 gio/inotify/Makefile
+gio/libasyncns/Makefile
 gio/fen/Makefile
 gio/fam/Makefile
 gio/win32/Makefile
diff --git a/docs/reference/ChangeLog b/docs/reference/ChangeLog
index 5f4e455..61d645b 100644
--- a/docs/reference/ChangeLog
+++ b/docs/reference/ChangeLog
@@ -1,3 +1,12 @@
+2009-02-06  Stefan Kost  <ensonic@users.sf.net>
+
+	* gio/gio-docs.xml:
+	* glib/glib-docs.sgml:
+	* gobject/gobject-docs.sgml:
+	  Add online urls for library.gnome.org. This allows other docs to do
+          gtkdoc-rebase --online --html-dir=html
+          before publishing docs and have working xrefs.
+
 2009-02-02  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.6 ===
diff --git a/docs/reference/gio/Makefile.am b/docs/reference/gio/Makefile.am
index 43e003f..1cd0cdc 100644
--- a/docs/reference/gio/Makefile.am
+++ b/docs/reference/gio/Makefile.am
@@ -43,11 +43,14 @@ IGNORE_HFILES=				\
 	glocalvfs.h			\
 	gnativevolumemonitor.h		\
 	gpollfilemonitor.h		\
+	gthreadedresolver.h		\
 	gunionvolumemonitor.h		\
 	gunixdrive.h			\
+	gunixresolver.h			\
 	gunixvolume.h			\
 	gvolumeprivate.h		\
 	gwin32appinfo.h			\
+	gwin32resolver.h		\
 	inotify-diag.h			\
 	inotify-helper.h		\
 	inotify-kernel.h		\
@@ -85,7 +88,8 @@ GTKDOC_LIBS = \
 	$(NULL)
 
 # Extra options to supply to gtkdoc-mkdb
-MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g
+MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g \
+	--ignore-files=libasyncns
 
 # Images to copy into HTML directory
 HTML_IMAGES =			\
diff --git a/docs/reference/gio/gio-docs.xml b/docs/reference/gio/gio-docs.xml
index dfe2fb5..0b0208a 100644
--- a/docs/reference/gio/gio-docs.xml
+++ b/docs/reference/gio/gio-docs.xml
@@ -7,7 +7,11 @@
 <title>GIO Reference Manual</title>
   <bookinfo>
     <title>GIO Reference Manual</title>
-    <releaseinfo>for GIO &version;</releaseinfo>
+    <releaseinfo>
+      for GIO &version;
+      The latest version of this documentation can be found on-line at
+      <ulink role="online-location" url="http://library.gnome.org/devel/gio/unstable/">http://library.gnome.org/devel/gio/unstable/</ulink>.
+    </releaseinfo>
   </bookinfo>
 
   <xi:include href="xml/overview.xml"/>
@@ -86,6 +90,18 @@
     	<xi:include href="xml/gemblemedicon.xml"/>
     	<xi:include href="xml/gemblem.xml"/>
     </chapter>
+    <chapter id="networking">
+    	<title>Networking</title>
+        <xi:include href="xml/gresolver.xml"/>
+        <xi:include href="xml/ginetaddress.xml"/>
+        <xi:include href="xml/gsocketaddress.xml"/>
+        <xi:include href="xml/ginetsocketaddress.xml"/>
+        <xi:include href="xml/gunixsocketaddress.xml"/>
+        <xi:include href="xml/gsrvtarget.xml"/>
+        <xi:include href="xml/gsocketconnectable.xml"/>
+        <xi:include href="xml/gnetworkaddress.xml"/>
+        <xi:include href="xml/gnetworkservice.xml"/>
+    </chapter>
     <chapter id="utils">   
     	<title>Utilities</title>
         <xi:include href="xml/gfilenamecompleter.xml"/>
diff --git a/docs/reference/gio/gio-sections.txt b/docs/reference/gio/gio-sections.txt
index 391dfaf..a969a8b 100644
--- a/docs/reference/gio/gio-sections.txt
+++ b/docs/reference/gio/gio-sections.txt
@@ -1310,4 +1310,208 @@ g_io_extension_point_set_required_type
 g_io_extension_ref_class
 </SECTION>
 
+<SECTION>
+<FILE>ginetaddress</FILE>
+<TITLE>GInetAddress</TITLE>
+GInetAddress
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_to_bytes
+g_inet_address_to_string
+g_inet_address_get_family
+g_inet_address_is_any
+g_inet_address_is_link_local
+g_inet_address_is_loopback
+g_inet_address_is_mc_global
+g_inet_address_is_mc_link_local
+g_inet_address_is_mc_node_local
+g_inet_address_is_mc_org_local
+g_inet_address_is_mc_site_local
+g_inet_address_is_multicast
+g_inet_address_is_site_local
+<SUBSECTION Standard>
+GInetAddressClass
+GInetAddressPrivate
+G_INET_ADDRESS
+G_INET_ADDRESS_CLASS
+G_INET_ADDRESS_GET_CLASS
+G_IS_INET_ADDRESS
+G_IS_INET_ADDRESS_CLASS
+G_TYPE_INET_ADDRESS
+<SUBSECTION Private>
+g_inet_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketaddress</FILE>
+<TITLE>GSocketAddress</TITLE>
+GSocketAddress
+GSocketAddressFamily
+g_socket_address_new_from_native
+g_socket_address_get_family
+g_socket_address_to_native
+g_socket_address_get_native_size
+<SUBSECTION Standard>
+GSocketAddressClass
+G_IS_SOCKET_ADDRESS
+G_IS_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS
+G_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS_GET_CLASS
+G_TYPE_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>ginetsocketaddress</FILE>
+<TITLE>GInetSocketAddress</TITLE>
+GInetSocketAddress
+g_inet_socket_address_new
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+<SUBSECTION Standard>
+GInetSocketAddressClass
+GInetSocketAddressPrivate
+G_INET_SOCKET_ADDRESS
+G_INET_SOCKET_ADDRESS_CLASS
+G_INET_SOCKET_ADDRESS_GET_CLASS
+G_IS_INET_SOCKET_ADDRESS
+G_IS_INET_SOCKET_ADDRESS_CLASS
+G_TYPE_INET_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_inet_socket_address_get_type
+</SECTION>
 
+<SECTION>
+<FILE>gunixsocketaddress</FILE>
+<TITLE>GUnixSocketAddress</TITLE>
+GUnixSocketAddress
+g_unix_socket_address_new
+<SUBSECTION Standard>
+GUnixSocketAddressClass
+GUnixSocketAddressPrivate
+G_IS_UNIX_SOCKET_ADDRESS
+G_IS_UNIX_SOCKET_ADDRESS_CLASS
+G_TYPE_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS_CLASS
+G_UNIX_SOCKET_ADDRESS_GET_CLASS
+<SUBSECTION Private>
+g_unix_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gresolver</FILE>
+<TITLE>GResolver</TITLE>
+GResolver
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_free_addresses
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+g_resolver_free_targets
+<SUBSECTION>
+G_RESOLVER_ERROR
+GResolverError
+<SUBSECTION Standard>
+GResolverClass
+G_IS_RESOLVER
+G_IS_RESOLVER_CLASS
+G_RESOLVER
+G_RESOLVER_CLASS
+G_RESOLVER_GET_CLASS
+G_TYPE_RESOLVER
+<SUBSECTION Private>
+g_resolver_get_type
+g_resolver_error_quark
+</SECTION>
+
+<SECTION>
+<FILE>gsrvtarget</FILE>
+<TITLE>GSrvTarget</TITLE>
+GSrvTarget
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_array_sort
+<SUBSECTION Standard>
+G_TYPE_SRV_TARGET
+<SUBSECTION Private>
+g_srv_target_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketconnectable</FILE>
+<TITLE>GSocketConnectable</TITLE>
+GSocketConnectable
+GSocketConnectableIface
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_reset
+<SUBSECTION Standard>
+G_IS_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE_GET_IFACE
+G_TYPE_SOCKET_CONNECTABLE
+<SUBSECTION Private>
+g_socket_connectable_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkaddress</FILE>
+<TITLE>GNetworkAddress</TITLE>
+GNetworkAddress
+g_network_address_new
+g_network_address_get_hostname
+g_network_address_get_ascii_name
+g_network_address_get_port
+<SUBSECTION Standard>
+GNetworkAddressClass
+GNetworkAddressPrivate
+G_IS_NETWORK_ADDRESS
+G_IS_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS
+G_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS_GET_CLASS
+G_TYPE_NETWORK_ADDRESS
+<SUBSECTION Private>
+g_network_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkservice</FILE>
+<TITLE>GNetworkService</TITLE>
+GNetworkService
+g_network_service_new
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_get_expires
+<SUBSECTION Standard>
+GNetworkServiceClass
+GNetworkServicePrivate
+G_IS_NETWORK_SERVICE
+G_IS_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE
+G_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE_GET_CLASS
+G_TYPE_NETWORK_SERVICE
+<SUBSECTION Private>
+g_network_service_get_type
+</SECTION>
diff --git a/docs/reference/gio/gio.types b/docs/reference/gio/gio.types
index c73282a..8fb70f5 100644
--- a/docs/reference/gio/gio.types
+++ b/docs/reference/gio/gio.types
@@ -36,6 +36,8 @@ g_file_type_get_type
 g_filter_input_stream_get_type
 g_filter_output_stream_get_type
 g_icon_get_type
+g_inet_address_get_type
+g_inet_socket_address_get_type
 g_input_stream_get_type
 g_io_error_enum_get_type
 g_io_module_get_type
@@ -50,15 +52,21 @@ g_mount_operation_get_type
 g_mount_operation_result_get_type
 g_mount_unmount_flags_get_type
 g_native_volume_monitor_get_type
+g_network_address_get_type
+g_network_service_get_type
 g_output_stream_get_type
 g_output_stream_splice_flags_get_type
 g_password_save_get_type
+g_resolver_get_type
 g_seekable_get_type
 g_simple_async_result_get_type
+g_socket_address_get_type
+g_socket_connectable_get_type
 g_themed_icon_get_type
 g_unix_input_stream_get_type
 g_unix_mount_monitor_get_type
 g_unix_output_stream_get_type
+g_unix_socket_address_get_type
 g_vfs_get_type
 g_volume_get_type
 g_volume_monitor_get_type
diff --git a/docs/reference/glib/glib-docs.sgml b/docs/reference/glib/glib-docs.sgml
index 390fd4b..4d7c36d 100644
--- a/docs/reference/glib/glib-docs.sgml
+++ b/docs/reference/glib/glib-docs.sgml
@@ -66,6 +66,7 @@
 <!ENTITY glib-Version SYSTEM "xml/version.xml">
 <!ENTITY glib-Uri SYSTEM "xml/gurifuncs.xml">
 <!ENTITY glib-Testing SYSTEM "xml/testing.xml">
+<!ENTITY glib-Hostutils SYSTEM "xml/ghostutils.xml">
 
 <!ENTITY glib-Compiling SYSTEM "compiling.sgml">
 <!ENTITY glib-Building SYSTEM "building.sgml">
@@ -84,7 +85,11 @@
 <book id="index">
   <bookinfo>
     <title>GLib Reference Manual</title>
-    <releaseinfo>for GLib &version;</releaseinfo>
+    <releaseinfo>
+      for GLib &version;
+      The latest version of this documentation can be found on-line at
+      <ulink role="online-location" url="http://library.gnome.org/devel/glib/unstable/">http://library.gnome.org/devel/glib/unstable/</ulink>.
+    </releaseinfo>
   </bookinfo>
 
   <chapter id="glib">
@@ -158,6 +163,7 @@ synchronize their operation.
     &glib-Spawn;
     &glib-Fileutils;
     &glib-Uri;
+    &glib-Hostutils;
     &glib-Shell;
     &glib-Option;
     &glib-Pattern-Matching;
diff --git a/docs/reference/glib/glib-sections.txt b/docs/reference/glib/glib-sections.txt
index 6df70cb..4feea78 100644
--- a/docs/reference/glib/glib-sections.txt
+++ b/docs/reference/glib/glib-sections.txt
@@ -2653,3 +2653,16 @@ g_test_log_buffer_push
 g_test_log_buffer_pop
 g_test_log_msg_free
 </SECTION>
+
+
+<SECTION>
+<FILE>ghostutils</FILE>
+<TITLE>Hostname Utilities</TITLE>
+g_hostname_to_ascii
+g_hostname_to_unicode
+<SUBSECTION>
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+<SUBSECTION>
+g_hostname_is_ip_address
+</SECTION>
diff --git a/docs/reference/glib/tmpl/ghostutils.sgml b/docs/reference/glib/tmpl/ghostutils.sgml
new file mode 100644
index 0000000..b619912
--- /dev/null
+++ b/docs/reference/glib/tmpl/ghostutils.sgml
@@ -0,0 +1,66 @@
+<!-- ##### SECTION Title ##### -->
+Hostname Utilities
+
+<!-- ##### SECTION Short_Description ##### -->
+
+
+<!-- ##### SECTION Long_Description ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION See_Also ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION Stability_Level ##### -->
+
+
+<!-- ##### FUNCTION g_hostname_to_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_to_unicode ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_non_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ascii_encoded ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ip_address ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
diff --git a/docs/reference/gobject/gobject-docs.sgml b/docs/reference/gobject/gobject-docs.sgml
index a37b262..ef93c7e 100644
--- a/docs/reference/gobject/gobject-docs.sgml
+++ b/docs/reference/gobject/gobject-docs.sgml
@@ -30,7 +30,11 @@
 <book id="index">
   <bookinfo>
     <title>GObject Reference Manual</title>
-    <releaseinfo>for GLib &version;</releaseinfo>
+    <releaseinfo>
+      for GObject &version;
+      The latest version of this documentation can be found on-line at
+      <ulink role="online-location" url="http://library.gnome.org/devel/gobject/unstable/">http://library.gnome.org/devel/gobject/unstable/</ulink>.
+    </releaseinfo>
   </bookinfo>
 
   <preface>
diff --git a/gio/ChangeLog b/gio/ChangeLog
index 321f75a..fb38aff 100644
--- a/gio/ChangeLog
+++ b/gio/ChangeLog
@@ -1,3 +1,19 @@
+2009-02-11  Matthias Clasen  <mclasen@redhat.com>
+
+	Bug 541225 – Can't compile gio on AIX : duplicate case value in 
+	gioerror.c
+
+	* gioerror.c (g_io_error_from_errno): Cope with EEXIST == ENOTEMPTY. 
+	Reported by Nicolas Joseph 
+
+2009-02-04  Alexander Larsson  <alexl@redhat.com>
+
+	Bug 566747 - URIs opened with firefox %u load as local files
+
+	* gdummyfile.c (g_dummy_file_get_path):
+	Dummy files are never used for local paths, so always return NULL
+	in get_path(). 
+
 2009-02-02  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.6 ===
diff --git a/gio/Makefile.am b/gio/Makefile.am
index be6568f..7e7c2d5 100644
--- a/gio/Makefile.am
+++ b/gio/Makefile.am
@@ -5,7 +5,7 @@ NULL =
 SUBDIRS=
 
 if OS_UNIX
-SUBDIRS += xdgmime
+SUBDIRS += libasyncns xdgmime
 endif
 
 if OS_WIN32_AND_DLL_COMPILATION
@@ -125,13 +125,16 @@ endif
 
 if OS_UNIX
 appinfo_sources += gdesktopappinfo.c gdesktopappinfo.h
-platform_libadd += xdgmime/libxdgmime.la
-platform_deps += xdgmime/libxdgmime.la
+platform_libadd += libasyncns/libasyncns.la xdgmime/libxdgmime.la
+platform_deps += libasyncns/libasyncns.la xdgmime/libxdgmime.la
 unix_sources = \
 	gunixmount.c		\
 	gunixmount.h		\
 	gunixmounts.c 		\
 	gunixmounts.h 		\
+	gunixresolver.c		\
+	gunixresolver.h		\
+	gunixsocketaddress.c	\
 	gunixvolume.c 		\
 	gunixvolume.h 		\
 	gunixvolumemonitor.c 	\
@@ -147,15 +150,18 @@ giounixinclude_HEADERS = \
 	gunixmounts.h 		\
 	gunixinputstream.h 	\
 	gunixoutputstream.h 	\
+	gunixsocketaddress.h	\
 	$(NULL)
 endif
 
 if OS_WIN32
 appinfo_sources += gwin32appinfo.c gwin32appinfo.h
-platform_libadd += -lshlwapi
+platform_libadd += -lshlwapi -lws2_32 -ldnsapi
 win32_sources = \
 	gwin32mount.c \
 	gwin32mount.h \
+	gwin32resolver.c \
+	gwin32resolver.h \
 	gwin32volumemonitor.c \
 	gwin32volumemonitor.h \
 	$(NULL)
@@ -196,6 +202,8 @@ libgio_2_0_la_SOURCES =		\
 	gfilterinputstream.c 	\
 	gfilteroutputstream.c 	\
 	gicon.c 		\
+	ginetaddress.c		\
+	ginetsocketaddress.c	\
 	ginputstream.c 		\
 	gioenums.h		\
 	gioerror.c 		\
@@ -209,12 +217,21 @@ libgio_2_0_la_SOURCES =		\
 	gmountoperation.c 	\
 	gnativevolumemonitor.c 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.c	\
+	gnetworkingprivate.h	\
+	gnetworkservice.c	\
 	goutputstream.c 	\
 	gpollfilemonitor.c 	\
 	gpollfilemonitor.h 	\
+	gresolver.c		\
 	gseekable.c 		\
 	gsimpleasyncresult.c 	\
+	gsocketaddress.c	\
+	gsocketconnectable.c	\
+	gsrvtarget.c		\
 	gthemedicon.c 		\
+	gthreadedresolver.c	\
+	gthreadedresolver.h	\
 	gunionvolumemonitor.c 	\
 	gunionvolumemonitor.h 	\
 	gvfs.c 			\
@@ -299,6 +316,8 @@ gio_headers =			\
 	gfilterinputstream.h 	\
 	gfilteroutputstream.h 	\
 	gicon.h 		\
+	ginetaddress.h		\
+	ginetsocketaddress.h	\
 	ginputstream.h 		\
 	gio.h			\
 	giotypes.h		\
@@ -312,9 +331,15 @@ gio_headers =			\
 	gmemoryoutputstream.h 	\
 	gmountoperation.h 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.h	\
+	gnetworkservice.h	\
 	goutputstream.h 	\
+	gresolver.h		\
 	gseekable.h 		\
 	gsimpleasyncresult.h 	\
+	gsocketaddress.h	\
+	gsocketconnectable.h	\
+	gsrvtarget.h		\
 	gthemedicon.h 		\
 	gvfs.h 			\
 	gvolume.h 		\
diff --git a/gio/gdatainputstream.c b/gio/gdatainputstream.c
index 387fede..3e8ce0e 100644
--- a/gio/gdatainputstream.c
+++ b/gio/gdatainputstream.c
@@ -861,7 +861,7 @@ scan_for_chars (GDataInputStream *stream,
  * @error: #GError for error reporting.
  * 
  * Reads a string from the data input stream, up to the first 
- * occurrance of any of the stop characters.
+ * occurrence of any of the stop characters.
  *
  * Returns: a string with the data that was read before encountering 
  * any of the stop characters. Set @length to a #gsize to get the length 
diff --git a/gio/gdummyfile.c b/gio/gdummyfile.c
index 6a5883f..1033b4e 100644
--- a/gio/gdummyfile.c
+++ b/gio/gdummyfile.c
@@ -144,10 +144,6 @@ g_dummy_file_get_basename (GFile *file)
 static char *
 g_dummy_file_get_path (GFile *file)
 {
-  GDummyFile *dummy = G_DUMMY_FILE (file);
-
-  if (dummy->decoded_uri)
-    return g_strdup (dummy->decoded_uri->path);
   return NULL;
 }
 
diff --git a/gio/gfilterinputstream.c b/gio/gfilterinputstream.c
index 86d001e..aa27465 100644
--- a/gio/gfilterinputstream.c
+++ b/gio/gfilterinputstream.c
@@ -132,7 +132,7 @@ g_filter_input_stream_class_init (GFilterInputStreamClass *klass)
                                    PROP_BASE_STREAM,
                                    g_param_spec_object ("base-stream",
                                                          P_("The Filter Base Stream"),
-                                                         P_("The underlying base stream the io ops will be done on"),
+                                                         P_("The underlying base stream on which the io ops will be done."),
                                                          G_TYPE_INPUT_STREAM,
                                                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | 
                                                          G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB));
@@ -141,7 +141,7 @@ g_filter_input_stream_class_init (GFilterInputStreamClass *klass)
                                    PROP_CLOSE_BASE,
                                    g_param_spec_boolean ("close-base-stream",
                                                          P_("Close Base Stream"),
-                                                         P_("If the base stream be closed when the filter stream is"),
+                                                         P_("If the base stream should be closed when the filter stream is closed."),
                                                          TRUE, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | 
                                                          G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB));
 }
diff --git a/gio/gfilteroutputstream.c b/gio/gfilteroutputstream.c
index 8706941..32fc6f7 100644
--- a/gio/gfilteroutputstream.c
+++ b/gio/gfilteroutputstream.c
@@ -131,7 +131,7 @@ g_filter_output_stream_class_init (GFilterOutputStreamClass *klass)
                                    PROP_BASE_STREAM,
                                    g_param_spec_object ("base-stream",
                                                          P_("The Filter Base Stream"),
-                                                         P_("The underlying base stream the io ops will be done on"),
+                                                         P_("The underlying base stream on which the io ops will be done."),
                                                          G_TYPE_OUTPUT_STREAM,
                                                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | 
                                                          G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB));
@@ -140,7 +140,7 @@ g_filter_output_stream_class_init (GFilterOutputStreamClass *klass)
                                    PROP_CLOSE_BASE,
                                    g_param_spec_boolean ("close-base-stream",
                                                          P_("Close Base Stream"),
-                                                         P_("If the base stream be closed when the filter stream is"),
+                                                         P_("If the base stream should be closed when the filter stream is closed."),
                                                          TRUE, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
                                                          G_PARAM_STATIC_NAME|G_PARAM_STATIC_NICK|G_PARAM_STATIC_BLURB));
 }
diff --git a/gio/ginetaddress.c b/gio/ginetaddress.c
new file mode 100644
index 0000000..12b3025
--- /dev/null
+++ b/gio/ginetaddress.c
@@ -0,0 +1,718 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "ginetaddress.h"
+#include "gioenums.h"
+#include "gioenumtypes.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetaddress
+ * @short_description: An IPv4/IPv6 address
+ *
+ * #GInetAddress represents an IPv4 or IPv6 internet address. Use
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
+ * look up the #GInetAddress for a hostname. Use
+ * g_resolver_lookup_by_address() or
+ * g_resolver_lookup_by_address_async() to look up the hostname for a
+ * #GInetAddress.
+ *
+ * To actually connect to a remote host, you will need a
+ * #GInetSocketAddress (which includes a #GInetAddress as well as a
+ * port number).
+ **/
+
+/**
+ * GInetAddress:
+ *
+ * An IPv4 or IPv6 internet address.
+ **/
+
+/* Networking initialization function, called from inside the g_once of
+ * g_inet_address_get_type()
+ */
+static void
+_g_networking_init (void)
+{
+#ifdef G_OS_WIN32
+  WSADATA wsadata;
+  if (WSAStartup (MAKEWORD (2, 0), &wsadata) != 0)
+    g_error ("Windows Sockets could not be initialized");
+#endif
+}
+
+G_DEFINE_TYPE_WITH_CODE (GInetAddress, g_inet_address, G_TYPE_OBJECT,
+			 _g_networking_init ();)
+
+struct _GInetAddressPrivate
+{
+  GSocketAddressFamily family;
+  union {
+    struct in_addr ipv4;
+    struct in6_addr ipv6;
+  } addr;
+};
+
+enum
+{
+  PROP_0,
+  PROP_FAMILY,
+  PROP_BYTES,
+  PROP_IS_ANY,
+  PROP_IS_LOOPBACK,
+  PROP_IS_LINK_LOCAL,
+  PROP_IS_SITE_LOCAL,
+  PROP_IS_MULTICAST,
+  PROP_IS_MC_GLOBAL,
+  PROP_IS_MC_LINK_LOCAL,
+  PROP_IS_MC_NODE_LOCAL,
+  PROP_IS_MC_ORG_LOCAL,
+  PROP_IS_MC_SITE_LOCAL,
+};
+
+static void
+g_inet_address_set_property (GObject      *object,
+			     guint         prop_id,
+			     const GValue *value,
+			     GParamSpec   *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_FAMILY:
+      address->priv->family = g_value_get_enum (value);
+      break;
+
+    case PROP_BYTES:
+      memcpy (&address->priv->addr, g_value_get_pointer (value),
+	      address->priv->family == AF_INET ?
+	      sizeof (address->priv->addr.ipv4) :
+	      sizeof (address->priv->addr.ipv6));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_inet_address_get_property (GObject    *object,
+                             guint       prop_id,
+                             GValue     *value,
+                             GParamSpec *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+    case PROP_FAMILY:
+      g_value_set_enum (value, address->priv->family);
+      break;
+
+    case PROP_BYTES:
+      g_value_set_pointer (value, &address->priv->addr);
+      break;
+
+    case PROP_IS_ANY:
+      g_value_set_boolean (value, g_inet_address_is_any (address));
+      break;
+
+    case PROP_IS_LOOPBACK:
+      g_value_set_boolean (value, g_inet_address_is_loopback (address));
+      break;
+
+    case PROP_IS_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_link_local (address));
+      break;
+
+    case PROP_IS_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_site_local (address));
+      break;
+
+    case PROP_IS_MULTICAST:
+      g_value_set_boolean (value, g_inet_address_is_multicast (address));
+      break;
+
+    case PROP_IS_MC_GLOBAL:
+      g_value_set_boolean (value, g_inet_address_is_mc_global (address));
+      break;
+
+    case PROP_IS_MC_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_mc_link_local (address));
+      break;
+
+    case PROP_IS_MC_NODE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_mc_node_local (address));
+      break;
+
+    case PROP_IS_MC_ORG_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_mc_org_local (address));
+      break;
+
+    case PROP_IS_MC_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_is_mc_site_local (address));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_address_class_init (GInetAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetAddressPrivate));
+
+  gobject_class->set_property = g_inet_address_set_property;
+  gobject_class->get_property = g_inet_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The address family (IPv4 or IPv6)"),
+						      G_TYPE_SOCKET_ADDRESS_FAMILY,
+						      G_SOCKET_ADDRESS_INVALID,
+						      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_BYTES,
+                                   g_param_spec_pointer ("bytes",
+							 _("Bytes"),
+							 _("The raw address data"),
+							 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_ANY,
+                                   g_param_spec_boolean ("is-any",
+                                                         _("Is any"),
+                                                         _("See g_inet_address_is_any()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-link-local",
+                                                         _("Is link-local"),
+                                                         _("See g_inet_address_is_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LOOPBACK,
+                                   g_param_spec_boolean ("is-loopback",
+                                                         _("Is loopback"),
+                                                         _("See g_inet_address_is_loopback()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-site-local",
+                                                         _("Is site-local"),
+                                                         _("See g_inet_address_is_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MULTICAST,
+                                   g_param_spec_boolean ("is-multicast",
+                                                         _("Is multicast"),
+                                                         _("See g_inet_address_is_multicast()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_GLOBAL,
+                                   g_param_spec_boolean ("is-mc-global",
+                                                         _("Is multicast global"),
+                                                         _("See g_inet_address_is_mc_global()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-mc-link-local",
+                                                         _("Is multicast link-local"),
+                                                         _("See g_inet_address_is_mc_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_NODE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-node-local",
+                                                         _("Is multicast node-local"),
+                                                         _("See g_inet_address_is_mc_node_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_ORG_LOCAL,
+                                   g_param_spec_boolean ("is-mc-org-local",
+                                                         _("Is multicast org-local"),
+                                                         _("See g_inet_address_is_mc_org_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-site-local",
+                                                         _("Is multicast site-local"),
+                                                         _("See g_inet_address_is_mc_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_inet_address_init (GInetAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_ADDRESS,
+                                               GInetAddressPrivate);
+}
+
+/**
+ * g_inet_address_new_from_string:
+ * @string: a string representation of an IP address
+ *
+ * Parses @string as an IP address and creates a new #GInetAddress.
+ *
+ * Returns: a new #GInetAddress corresponding to @string, or %NULL if
+ * @string could not be parsed.
+ */
+GInetAddress *
+g_inet_address_new_from_string (const gchar *string)
+{
+#ifdef G_OS_WIN32
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+  gint len;
+#else /* !G_OS_WIN32 */
+  struct in_addr in_addr;
+  struct in6_addr in6_addr;
+#endif
+
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+#ifdef G_OS_WIN32
+  memset (&sa, 0, sizeof (sa));
+  len = sizeof (sa);
+  if (WSAStringToAddress ((LPTSTR) string, AF_INET, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin->sin_addr, AF_INET);
+  else if (WSAStringToAddress ((LPTSTR) string, AF_INET6, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin6->sin6_addr, AF_INET6);
+
+#else /* !G_OS_WIN32 */
+
+  if (inet_pton (AF_INET, string, &in_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in_addr, AF_INET);
+  else if (inet_pton (AF_INET6, string, &in6_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in6_addr, AF_INET6);
+#endif
+
+  return NULL;
+}
+
+#define G_INET_ADDRESS_FAMILY_IS_VALID(family) ((family) == AF_INET || (family) == AF_INET6)
+
+/**
+ * g_inet_address_new_from_bytes:
+ * @bytes: raw address data
+ * @family: the address family of @bytes
+ *
+ * Creates a new #GInetAddress from the given @family and @bytes.
+ * @bytes should be 4 bytes for %G_INET_ADDRESS_IPV4 and 16 bytes for
+ * %G_INET_ADDRESS_IPV6.
+ *
+ * Returns: a new #GInetAddress corresponding to @family and @bytes.
+ */
+GInetAddress *
+g_inet_address_new_from_bytes (const guint8         *bytes,
+			       GSocketAddressFamily  family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  return g_object_new (G_TYPE_INET_ADDRESS,
+		       "family", family,
+		       "bytes", bytes,
+		       NULL);
+}
+
+/**
+ * g_inet_address_new_loopback:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the loopback address for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the loopback address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_loopback (GSocketAddressFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {127, 0, 0, 1};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_loopback.s6_addr, family);
+}
+
+/**
+ * g_inet_address_new_any:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the "any" address (unassigned/"don't
+ * care") for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the "any" address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_any (GSocketAddressFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {0, 0, 0, 0};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_any.s6_addr, family);
+}
+
+
+/**
+ * g_inet_address_to_string:
+ * @address: a #GInetAddress
+ *
+ * Converts @address to string form.
+ *
+ * Returns: a representation of @address as a string, which should be
+ * freed after use.
+ */
+gchar *
+g_inet_address_to_string (GInetAddress *address)
+{
+  gchar buffer[INET6_ADDRSTRLEN];
+#ifdef G_OS_WIN32
+  DWORD buflen = sizeof (buffer), addrlen;
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+#endif
+
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+#ifdef G_OS_WIN32
+  sa.ss_family = address->priv->family;
+  if (address->priv->family == AF_INET)
+    {
+      addrlen = sizeof (*sin);
+      memcpy (&sin->sin_addr, &address->priv->addr.ipv4,
+	      sizeof (sin->sin_addr));
+      sin->sin_port = 0;
+    }
+  else
+    {
+      addrlen = sizeof (*sin6);
+      memcpy (&sin6->sin6_addr, &address->priv->addr.ipv6,
+	      sizeof (sin6->sin6_addr));
+      sin6->sin6_port = 0;
+    }
+  if (WSAAddressToString ((LPSOCKADDR) &sa, addrlen, NULL, buffer, &buflen) != 0)
+    return NULL;
+
+#else /* !G_OS_WIN32 */
+
+  if (address->priv->family == AF_INET)
+    inet_ntop (AF_INET, &address->priv->addr.ipv4, buffer, sizeof (buffer));
+  else
+    inet_ntop (AF_INET6, &address->priv->addr.ipv6, buffer, sizeof (buffer));
+#endif
+
+  return g_strdup (buffer);
+}
+
+/**
+ * g_inet_address_to_bytes:
+ * @address: a #GInetAddress
+ *
+ * Gets the raw binary address data from @address.
+ *
+ * Returns: a pointer to an internal array of the bytes in @address,
+ * which should not be modified, stored, or freed.
+ */
+const guint8 *
+g_inet_address_to_bytes (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return (guint8 *)&address->priv->addr;
+}
+
+/**
+ * g_inet_address_get_family:
+ * @address: a #GInetAddress
+ *
+ * Gets @address's family
+ *
+ * Returns: @address's family
+ */
+GSocketAddressFamily
+g_inet_address_get_family (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  return address->priv->family;
+}
+
+/**
+ * g_inet_address_is_any:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the "any" address for its family.
+ *
+ * Returns: %TRUE if @address is the "any" address for its family.
+ */
+gboolean
+g_inet_address_is_any (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return addr4 == INADDR_ANY;
+    }
+  else
+    return IN6_IS_ADDR_UNSPECIFIED (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_loopback:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the loopback address for its family.
+ *
+ * Returns: %TRUE if @address is the loopback address for its family.
+ */
+gboolean
+g_inet_address_is_loopback (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 127.0.0.0/8 */
+      return ((addr4 & 0xff000000) == 0x7f000000);
+    }
+  else
+    return IN6_IS_ADDR_LOOPBACK (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local address (that is, if it
+ * identifies a host on a local network that is not connected to the
+ * Internet).
+ *
+ * Returns: %TRUE if @address is a link-local address.
+ */
+gboolean
+g_inet_address_is_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 169.254.0.0/16 */
+      return ((addr4 & 0xffff0000) == 0xa9fe0000);
+    }
+  else
+    return IN6_IS_ADDR_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local address such as 10.0.0.1
+ * (that is, the address identifies a host on a local network that can
+ * not be reached directly from the Internet, but which may have
+ * outgoing Internet connectivity via a NAT or firewall).
+ *
+ * Returns: %TRUE if @address is a site-local address.
+ */
+gboolean
+g_inet_address_is_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 */
+      return ((addr4 & 0xff000000) == 0x0a000000 ||
+	      (addr4 & 0xfff00000) == 0xac100000 ||
+	      (addr4 & 0xffff0000) == 0xc0a80000);
+    }
+  else
+    return IN6_IS_ADDR_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_multicast:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a multicast address.
+ *
+ * Returns: %TRUE if @address is a multicast address.
+ */
+gboolean
+g_inet_address_is_multicast (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return IN_MULTICAST (addr4);
+    }
+  else
+    return IN6_IS_ADDR_MULTICAST (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_mc_global:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a global multicast address.
+ *
+ * Returns: %TRUE if @address is a global multicast address.
+ */
+gboolean
+g_inet_address_is_mc_global (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_GLOBAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_mc_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local multicast address.
+ *
+ * Returns: %TRUE if @address is a link-local multicast address.
+ */
+gboolean
+g_inet_address_is_mc_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_mc_node_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a node-local multicast address.
+ *
+ * Returns: %TRUE if @address is a node-local multicast address.
+ */
+gboolean
+g_inet_address_is_mc_node_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_NODELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_mc_org_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is an organization-local multicast address.
+ *
+ * Returns: %TRUE if @address is an organization-local multicast address.
+ */
+gboolean
+g_inet_address_is_mc_org_local  (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_ORGLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_is_mc_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local multicast address.
+ *
+ * Returns: %TRUE if @address is a site-local multicast address.
+ */
+gboolean
+g_inet_address_is_mc_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+#define __G_INET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetaddress.h b/gio/ginetaddress.h
new file mode 100644
index 0000000..8c6336a
--- /dev/null
+++ b/gio/ginetaddress.h
@@ -0,0 +1,101 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_ADDRESS_H__
+#define __G_INET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_ADDRESS         (g_inet_address_get_type ())
+#define G_INET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
+#define G_INET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
+#define G_IS_INET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
+#define G_IS_INET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
+#define G_INET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))
+
+typedef struct _GInetAddressClass   GInetAddressClass;
+typedef struct _GInetAddressPrivate GInetAddressPrivate;
+
+struct _GInetAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GInetAddressPrivate *priv;
+};
+
+struct _GInetAddressClass
+{
+  GObjectClass parent_class;
+
+  gchar *        (*to_string) (GInetAddress *address);
+  const guint8 * (*to_bytes)  (GInetAddress *address);
+};
+
+GType                 g_inet_address_get_type         (void) G_GNUC_CONST;
+
+GInetAddress *        g_inet_address_new_from_string  (const gchar          *string);
+
+GInetAddress *        g_inet_address_new_from_bytes   (const guint8         *bytes,
+						       GSocketAddressFamily  family);
+
+GInetAddress *        g_inet_address_new_loopback     (GSocketAddressFamily  family);
+
+GInetAddress *        g_inet_address_new_any          (GSocketAddressFamily  family);
+
+gchar *               g_inet_address_to_string        (GInetAddress         *address);
+
+const guint8 *        g_inet_address_to_bytes         (GInetAddress         *address);
+
+GSocketAddressFamily  g_inet_address_get_family       (GInetAddress         *address);
+
+gboolean              g_inet_address_is_any           (GInetAddress         *address);
+
+gboolean              g_inet_address_is_loopback      (GInetAddress         *address);
+
+gboolean              g_inet_address_is_link_local    (GInetAddress         *address);
+
+gboolean              g_inet_address_is_site_local    (GInetAddress         *address);
+
+gboolean              g_inet_address_is_multicast     (GInetAddress         *address);
+
+gboolean              g_inet_address_is_mc_global     (GInetAddress         *address);
+
+gboolean              g_inet_address_is_mc_link_local (GInetAddress         *address);
+
+gboolean              g_inet_address_is_mc_node_local (GInetAddress         *address);
+
+gboolean              g_inet_address_is_mc_org_local  (GInetAddress         *address);
+
+gboolean              g_inet_address_is_mc_site_local (GInetAddress         *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_ADDRESS_H__ */
+
diff --git a/gio/ginetsocketaddress.c b/gio/ginetsocketaddress.c
new file mode 100644
index 0000000..cae7d56
--- /dev/null
+++ b/gio/ginetsocketaddress.c
@@ -0,0 +1,300 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "ginetsocketaddress.h"
+#include "ginetaddress.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetsocketaddress
+ * @short_description: Internet socket addresses
+ *
+ * An IPv4 or IPv6 socket address; that is, the combination of a
+ * #GInetAddress and a port number.
+ **/
+
+/**
+ * GInetSocketAddress:
+ *
+ * An IPv4 or IPv6 socket address, corresponding to a <type>struct
+ * sockaddr_in</type> or <type>struct sockaddr_in6</type>.
+ **/
+G_DEFINE_TYPE (GInetSocketAddress, g_inet_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum {
+  PROP_0,
+  PROP_ADDRESS,
+  PROP_PORT
+};
+
+struct _GInetSocketAddressPrivate
+{
+  GInetAddress *address;
+  guint16       port;
+};
+
+static void
+g_inet_socket_address_finalize (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_inet_socket_address_dispose (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  g_object_unref (address->priv->address);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_inet_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        g_value_set_object (value, address->priv->address);
+        break;
+
+      case PROP_PORT:
+        g_value_set_uint (value, address->priv->port);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        address->priv->address = g_object_ref (g_value_get_object (value));
+        break;
+
+      case PROP_PORT:
+        address->priv->port = (guint16) g_value_get_uint (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketAddressFamily
+g_inet_socket_address_get_family (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+
+  return g_inet_address_get_family (addr->priv->address);
+}
+
+static gssize
+g_inet_socket_address_get_native_size (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+  GSocketAddressFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    return sizeof (struct sockaddr_in);
+  else if (family == AF_INET6)
+    return sizeof (struct sockaddr_in6);
+  else
+    return -1;
+}
+
+static gboolean
+g_inet_socket_address_to_native (GSocketAddress *address,
+                                 gpointer        dest,
+				 gsize           destlen)
+{
+  GInetSocketAddress *addr;
+  GSocketAddressFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *sock = (struct sockaddr_in *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      sock->sin_family = AF_INET;
+      sock->sin_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin_addr.s_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin_addr));
+      memset (sock->sin_zero, 0, sizeof (sock->sin_zero));
+      return TRUE;
+    }
+  else if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *sock = (struct sockaddr_in6 *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      memset (sock, 0, sizeof (sock));
+      sock->sin6_family = AF_INET6;
+      sock->sin6_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin6_addr.s6_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin6_addr));
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+static void
+g_inet_socket_address_class_init (GInetSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetSocketAddressPrivate));
+
+  gobject_class->finalize = g_inet_socket_address_finalize;
+  gobject_class->dispose = g_inet_socket_address_dispose;
+  gobject_class->set_property = g_inet_socket_address_set_property;
+  gobject_class->get_property = g_inet_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_inet_socket_address_get_family;
+  gsocketaddress_class->to_native = g_inet_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_inet_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class, PROP_ADDRESS,
+                                   g_param_spec_object ("address",
+                                                        "address",
+                                                        "address",
+                                                        G_TYPE_INET_ADDRESS,
+                                                        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      "port",
+                                                      "port",
+                                                      0,
+                                                      65535,
+                                                      0,
+                                                      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+}
+
+static void
+g_inet_socket_address_init (GInetSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_SOCKET_ADDRESS,
+                                               GInetSocketAddressPrivate);
+
+  address->priv->address = NULL;
+  address->priv->port = 0;
+}
+
+/**
+ * g_inet_socket_address_new:
+ * @address: a #GInetAddress
+ * @port: a port number
+ *
+ * Creates a new #GInetSocketAddress for @address and @port.
+ *
+ * Returns: a new #GInetSocketAddress
+ */
+GSocketAddress *
+g_inet_socket_address_new (GInetAddress *address,
+                           guint16       port)
+{
+  return g_object_new (G_TYPE_INET_SOCKET_ADDRESS,
+		       "address", address,
+		       "port", port,
+		       NULL);
+}
+
+/**
+ * g_inet_socket_address_get_address:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's #GInetAddress.
+ *
+ * Returns: the #GInetAddress for @address, which must be
+ * g_object_ref()'d if it will be stored
+ */
+GInetAddress *
+g_inet_socket_address_get_address (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), NULL);
+
+  return address->priv->address;
+}
+
+/**
+ * g_inet_socket_address_get_port:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's port.
+ *
+ * Returns: the port for @address
+ */
+guint16
+g_inet_socket_address_get_port (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  return address->priv->port;
+}
+
+#define __G_INET_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetsocketaddress.h b/gio/ginetsocketaddress.h
new file mode 100644
index 0000000..b455ac5
--- /dev/null
+++ b/gio/ginetsocketaddress.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_SOCKET_ADDRESS_H__
+#define __G_INET_SOCKET_ADDRESS_H__
+
+#include <gio/gsocketaddress.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_SOCKET_ADDRESS         (g_inet_socket_address_get_type ())
+#define G_INET_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
+#define G_INET_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+#define G_IS_INET_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_INET_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+
+typedef struct _GInetSocketAddressClass   GInetSocketAddressClass;
+typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
+
+struct _GInetSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GInetSocketAddressPrivate *priv;
+};
+
+struct _GInetSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_inet_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_inet_socket_address_new         (GInetAddress       *address,
+						   guint16             port);
+
+GInetAddress *  g_inet_socket_address_get_address (GInetSocketAddress *address);
+
+guint16         g_inet_socket_address_get_port    (GInetSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_SOCKET_ADDRESS_H__ */
diff --git a/gio/gio.h b/gio/gio.h
index e3a0b14..e61b8e4 100644
--- a/gio/gio.h
+++ b/gio/gio.h
@@ -49,6 +49,8 @@
 #include <gio/gfilterinputstream.h>
 #include <gio/gfilteroutputstream.h>
 #include <gio/gicon.h>
+#include <gio/ginetaddress.h>
+#include <gio/ginetsocketaddress.h>
 #include <gio/ginputstream.h>
 #include <gio/gioenums.h>
 #include <gio/gioenumtypes.h>
@@ -61,9 +63,15 @@
 #include <gio/gmount.h>
 #include <gio/gmountoperation.h>
 #include <gio/gnativevolumemonitor.h>
+#include <gio/gnetworkaddress.h>
+#include <gio/gnetworkservice.h>
 #include <gio/goutputstream.h>
+#include <gio/gresolver.h>
 #include <gio/gseekable.h>
 #include <gio/gsimpleasyncresult.h>
+#include <gio/gsocketaddress.h>
+#include <gio/gsocketconnectable.h>
+#include <gio/gsrvtarget.h>
 #include <gio/gthemedicon.h>
 #include <gio/gvfs.h>
 #include <gio/gvolume.h>
diff --git a/gio/gio.symbols b/gio/gio.symbols
index bfeaf60..e2b16a3 100644
--- a/gio/gio.symbols
+++ b/gio/gio.symbols
@@ -829,6 +829,8 @@ g_output_stream_splice_flags_get_type G_GNUC_CONST
 g_ask_password_flags_get_type G_GNUC_CONST
 g_password_save_get_type G_GNUC_CONST
 g_emblem_origin_get_type G_GNUC_CONST
+g_socket_address_family_get_type G_GNUC_CONST
+g_resolver_error_get_type G_GNUC_CONST
 #endif
 #endif
 
@@ -853,3 +855,136 @@ g_emblem_get_origin
 #endif
 #endif
 
+#if IN_HEADER(__G_INET_ADDRESS_H__)
+#if IN_FILE(__G_INET_ADDRESS_C__)
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_get_family
+g_inet_address_get_type G_GNUC_CONST
+g_inet_address_is_any
+g_inet_address_is_link_local
+g_inet_address_is_loopback
+g_inet_address_is_mc_global
+g_inet_address_is_mc_link_local
+g_inet_address_is_mc_node_local
+g_inet_address_is_mc_org_local
+g_inet_address_is_mc_site_local
+g_inet_address_is_multicast
+g_inet_address_is_site_local
+g_inet_address_to_bytes
+g_inet_address_to_string
+#endif
+#endif
+
+#if IN_HEADER(__G_INET_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_INET_SOCKET_ADDRESS_C__)
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+g_inet_socket_address_get_type G_GNUC_CONST
+g_inet_socket_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_UNIX_SOCKET_ADDRESS_C__)
+#ifdef G_OS_UNIX
+g_unix_socket_address_get_type G_GNUC_CONST
+g_unix_socket_address_new
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_SOCKET_ADDRESS_C__)
+g_socket_address_new_from_native
+g_socket_address_get_type G_GNUC_CONST
+g_socket_address_get_family
+g_socket_address_get_native_size
+g_socket_address_to_native
+#endif
+#endif
+
+#if IN_HEADER(__G_RESOLVER_H__)
+#if IN_FILE(__G_RESOLVER_C__)
+g_resolver_error_quark
+g_resolver_get_type G_GNUC_CONST
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+#endif
+#endif
+
+#if IN_HEADER(__G_THREADED_RESOLVER_H__)
+#if IN_FILE(__G_THREADED_RESOLVER_C__)
+g_threaded_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_RESOLVER_H__)
+#if IN_FILE(__G_UNIX_RESOLVER_C__)
+#ifdef G_OS_UNIX
+g_unix_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_WIN32_RESOLVER_H__)
+#if IN_FILE(__G_WIN32_RESOLVER_C__)
+#ifdef G_OS_WIN32
+g_win32_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SRV_TARGET_H__)
+#if IN_FILE(__G_SRV_TARGET_C__)
+g_srv_target_get_type G_GNUC_CONST
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_list_sort
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_ADDRESS_H__)
+#if IN_FILE(__G_NETWORK_ADDRESS_C__)
+g_network_address_get_type G_GNUC_CONST
+g_network_address_get_hostname
+g_network_address_get_port
+g_network_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_SERVICE_H__)
+#if IN_FILE(__G_NETWORK_SERVICE_C__)
+g_network_service_get_type G_GNUC_CONST
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_new
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_CONNECTABLE_H__)
+#if IN_FILE(__G_SOCKET_CONNECTABLE_C__)
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_get_type G_GNUC_CONST
+#endif
+#endif
diff --git a/gio/gioenums.h b/gio/gioenums.h
index 2b69ccf..3a98e2a 100644
--- a/gio/gioenums.h
+++ b/gio/gioenums.h
@@ -467,6 +467,41 @@ typedef enum  {
   G_EMBLEM_ORIGIN_TAG
 } GEmblemOrigin;
 
+/**
+ * GResolverError:
+ * @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not found
+ * @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not be looked up due to a network error or similar problem
+ * @G_RESOLVER_ERROR_INTERNAL: unknown error
+ *
+ * An error code used with %G_RESOLVER_ERROR in a #GError returned
+ * from a #GResolver routine.
+ */
+typedef enum {
+  G_RESOLVER_ERROR_NOT_FOUND,
+  G_RESOLVER_ERROR_TEMPORARY_FAILURE,
+  G_RESOLVER_ERROR_INTERNAL
+} GResolverError;
+
+/**
+ * GSocketAddressFamily:
+ * @G_SOCKET_ADDRESS_INVALID: no address family
+ * @G_SOCKET_ADDRESS_IPV4: an IPv4 address
+ * @G_SOCKET_ADDRESS_IPV6: an IPv6 address
+ * @G_SOCKET_ADDRESS_UNIX: a UNIX domain socket address
+ *
+ * The protocol family of a #GSocketAddress. (These values are
+ * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
+ * if available.)
+ */
+typedef enum {
+  G_SOCKET_ADDRESS_INVALID,
+  G_SOCKET_ADDRESS_IPV4	= GLIB_SYSDEF_AF_INET,
+  G_SOCKET_ADDRESS_IPV6	= GLIB_SYSDEF_AF_INET6
+#ifdef GLIB_SYSDEF_AF_UNIX
+                                              ,
+  G_SOCKET_ADDRESS_UNIX = GLIB_SYSDEF_AF_UNIX
+#endif
+} GSocketAddressFamily;
 
 G_END_DECLS
 
diff --git a/gio/gioerror.c b/gio/gioerror.c
index 0419a7d..697070b 100644
--- a/gio/gioerror.c
+++ b/gio/gioerror.c
@@ -138,7 +138,7 @@ g_io_error_from_errno (gint err_no)
       break;
 #endif
 
-#ifdef ENOTEMPTY
+#if defined(ENOTEMPTY) && (!defined (EEXIST) || (ENOTEMPTY != EEXIST))
     case ENOTEMPTY:
       return G_IO_ERROR_NOT_EMPTY;
       break;
diff --git a/gio/giotypes.h b/gio/giotypes.h
index 981c195..6b08331 100644
--- a/gio/giotypes.h
+++ b/gio/giotypes.h
@@ -75,6 +75,8 @@ typedef struct _GFilenameCompleter            GFilenameCompleter;
 
 
 typedef struct _GIcon                         GIcon; /* Dummy typedef */
+typedef struct _GInetAddress                  GInetAddress;
+typedef struct _GInetSocketAddress            GInetSocketAddress;
 typedef struct _GInputStream                  GInputStream;
 typedef struct _GIOModule                     GIOModule;
 typedef struct _GIOExtensionPoint             GIOExtensionPoint;
@@ -97,9 +99,15 @@ typedef struct _GMemoryOutputStream           GMemoryOutputStream;
  **/
 typedef struct _GMount                        GMount; /* Dummy typedef */
 typedef struct _GMountOperation               GMountOperation;
+typedef struct _GNetworkAddress               GNetworkAddress;
+typedef struct _GNetworkService               GNetworkService;
 typedef struct _GOutputStream                 GOutputStream;
+typedef struct _GResolver                     GResolver;
 typedef struct _GSeekable                     GSeekable;
 typedef struct _GSimpleAsyncResult            GSimpleAsyncResult;
+typedef struct _GSocketAddress                GSocketAddress;
+typedef struct _GSocketConnectable            GSocketConnectable;
+typedef struct _GSrvTarget                    GSrvTarget;
 typedef struct _GThemedIcon                   GThemedIcon;
 typedef struct _GVfs                          GVfs; /* Dummy typedef */
 
diff --git a/gio/gnetworkaddress.c b/gio/gnetworkaddress.c
new file mode 100644
index 0000000..9548df6
--- /dev/null
+++ b/gio/gnetworkaddress.c
@@ -0,0 +1,465 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkaddress.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkaddress
+ * @short_description: a #GSocketConnectable for resolving hostnames
+ * @include: gio/gio.h
+ *
+ * #GNetworkAddress provides an easy way to resolve a hostname and
+ * then attempt to connect to that host, handling the possibility of
+ * multiple IP addresses and multiple address families.
+ *
+ * |[
+ * MyConnectionType *
+ * connect_to_host (const char    *hostname,
+ *                  guint16        port,
+ *                  GCancellable  *cancellable,
+ *                  GError       **error)
+ * {
+ *   MyConnection *conn = NULL;
+ *   GSocketConnectable *addr;
+ *   GSocketAddress *sockaddr;
+ *   GError *conn_error = NULL;
+ *
+ *   addr = g_network_address_new ("www.gnome.org", 80);
+ *
+ *   /<!-- -->* Try each sockaddr until we succeed. Record the first
+ *    * connection error, but not any further ones (since they'll probably
+ *    * be basically the same as the first).
+ *    *<!-- -->/
+ *   while (!conn && (sockaddr = g_socket_connectable_get_next (addr, cancellable, error))
+ *     {
+ *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
+ *       g_object_unref (sockaddr);
+ *     }
+ *   g_object_unref (addr);
+ *
+ *   if (conn)
+ *     {
+ *       if (conn_error)
+ *         {
+ *           /<!-- -->* We couldn't connect to the first address, but we succeeded
+ *            * in connecting to a later address.
+ *            *<!-- -->/
+ *           g_error_free (conn_error);
+ *         }
+ *       return conn;
+ *     }
+ *   else if (error)
+ *     {
+ *       /<!-- -->* Either the initial lookup failed, or else the caller
+ *        * cancelled us.
+ *        *<!-- -->/
+ *       if (conn_error)
+ *         g_error_free (conn_error);
+ *       return NULL;
+ *     }
+ *   else
+ *     {
+ *       g_error_propagate (error, conn_error);
+ *       return NULL;
+ *     }
+ * }
+ * ]|
+ **/
+
+/**
+ * GNetworkAddress:
+ *
+ * A #GSocketConnectable for resolving a hostname and connecting to
+ * that host.
+ **/
+
+struct _GNetworkAddressPrivate {
+  gchar *hostname;
+  guint16 port;
+
+  GList *sockaddrs, *iter;
+};
+
+enum {
+  PROP_0,
+  PROP_HOSTNAME,
+  PROP_PORT,
+};
+
+static void g_network_address_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_address_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_address_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_address_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_address_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_address_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_address_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkAddress, g_network_address, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_address_connectable_iface_init))
+
+static void
+g_network_address_finalize (GObject *object)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  g_free (addr->priv->hostname);
+
+  if (addr->priv->sockaddrs)
+    {
+      GList *a;
+
+      for (a = addr->priv->sockaddrs; a; a = a->next)
+        g_object_unref (a->data);
+      g_list_free (addr->priv->sockaddrs);
+    }
+
+  G_OBJECT_CLASS (g_network_address_parent_class)->finalize (object);
+}
+
+static void
+g_network_address_class_init (GNetworkAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkAddressPrivate));
+
+  gobject_class->set_property = g_network_address_set_property;
+  gobject_class->get_property = g_network_address_get_property;
+  gobject_class->finalize = g_network_address_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_HOSTNAME,
+                                   g_param_spec_string ("hostname",
+                                                        P_("Hostname"),
+                                                        P_("Hostname to resolver"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      P_("Port"),
+                                                      P_("Network port"),
+                                                      0, 65535, 0,
+                                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_address_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_address_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_address_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_address_connectable_reset;
+}
+
+static void
+g_network_address_init (GNetworkAddress *addr)
+{
+  addr->priv = G_TYPE_INSTANCE_GET_PRIVATE (addr, G_TYPE_NETWORK_ADDRESS,
+                                            GNetworkAddressPrivate);
+}
+
+static void
+g_network_address_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_HOSTNAME:
+      if (addr->priv->hostname)
+        g_free (addr->priv->hostname);
+      addr->priv->hostname = g_value_dup_string (value);
+      break;
+
+    case PROP_PORT:
+      addr->priv->port = g_value_get_uint (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id)
+    { 
+    case PROP_HOSTNAME:
+      g_value_set_string (value, addr->priv->hostname);
+      break;
+
+    case PROP_PORT:
+      g_value_set_uint (value, addr->priv->port);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_set_addresses (GNetworkAddress *addr,
+                                 GList           *addresses)
+{
+  GList *a;
+  GSocketAddress *sockaddr;
+
+  g_return_if_fail (addresses != NULL && addr->priv->sockaddrs == NULL);
+
+  for (a = addresses; a; a = a->next)
+    {
+      sockaddr = g_inet_socket_address_new (a->data, addr->priv->port);
+      addr->priv->sockaddrs = g_list_prepend (addr->priv->sockaddrs, sockaddr);
+      g_object_unref (a->data);
+    }
+  g_list_free (addresses);
+  addr->priv->sockaddrs = g_list_reverse (addr->priv->sockaddrs);
+}
+
+/**
+ * g_network_address_new:
+ * @hostname: the hostname
+ * @port: the port
+ *
+ * Creates a new #GSocketConnectable for connecting to the given
+ * @hostname and @port.
+ *
+ * Return value: the new #GNetworkAddress
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_address_new (const gchar *hostname,
+                       guint16      port)
+{
+  return g_object_new (G_TYPE_NETWORK_ADDRESS,
+                       "hostname", hostname,
+                       "port", port,
+                       NULL);
+}
+
+/**
+ * g_network_address_get_hostname:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
+ * depending on what @addr was created with.
+ *
+ * Return value: @addr's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_address_get_hostname (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), NULL);
+
+  return addr->priv->hostname;
+}
+
+/**
+ * g_network_address_get_port:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's port number
+ *
+ * Return value: @addr's port (which may be %0)
+ *
+ * Since: 2.20
+ **/
+guint16
+g_network_address_get_port (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), 0);
+
+  return addr->priv->port;
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSocketAddress *sockaddr;
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver,
+                                             addr->priv->hostname,
+                                             cancellable, error);
+      g_object_unref (resolver);
+
+      if (!addresses)
+        return NULL;
+
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  if (!addr->priv->iter)
+    return NULL;
+  else
+    {
+      sockaddr = addr->priv->iter->data;
+      addr->priv->iter = addr->priv->iter->next;
+      return g_object_ref (sockaddr);
+    }
+}
+
+static void
+got_addresses (GObject      *source_object,
+               GAsyncResult *result,
+               gpointer      user_data)
+{
+  GResolver *resolver = G_RESOLVER (source_object);
+  GSimpleAsyncResult *simple = user_data;
+  GNetworkAddress *addr;
+  GList *addresses;
+  GError *error = NULL;
+  GSocketAddress *sockaddr;
+
+  addr = (GNetworkAddress *)g_async_result_get_source_object (G_ASYNC_RESULT (simple));
+  /* get_source_object adds a ref */
+  g_object_unref (addr);
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  if (error)
+    {
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+    }
+  else
+    {
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  sockaddr = g_network_address_connectable_get_next (G_SOCKET_CONNECTABLE (addr), NULL, NULL);
+  if (sockaddr)
+    g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+  g_simple_async_result_complete (simple);
+  g_object_unref (simple);
+}
+
+static void
+g_network_address_connectable_get_next_async (GSocketConnectable   *connectable,
+                                              GCancellable         *cancellable,
+                                              GAsyncReadyCallback   callback,
+                                              gpointer              user_data)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  simple = g_simple_async_result_new (G_OBJECT (connectable),
+                                      callback, user_data,
+                                      g_network_address_connectable_get_next_async);
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+
+      g_resolver_lookup_by_name_async (resolver,
+                                       addr->priv->hostname,
+                                       cancellable,
+                                       got_addresses, simple);
+      g_object_unref (resolver);
+    }
+  else
+    {
+      sockaddr = g_network_address_connectable_get_next (connectable, NULL, NULL);
+      if (sockaddr)
+        g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+    }
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+
+  addr->priv->iter = addr->priv->sockaddrs;
+}
+
+#define __G_NETWORK_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkaddress.h b/gio/gnetworkaddress.h
new file mode 100644
index 0000000..47dba10
--- /dev/null
+++ b/gio/gnetworkaddress.h
@@ -0,0 +1,65 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_ADDRESS_H__
+#define __G_NETWORK_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
+#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
+#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
+#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
+#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+
+typedef struct _GNetworkAddressClass   GNetworkAddressClass;
+typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
+
+struct _GNetworkAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkAddressPrivate *priv;
+};
+
+struct _GNetworkAddressClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType               g_network_address_get_type       (void) G_GNUC_CONST;
+
+GSocketConnectable *g_network_address_new            (const gchar      *hostname,
+						      guint16           port);
+const gchar        *g_network_address_get_hostname   (GNetworkAddress  *addr);
+guint16             g_network_address_get_port       (GNetworkAddress  *addr);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_ADDRESS_H__ */
diff --git a/gio/gnetworkingprivate.h b/gio/gnetworkingprivate.h
new file mode 100644
index 0000000..c41f598
--- /dev/null
+++ b/gio/gnetworkingprivate.h
@@ -0,0 +1,85 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_NETWORKINGPRIVATE_H__
+#define __G_NETWORKINGPRIVATE_H__
+
+#ifdef G_OS_WIN32
+
+#define WINVER 0x0501 // FIXME?
+#include <winsock2.h>
+#undef interface
+#include <ws2tcpip.h>
+#include <windns.h>
+
+#else /* !G_OS_WIN32 */
+
+#define BIND_4_COMPAT
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+/* We're supposed to define _GNU_SOURCE to get EAI_NODATA, but that
+ * won't actually work since <features.h> has already been included at
+ * this point. So we define __USE_GNU instead.
+ */
+#define __USE_GNU
+#include <netdb.h>
+#undef __USE_GNU
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <resolv.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#endif
+
+G_BEGIN_DECLS
+
+extern struct addrinfo _g_resolver_addrinfo_hints;
+
+GList *_g_resolver_addresses_from_addrinfo (const char       *hostname,
+					    struct addrinfo  *res,
+					    gint              gai_retval,
+					    GError          **error);
+
+void   _g_resolver_address_to_sockaddr     (GInetAddress            *address,
+					    struct sockaddr_storage *sa,
+					    gsize                   *sa_len);
+char  *_g_resolver_name_from_nameinfo      (GInetAddress     *address,
+					    const gchar      *name,
+					    gint              gni_retval,
+					    GError          **error);
+
+#if defined(G_OS_UNIX)
+GList *_g_resolver_targets_from_res_query  (const gchar      *rrname,
+					    guchar           *answer,
+					    gint              len,
+					    gint              herr,
+					    GError          **error);
+#elif defined(G_OS_WIN32)
+GList *_g_resolver_targets_from_DnsQuery   (const gchar      *rrname,
+					    DNS_STATUS        status,
+					    DNS_RECORD       *results,
+					    GError          **error);
+#endif
+
+G_END_DECLS
+
+#endif /* __G_NETWORKINGPRIVATE_H__ */
diff --git a/gio/gnetworkservice.c b/gio/gnetworkservice.c
new file mode 100644
index 0000000..b23619b
--- /dev/null
+++ b/gio/gnetworkservice.c
@@ -0,0 +1,610 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkservice.h"
+#include "gcancellable.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkservice
+ * @short_description: a #GSocketConnectable for resolving SRV records
+ * @include: gio/gio.h
+ *
+ * Like #GNetworkAddress does with hostnames, #GNetworkService
+ * provides an easy way to resolve a SRV record, and then attempt to
+ * connect to one of the hosts that implements that service, handling
+ * service priority/weighting, multiple IP addresses, and multiple
+ * address families.
+ *
+ * See #GSrvTarget for more information about SRV records.
+ **/
+
+/**
+ * GNetworkService:
+ *
+ * A #GSocketConnectable for resolving a SRV record and connecting to
+ * that service.
+ **/
+
+struct _GNetworkServicePrivate
+{
+  gchar *service, *protocol, *domain;
+
+  GResolver *resolver;
+  GList *targets, *target_iter;
+  GList *addrs, *addr_iter;
+
+  GSimpleAsyncResult *next_result;
+  GCancellable *cancellable;
+  GError *iter_error;
+};
+
+enum {
+  PROP_0,
+  PROP_SERVICE,
+  PROP_PROTOCOL,
+  PROP_DOMAIN,
+};
+
+static void g_network_service_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_service_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_service_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_service_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_service_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_service_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_service_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkService, g_network_service, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_service_connectable_iface_init))
+
+static void
+g_network_service_finalize (GObject *object)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  g_free (srv->priv->service);
+  g_free (srv->priv->protocol);
+  g_free (srv->priv->domain);
+
+  if (srv->priv->targets)
+    g_resolver_free_targets (srv->priv->targets);
+
+  g_object_unref (srv->priv->resolver);
+  g_network_service_connectable_reset ((GSocketConnectable *)srv);
+
+  G_OBJECT_CLASS (g_network_service_parent_class)->finalize (object);
+}
+
+static void
+g_network_service_class_init (GNetworkServiceClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkServicePrivate));
+
+  gobject_class->set_property = g_network_service_set_property;
+  gobject_class->get_property = g_network_service_get_property;
+  gobject_class->finalize = g_network_service_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_SERVICE,
+                                   g_param_spec_string ("service",
+                                                        P_("Service"),
+                                                        P_("Service name, eg \"ldap\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PROTOCOL,
+                                   g_param_spec_string ("protocol",
+                                                        P_("Protocol"),
+                                                        P_("Network protocol, eg \"tcp\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_DOMAIN,
+                                   g_param_spec_string ("domain",
+                                                        P_("domain"),
+                                                        P_("Network domain, eg, \"example.com\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_service_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_service_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_service_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_service_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_service_connectable_reset;
+}
+
+static void
+g_network_service_init (GNetworkService *srv)
+{
+  srv->priv = G_TYPE_INSTANCE_GET_PRIVATE (srv, G_TYPE_NETWORK_SERVICE,
+                                           GNetworkServicePrivate);
+  srv->priv->resolver = g_resolver_get_default ();
+}
+
+static void
+g_network_service_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id) 
+    {
+    case PROP_SERVICE:
+      srv->priv->service = g_value_dup_string (value);
+      break;
+
+    case PROP_PROTOCOL:
+      srv->priv->protocol = g_value_dup_string (value);
+      break;
+
+    case PROP_DOMAIN:
+      srv->priv->domain = g_value_dup_string (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_service_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id)
+    { 
+    case PROP_SERVICE:
+      g_value_set_string (value, g_network_service_get_service (srv));
+      break;
+
+    case PROP_PROTOCOL:
+      g_value_set_string (value, g_network_service_get_protocol (srv));
+      break;
+
+    case PROP_DOMAIN:
+      g_value_set_string (value, g_network_service_get_domain (srv));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+/**
+ * g_network_service_new:
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ *
+ * Creates a new #GNetworkService representing the given @service,
+ * @protocol, and @domain. This will initially be unresolved; use the
+ * #GSocketConnectable interface to resolve it.
+ *
+ * Return value: a new #GNetworkService
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_service_new (const gchar *service,
+                       const gchar *protocol,
+                       const gchar *domain)
+{
+  return g_object_new (G_TYPE_NETWORK_SERVICE,
+                       "service", service,
+                       "protocol", protocol,
+                       "domain", domain,
+                       NULL);
+}
+
+/**
+ * g_network_service_get_service:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's service name (eg, "ldap").
+ *
+ * Return value: @srv's service name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_service (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->service;
+}
+
+/**
+ * g_network_service_get_protocol:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's protocol name (eg, "tcp").
+ *
+ * Return value: @srv's protocol name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_protocol (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->protocol;
+}
+
+/**
+ * g_network_service_get_domain:
+ * @srv: a #GNetworkService
+ *
+ * Gets the domain that @srv serves. This might be either UTF-8 or
+ * ASCII-encoded, depending on what @srv was created with.
+ *
+ * Return value: @srv's domain name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_domain (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->domain;
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+  GSrvTarget *target;
+  GSocketAddress *sockaddr;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      GList *targets;
+
+      targets = g_resolver_lookup_service (srv->priv->resolver,
+                                           srv->priv->service,
+                                           srv->priv->protocol,
+                                           srv->priv->domain,
+                                           cancellable, error);
+      if (!targets)
+        return NULL;
+
+      srv->priv->targets = targets;
+      srv->priv->target_iter = srv->priv->targets;
+    }
+
+  /* Make sure we have a set of resolved addresses for the current
+   * target. When resolving the first target, we save the GError, if
+   * any. If any later target succeeds, we'll free the earlier error,
+   * but if we get to the last target without any of them resolving,
+   * we return that initial error.
+   */
+  do
+    {
+      /* Return if we're out of targets. */
+      if (!srv->priv->target_iter)
+        {
+          if (srv->priv->iter_error)
+            {
+              g_propagate_error (error, srv->priv->iter_error);
+              srv->priv->iter_error = NULL;
+            }
+          return NULL;
+        }
+      target = srv->priv->target_iter->data;
+
+      /* If we haven't resolved the addrs for the current target, do that */
+      if (!srv->priv->addrs)
+        {
+          GError **error_p;
+
+          if (srv->priv->target_iter == srv->priv->targets)
+            error_p = &srv->priv->iter_error;
+          else
+            error_p = NULL;
+          srv->priv->addrs = g_resolver_lookup_by_name (srv->priv->resolver,
+                                                        g_srv_target_get_hostname (target),
+                                                        cancellable, error_p);
+          if (g_cancellable_set_error_if_cancelled (cancellable, error))
+            return NULL;
+
+          if (srv->priv->addrs)
+            {
+              srv->priv->addr_iter = srv->priv->addrs;
+              if (srv->priv->iter_error)
+                {
+                  g_error_free (srv->priv->iter_error);
+                  srv->priv->iter_error = NULL;
+                }
+            }
+          else
+            {
+              /* Try the next target */
+              srv->priv->target_iter = srv->priv->target_iter->next;
+            }
+        }
+    }
+  while (!srv->priv->addrs);
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (target));
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  return sockaddr;
+}
+
+static void get_next_async_resolved_targets   (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_targets       (GNetworkService *srv);
+static void get_next_async_resolved_addresses (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_addresses     (GNetworkService *srv);
+
+/* The async version is basically the same as the sync, except we have
+ * to split it into multiple functions.
+ */
+static void
+g_network_service_connectable_get_next_async (GSocketConnectable  *connectable,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_return_if_fail (srv->priv->next_result == NULL);
+
+  srv->priv->next_result = g_simple_async_result_new (G_OBJECT (connectable),
+                                                      callback, user_data,
+                                                      g_network_service_connectable_get_next_async);
+  srv->priv->cancellable = cancellable;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      g_resolver_lookup_service_async (srv->priv->resolver,
+                                       srv->priv->service,
+                                       srv->priv->protocol,
+                                       srv->priv->domain,
+                                       cancellable,
+                                       get_next_async_resolved_targets,
+                                       srv);
+    }
+  else
+    get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_resolved_targets (GObject      *source_object,
+                                 GAsyncResult *result,
+                                 gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->targets = g_resolver_lookup_service_finish (srv->priv->resolver,
+                                                         result, &error);
+  if (error)
+    {
+      GSimpleAsyncResult *simple = srv->priv->next_result;
+
+      srv->priv->next_result = NULL;
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+      g_simple_async_result_complete (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  srv->priv->target_iter = srv->priv->targets;
+  get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_have_targets (GNetworkService *srv)
+{
+  GSrvTarget *target;
+
+  /* Get the current target, check if we're already done. */
+  if (!srv->priv->target_iter)
+    {
+      if (srv->priv->iter_error)
+        {
+          g_simple_async_result_set_from_error (srv->priv->next_result, srv->priv->iter_error);
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      g_simple_async_result_complete_in_idle (srv->priv->next_result);
+      g_object_unref (srv->priv->next_result);
+      srv->priv->next_result = NULL;
+      return;
+    }
+  target = srv->priv->target_iter->data;
+
+  /* If we haven't resolved the addrs for the current target, do that */
+  if (!srv->priv->addrs)
+    {
+      g_resolver_lookup_by_name_async (srv->priv->resolver,
+                                       g_srv_target_get_hostname (target),
+                                       srv->priv->cancellable,
+                                       get_next_async_resolved_addresses,
+                                       srv);
+    }
+  else
+    get_next_async_have_addresses (srv);
+}
+
+static void
+get_next_async_resolved_addresses (GObject      *source_object,
+                                   GAsyncResult *result,
+                                   gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->addrs = g_resolver_lookup_by_name_finish (srv->priv->resolver, result, &error);
+  if (srv->priv->addrs)
+    {
+      srv->priv->addr_iter = srv->priv->addrs;
+      if (srv->priv->iter_error)
+        {
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      get_next_async_have_addresses (srv);
+    }
+  else
+    {
+      if (g_cancellable_is_cancelled (srv->priv->cancellable))
+        {
+          GSimpleAsyncResult *simple = srv->priv->next_result;
+
+          srv->priv->next_result = NULL;
+          g_simple_async_result_set_from_error (srv->priv->next_result, error);
+          g_error_free (error);
+          g_simple_async_result_complete (simple);
+          g_object_unref (simple);
+        }
+      else
+        {
+          if (srv->priv->target_iter == srv->priv->targets)
+            srv->priv->iter_error = error;
+          else
+            g_error_free (error);
+
+          /* Try the next target */
+          srv->priv->target_iter = srv->priv->target_iter->next;
+          get_next_async_have_targets (srv);
+        }
+    }
+}
+
+static void
+get_next_async_have_addresses (GNetworkService *srv)
+{
+  GSocketAddress *sockaddr;
+  GSimpleAsyncResult *simple = srv->priv->next_result;
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (srv->priv->target_iter->data));
+
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  srv->priv->next_result = NULL;
+  g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+  g_simple_async_result_complete_in_idle (simple);
+  g_object_unref (simple);
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_service_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_resolver_free_addresses (srv->priv->addrs);
+  srv->priv->addrs = NULL;
+  srv->priv->target_iter = srv->priv->targets;
+  if (srv->priv->iter_error)
+    {
+      g_error_free (srv->priv->iter_error);
+      srv->priv->iter_error = NULL;
+    }
+}
+
+#define __G_NETWORK_SERVICE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkservice.h b/gio/gnetworkservice.h
new file mode 100644
index 0000000..b1a754b
--- /dev/null
+++ b/gio/gnetworkservice.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_SERVICE_H__
+#define __G_NETWORK_SERVICE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
+#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
+#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
+#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
+#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+
+typedef struct _GNetworkServiceClass   GNetworkServiceClass;
+typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
+
+struct _GNetworkService
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkServicePrivate *priv;
+};
+
+struct _GNetworkServiceClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType                g_network_service_get_type      (void) G_GNUC_CONST;
+
+GSocketConnectable  *g_network_service_new           (const gchar     *service,
+						      const gchar     *protocol,
+						      const gchar     *domain);
+
+const gchar         *g_network_service_get_service   (GNetworkService *srv);
+const gchar         *g_network_service_get_protocol  (GNetworkService *srv);
+const gchar         *g_network_service_get_domain    (GNetworkService *srv);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_SERVICE_H__ */
+
diff --git a/gio/gresolver.c b/gio/gresolver.c
new file mode 100644
index 0000000..ef046bc
--- /dev/null
+++ b/gio/gresolver.c
@@ -0,0 +1,865 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gresolver.h"
+#include "gnetworkingprivate.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gsimpleasyncresult.h"
+#include "gsrvtarget.h"
+
+#ifdef G_OS_UNIX
+#include "gunixresolver.h"
+#endif
+#ifdef G_OS_WIN32
+#include "gwin32resolver.h"
+#endif
+
+#include <stdlib.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gresolver
+ * @short_description: Asynchronous and cancellable DNS resolver
+ * @include: gio/gio.h
+ *
+ * #GResolver provides cancellable synchronous and asynchronous DNS
+ * resolution, for hostnames (g_resolver_lookup_by_address(),
+ * g_resolver_lookup_by_name() and their async variants) and SRV
+ * (service) records (g_resolver_lookup_service()).
+ *
+ * #GNetworkAddress and #GNetworkService provide wrappers around
+ * #GResolver functionality that also implement #GSocketConnectable,
+ * making it easy to connect to a remote host/service.
+ **/
+
+/**
+ * GResolver:
+ *
+ * The object that handles DNS resolution. Use g_resolver_get_default()
+ * to get the default resolver.
+ */
+G_DEFINE_TYPE (GResolver, g_resolver, G_TYPE_OBJECT)
+
+static void
+g_resolver_class_init (GResolverClass *resolver_class)
+{
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+  /* Initialize _g_resolver_addrinfo_hints */
+#ifdef AI_ADDRCONFIG
+  _g_resolver_addrinfo_hints.ai_flags |= AI_ADDRCONFIG;
+#endif
+  /* These two don't actually matter, they just get copied into the
+   * returned addrinfo structures (and then we ignore them). But if
+   * we leave them unset, we'll get back duplicate answers.
+   */
+  _g_resolver_addrinfo_hints.ai_socktype = SOCK_STREAM;
+  _g_resolver_addrinfo_hints.ai_protocol = IPPROTO_TCP;
+}
+
+static void
+g_resolver_init (GResolver *resolver)
+{
+  ;
+}
+
+static GResolver *default_resolver;
+
+/**
+ * g_resolver_get_default:
+ *
+ * Gets the default #GResolver. You should unref it when you are done
+ * with it. #GResolver may use its reference count as a hint about how
+ * many threads/processes, etc it should allocate for concurrent DNS
+ * resolutions.
+ *
+ * Return value: the #GResolver.
+ *
+ * Since: 2.20
+ **/
+GResolver *
+g_resolver_get_default (void)
+{
+  if (!default_resolver)
+    {
+      if (g_thread_supported ())
+        default_resolver = g_object_new (G_TYPE_THREADED_RESOLVER, NULL);
+      else
+        {
+#if defined(G_OS_UNIX)
+          default_resolver = g_object_new (G_TYPE_UNIX_RESOLVER, NULL);
+#elif defined(G_OS_WIN32)
+          default_resolver = g_object_new (G_TYPE_WIN32_RESOLVER, NULL);
+#endif
+        }
+    }
+
+  return g_object_ref (default_resolver);
+}
+
+/**
+ * g_resolver_set_default:
+ * @resolver: the new default #GResolver
+ *
+ * Sets @resolver to be the application's default resolver (reffing
+ * @resolver, and unreffing the previous default resolver, if any).
+ * Future calls to g_resolver_get_default() will return this resolver.
+ *
+ * This can be used if an applications wants to perform any sort of
+ * DNS caching or "pinning"; it can implement its own #GResolver that
+ * calls the original default resolver for DNS operations, and
+ * implements its own cache policies on top of that, and then set
+ * itself as the default resolver for all later code to use.
+ **/
+void
+g_resolver_set_default (GResolver *resolver)
+{
+  if (default_resolver)
+    g_object_unref (default_resolver);
+  default_resolver = g_object_ref (resolver);
+}
+
+
+/**
+ * g_resolver_lookup_by_name:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously resolves @hostname to determine its associated IP
+ * address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
+ * the textual form of an IP address (in which case this just becomes
+ * a wrapper around g_inet_address_new_from_string()).
+ *
+ * On success, g_resolver_lookup_by_name() will return a #GList of
+ * #GInetAddress, sorted in order of preference. (That is, you should
+ * attempt to connect to the first address first, then the second if
+ * the first fails, etc.) You must unref each address and free the
+ * list when you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to a
+ * value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to a socket on the resolved IP
+ * address, it may be easier to create a #GNetworkAddress and use its
+ * #GSocketConnectable interface.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. You
+ * must unref each of the addresses and free the list when you are
+ * done with it. (You can use g_resolver_free_addresses() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name (GResolver     *resolver,
+                           const gchar   *hostname,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GInetAddress *addr;
+  GList *addrs;
+  gchar *ascii_hostname = NULL;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (hostname != NULL, NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    return g_list_append (NULL, addr);
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  addrs = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name (resolver, hostname, cancellable, error);
+
+  g_free (ascii_hostname);
+  return addrs;
+}
+
+/**
+ * g_resolver_lookup_by_name_async:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up the address of
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously resolving @hostname to determine its
+ * associated IP address(es), and eventually calls @callback, which
+ * must call g_resolver_lookup_by_name_finish() to get the result. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_name_async (GResolver           *resolver,
+                                 const gchar         *hostname,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  GInetAddress *addr;
+  gchar *ascii_hostname = NULL;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (hostname != NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    {
+      GSimpleAsyncResult *simple;
+      GList *addrs;
+
+      simple = g_simple_async_result_new (G_OBJECT (resolver),
+                                          callback, user_data,
+                                          g_resolver_lookup_by_name_async);
+
+      addrs = g_list_append (NULL, addr);
+      g_simple_async_result_set_op_res_gpointer (simple, addrs, (GDestroyNotify)g_resolver_free_addresses);
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_async (resolver, hostname, cancellable, callback, user_data);
+
+  g_free (ascii_hostname);
+}
+
+/**
+ * g_resolver_lookup_by_name_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a call to
+ * g_resolver_lookup_by_name_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+
+      /* Handle the stringified-IP-addr case */
+      if (g_simple_async_result_get_source_tag (simple) == g_resolver_lookup_by_name_async)
+        {
+          GList *addrs;
+
+          addrs = g_simple_async_result_get_op_res_gpointer (simple);
+          g_simple_async_result_set_op_res_gpointer (simple, NULL, NULL);
+          return addrs;
+        }
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_addresses:
+ * @addresses: a #GList of #GInetAddress
+ *
+ * Frees @addresses (which should be the return value from
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
+ * (This is a convenience method; you can also simply free the results
+ * by hand.)
+ **/
+void
+g_resolver_free_addresses (GList *addresses)
+{
+  GList *a;
+
+  for (a = addresses; a; a = a->next)
+    g_object_unref (a->data);
+  g_list_free (addresses);
+}
+
+/**
+ * g_resolver_lookup_by_address:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously reverse-resolves @address to determine its
+ * associated hostname.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address (GResolver     *resolver,
+                              GInetAddress  *address,
+                              GCancellable  *cancellable,
+                              GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address (resolver, address, cancellable, error);
+}
+
+/**
+ * g_resolver_lookup_by_address_async:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously reverse-resolving @address to determine its
+ * associated hostname, and eventually calls @callback, which must
+ * call g_resolver_lookup_by_address_finish() to get the final result.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_address_async (GResolver           *resolver,
+                                    GInetAddress        *address,
+                                    GCancellable        *cancellable,
+                                    GAsyncReadyCallback  callback,
+                                    gpointer             user_data)
+{
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (G_IS_INET_ADDRESS (address));
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_async (resolver, address, cancellable, callback, user_data);
+}
+
+/**
+ * g_resolver_lookup_by_address_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_by_address_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address_finish (GResolver     *resolver,
+                                     GAsyncResult  *result,
+                                     GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_finish (resolver, result, error);
+}
+
+static gchar *
+g_resolver_get_service_rrname (const char *service,
+                               const char *protocol,
+                               const char *domain)
+{
+  gchar *rrname, *ascii_domain = NULL;
+
+  if (g_hostname_is_non_ascii (domain))
+    domain = ascii_domain = g_hostname_to_ascii (domain);
+
+  rrname = g_strdup_printf ("_%s._%s.%s", service, protocol, domain);
+
+  g_free (ascii_domain);
+  return rrname;
+}
+
+/**
+ * g_resolver_lookup_service:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously performs a DNS SRV lookup for the given @service and
+ * @protocol in the given @domain and returns an array of #GSrvTarget.
+ * @domain may be an ASCII-only or UTF-8 hostname. Note also that the
+ * @service and @protocol arguments DO NOT include the leading
+ * underscore that appears in the actual DNS entry.
+ *
+ * On success, g_resolver_lookup_service() will return a #GList of
+ * #GSrvTarget, sorted in order of preference. (That is, you should
+ * attempt to connect to the first target first, then the second if
+ * the first fails, etc.) You must free each target and the list when
+ * you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to the service, it is usually easier
+ * to create a #GNetworkService and use its #GSocketConnectable
+ * interface.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. You must
+ * free each of the targets and the list when you are done with it.
+ * (You can use g_resolver_free_targets() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service (GResolver     *resolver,
+                           const gchar   *service,
+                           const gchar   *protocol,
+                           const gchar   *domain,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GList *targets;
+  gchar *rrname;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (service != NULL, NULL);
+  g_return_val_if_fail (protocol != NULL, NULL);
+  g_return_val_if_fail (domain != NULL, NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  targets = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service (resolver, rrname, cancellable, error);
+
+  g_free (rrname);
+  return targets;
+}
+
+/**
+ * g_resolver_lookup_service_async:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously performing a DNS SRV lookup for the given
+ * @service and @protocol in the given @domain, and eventually calls
+ * @callback, which must call g_resolver_lookup_service_finish() to
+ * get the final result. See g_resolver_lookup_service() for more
+ * details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_service_async (GResolver           *resolver,
+                                 const gchar         *service,
+                                 const gchar         *protocol,
+                                 const gchar         *domain,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  gchar *rrname;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (service != NULL);
+  g_return_if_fail (protocol != NULL);
+  g_return_if_fail (domain != NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_async (resolver, rrname, cancellable, callback, user_data);
+
+  g_free (rrname);
+}
+
+/**
+ * g_resolver_lookup_service_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_service_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. See
+ * g_resolver_lookup_service() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_targets:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Frees @targets (which should be the return value from
+ * g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
+ * (This is a convenience method; you can also simply free the
+ * results by hand.)
+ **/
+void
+g_resolver_free_targets (GList *targets)
+{
+  GList *t;
+
+  for (t = targets; t; t = t->next)
+    g_srv_target_free (t->data);
+  g_list_free (targets);
+}
+
+/**
+ * g_resolver_error_quark:
+ * 
+ * Gets the #GResolver Error Quark.
+ *
+ * Return value: a #GQuark.
+ *
+ * Since: 2.20
+ **/
+GQuark
+g_resolver_error_quark (void)
+{
+  return g_quark_from_static_string ("g-resolver-error-quark");
+}
+
+
+static GResolverError
+g_resolver_error_from_addrinfo_error (gint err)
+{
+  switch (err)
+    {
+    case EAI_FAIL:
+    case EAI_NODATA:
+    case EAI_NONAME:
+      return G_RESOLVER_ERROR_NOT_FOUND;
+
+    case EAI_AGAIN:
+      return G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+
+    default:
+      return G_RESOLVER_ERROR_INTERNAL;
+    }
+}
+
+struct addrinfo _g_resolver_addrinfo_hints;
+
+/* Private method to process a getaddrinfo() response. */
+GList *
+_g_resolver_addresses_from_addrinfo (const char       *hostname,
+                                     struct addrinfo  *res,
+                                     gint              gai_retval,
+                                     GError          **error)
+{
+  struct addrinfo *ai;
+  GSocketAddress *sockaddr;
+  GInetAddress *addr;
+  GList *addrs;
+
+  if (gai_retval != 0)
+    {
+      g_set_error (error, G_RESOLVER_ERROR,
+		   g_resolver_error_from_addrinfo_error (gai_retval),
+		   _("Error resolving '%s': %s"),
+		   hostname, gai_strerror (gai_retval));
+      return NULL;
+    }
+
+  g_return_val_if_fail (res != NULL, NULL);
+
+  addrs = NULL;
+  for (ai = res; ai; ai = ai->ai_next)
+    {
+      sockaddr = g_socket_address_new_from_native (ai->ai_addr, ai->ai_addrlen);
+      if (!sockaddr || !G_IS_INET_SOCKET_ADDRESS (sockaddr))
+        continue;
+
+      addr = g_object_ref (g_inet_socket_address_get_address ((GInetSocketAddress *)sockaddr));
+      addrs = g_list_prepend (addrs, addr);
+      g_object_unref (sockaddr);
+    }
+
+  return g_list_reverse (addrs);
+}
+
+/* Private method to set up a getnameinfo() request */
+void
+_g_resolver_address_to_sockaddr (GInetAddress            *address,
+                                 struct sockaddr_storage *sa,
+                                 gsize                   *sa_len)
+{
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_inet_socket_address_new (address, 0);
+  g_socket_address_to_native (sockaddr, (struct sockaddr *)sa, sizeof (*sa));
+  *sa_len = g_socket_address_get_native_size (sockaddr);
+  g_object_unref (sockaddr);
+}
+
+/* Private method to process a getnameinfo() response. */
+char *
+_g_resolver_name_from_nameinfo (GInetAddress  *address,
+                                const gchar   *name,
+                                gint           gni_retval,
+                                GError       **error)
+{
+  if (gni_retval != 0)
+    {
+      gchar *phys;
+
+      phys = g_inet_address_to_string (address);
+      g_set_error (error, G_RESOLVER_ERROR,
+                   g_resolver_error_from_addrinfo_error (gni_retval),
+                   _("Error reverse-resolving '%s': %s"),
+                   phys ? phys : "(unknown)", gai_strerror (gni_retval));
+      g_free (phys);
+      return NULL;
+    }
+
+  return g_strdup (name);
+}
+
+#if defined(G_OS_UNIX)
+/* Private method to process a res_query response into GSrvTargets */
+GList *
+_g_resolver_targets_from_res_query (const gchar      *rrname,
+                                    guchar           *answer,
+                                    gint              len,
+                                    gint              herr,
+                                    GError          **error)
+{
+  gint count;
+  gchar namebuf[1024];
+  guchar *end, *p;
+  guint16 type, qclass, rdlength, priority, weight, port;
+  guint32 ttl;
+  HEADER *header;
+  time_t now = time (NULL);
+  GSrvTarget *target;
+  GList *targets;
+
+  if (len < 0)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (herr == HOST_NOT_FOUND || herr == NO_DATA)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (herr == TRY_AGAIN)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+
+  header = (HEADER *)answer;
+  p = answer + sizeof (HEADER);
+  end = answer + len;
+
+  /* Skip query */
+  count = ntohs (header->qdcount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      p += 4;
+    }
+
+  /* Read answers */
+  count = ntohs (header->ancount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      GETSHORT (type, p);
+      GETSHORT (qclass, p);
+      GETLONG  (ttl, p);
+      GETSHORT (rdlength, p);
+
+      if (type != T_SRV || qclass != C_IN)
+        {
+          p += rdlength;
+          continue;
+        }
+
+      GETSHORT (priority, p);
+      GETSHORT (weight, p);
+      GETSHORT (port, p);
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+
+      target = g_srv_target_new (namebuf, port, priority, weight, now + ttl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+#elif defined(G_OS_WIN32)
+/* Private method to process a DnsQuery response into GSrvTargets */
+GList *
+_g_resolver_targets_from_DnsQuery (const gchar  *rrname,
+                                   DNS_STATUS    status,
+                                   DNS_RECORD   *results,
+                                   GError      **error)
+{
+  DNS_RECORD *rec;
+  GSrvTarget *target;
+  GList *targets;
+  time_t now = time (NULL);
+
+  if (status != ERROR_SUCCESS)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (status == DNS_ERROR_RCODE_NAME_ERROR)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (status == DNS_ERROR_RCODE_SERVER_FAILURE)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+  for (rec = results; rec; rec = rec->pNext)
+    {
+      if (rec->wType != DNS_TYPE_SRV)
+        continue;
+
+      target = g_srv_target_new (rec->Data.SRV.pNameTarget,
+                                 rec->Data.SRV.wPort,
+                                 rec->Data.SRV.wPriority,
+                                 rec->Data.SRV.wWeight,
+                                 now + rec->dwTtl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+
+#endif
+
+#define __G_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gresolver.h b/gio/gresolver.h
new file mode 100644
index 0000000..788851e
--- /dev/null
+++ b/gio/gresolver.h
@@ -0,0 +1,159 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_RESOLVER_H__
+#define __G_RESOLVER_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_RESOLVER         (g_resolver_get_type ())
+#define G_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
+#define G_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
+#define G_IS_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
+#define G_IS_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
+#define G_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))
+
+struct _GResolver {
+  GObject parent_instance;
+
+};
+
+typedef struct {
+  GObjectClass parent_class;
+
+  GList * ( *lookup_by_name)           (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_name_async)     (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_by_name_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  gchar * ( *lookup_by_address)        (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_address_async)  (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  gchar * ( *lookup_by_address_finish) (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  GList * ( *lookup_service)           (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_service_async)     (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_service_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  /* Padding for future expansion */
+  void (*_g_reserved1) (void);
+  void (*_g_reserved2) (void);
+  void (*_g_reserved3) (void);
+  void (*_g_reserved4) (void);
+  void (*_g_reserved5) (void);
+  void (*_g_reserved6) (void);
+
+} GResolverClass;
+
+GType      g_resolver_get_type                  (void) G_GNUC_CONST;
+GResolver *g_resolver_get_default               (void);
+void       g_resolver_set_default               (GResolver            *resolver);
+
+GList     *g_resolver_lookup_by_name            (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_name_async      (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_by_name_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_addresses            (GList                *addresses);
+
+gchar     *g_resolver_lookup_by_address         (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_address_async   (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+gchar     *g_resolver_lookup_by_address_finish  (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+GList     *g_resolver_lookup_service            (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_service_async      (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_service_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_targets              (GList                *targets);
+
+/**
+ * G_RESOLVER_ERROR:
+ *
+ * Error domain for #GResolver. Errors in this domain will be from the
+ * #GResolverError enumeration. See #GError for more information on
+ * error domains.
+ **/
+#define G_RESOLVER_ERROR (g_resolver_error_quark ())
+GQuark g_resolver_error_quark (void);
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gsocketaddress.c b/gio/gsocketaddress.c
new file mode 100644
index 0000000..59bc453
--- /dev/null
+++ b/gio/gsocketaddress.c
@@ -0,0 +1,268 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "gsocketaddress.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gnetworkingprivate.h"
+#include "gsocketconnectable.h"
+#include "glibintl.h"
+#include "gioenumtypes.h"
+
+#ifdef G_OS_UNIX
+#include "gunixsocketaddress.h"
+#endif
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketaddress
+ * @short_description: Abstract base class representing endpoints for
+ * socket communication
+ *
+ * #GSocketAddress is the equivalent of <type>struct sockaddr</type>
+ * in the BSD sockets API. This is an abstract class; use
+ * #GInetSocketAddress for internet sockets, or #GUnixSocketAddress
+ * for UNIX domain sockets.
+ **/
+
+/**
+ * GSocketAddress:
+ *
+ * A socket endpoint address, corresponding to <type>struct sockaddr</type>
+ * or one of its subtypes.
+ **/
+
+enum
+{
+  PROP_NONE,
+  PROP_FAMILY
+};
+
+static void            g_socket_address_connectable_iface_init (GSocketConnectableIface *iface);
+static GSocketAddress *g_socket_address_connectable_get_next   (GSocketConnectable  *connectable,
+								GCancellable        *cancellable,
+								GError             **error);
+static void            g_socket_address_connectable_reset      (GSocketConnectable  *connectable);
+
+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (GSocketAddress, g_socket_address, G_TYPE_OBJECT,
+				  G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+							 g_socket_address_connectable_iface_init))
+
+/**
+ * g_socket_address_get_family:
+ * @address: a #GSocketAddress
+ *
+ * Gets the socket family type of @address.
+ *
+ * Returns: the socket family type of @address.
+ */
+GSocketAddressFamily
+g_socket_address_get_family (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), 0);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_family (address);
+}
+
+static void
+g_socket_address_get_property (GObject *object, guint prop_id,
+			       GValue *value, GParamSpec *pspec)
+{
+  GSocketAddress *address = G_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+     case PROP_FAMILY:
+      g_value_set_enum (value, g_socket_address_get_family (address));
+      break;
+
+     default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_socket_address_class_init (GSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->get_property = g_socket_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The family of the socket address"),
+						      G_TYPE_SOCKET_ADDRESS_FAMILY,
+						      G_SOCKET_ADDRESS_INVALID,
+						      G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_socket_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next = g_socket_address_connectable_get_next;
+  connectable_iface->reset    = g_socket_address_connectable_reset;
+}
+
+static void
+g_socket_address_init (GSocketAddress *address)
+{
+
+}
+
+/**
+ * g_socket_address_get_native_size:
+ * @address: a #GSocketAddress
+ *
+ * Gets the size of @address's native <type>struct sockaddr</type>.
+ * You can use this to allocate memory to pass to
+ * g_socket_address_to_native().
+ *
+ * Returns: the size of the native <type>struct sockaddr</type> that
+ * @address represents
+ */
+gssize
+g_socket_address_get_native_size (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), -1);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_native_size (address);
+}
+
+/**
+ * g_socket_address_to_native:
+ * @address: a #GSocketAddress
+ * @dest: a pointer to a memory location that will contain the native
+ * <type>struct sockaddr</type>.
+ * @destlen: the size of @dest. Must be at least as large as
+ * g_socket_address_get_native_size().
+ *
+ * Converts a #GSocketAddress to a native <type>struct
+ * sockaddr</type>, which can be passed to low-level functions like
+ * connect() or bind().
+ *
+ * Returns: %TRUE if @dest was filled in, %FALSE if @address is invalid
+ * or @destlen is too small.
+ */
+gboolean
+g_socket_address_to_native (GSocketAddress *address,
+			    gpointer        dest,
+			    gsize           destlen)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->to_native (address, dest, destlen);
+}
+
+/**
+ * g_socket_address_new_from_native:
+ * @native: a pointer to a <type>struct sockaddr</type>
+ * @len: the size of the memory location pointed to by @native
+ *
+ * Creates a #GSocketAddress subclass corresponding to the native
+ * <type>struct sockaddr</type> @native.
+ *
+ * Returns: a new #GSocketAddress if @native could successfully be converted,
+ * otherwise %NULL.
+ */
+GSocketAddress *
+g_socket_address_new_from_native (gpointer native,
+				  gsize    len)
+{
+  gshort family;
+
+  if (len < sizeof (gshort))
+    return NULL;
+
+  family = ((struct sockaddr *) native)->sa_family;
+
+  if (family == AF_UNSPEC)
+    return NULL;
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *addr = (struct sockaddr_in *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin_addr), AF_INET);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+  if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *addr = (struct sockaddr_in6 *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin6_addr), AF_INET6);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin6_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+#ifdef G_OS_UNIX
+  if (family == AF_UNIX)
+    {
+      struct sockaddr_un *addr = (struct sockaddr_un *) native;
+
+      return g_unix_socket_address_new (addr->sun_path);
+    }
+#endif
+
+  return NULL;
+}
+
+static GSocketAddress *
+g_socket_address_connectable_get_next (GSocketConnectable  *connectable,
+				       GCancellable        *cancellable,
+				       GError             **error)
+{
+  /* Rather than creating a GSocketAddressPrivate for just 1 bit of
+   * data, we cheat and use GObject data.
+   */
+  if (g_object_get_data (G_OBJECT (connectable), "GSocketConnectable-iterated"))
+    return NULL;
+  else
+    {
+      g_object_set_data (G_OBJECT (connectable),
+			 "GSocketConnectable-iterated",
+			 GINT_TO_POINTER (TRUE));
+      return g_object_ref (connectable);
+    }
+}
+
+static void
+g_socket_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  g_object_set_data (G_OBJECT (connectable),
+		     "GSocketConnectable-iterated",
+		     NULL);
+}
+
+#define __G_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketaddress.h b/gio/gsocketaddress.h
new file mode 100644
index 0000000..5783cee
--- /dev/null
+++ b/gio/gsocketaddress.h
@@ -0,0 +1,77 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_ADDRESS_H__
+#define __G_SOCKET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_ADDRESS         (g_socket_address_get_type ())
+#define G_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
+#define G_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+#define G_IS_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
+#define G_IS_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
+#define G_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+
+typedef struct _GSocketAddressClass   GSocketAddressClass;
+
+struct _GSocketAddress
+{
+  GObject parent_instance;
+};
+
+struct _GSocketAddressClass
+{
+  GObjectClass parent_class;
+
+  GSocketAddressFamily  (*get_family)      (GSocketAddress *address);
+
+  gssize                (*get_native_size) (GSocketAddress *address);
+
+  gboolean              (*to_native)       (GSocketAddress *address,
+					    gpointer        dest,
+	     				    gsize           destlen);
+};
+
+GType                 g_socket_address_get_type        (void) G_GNUC_CONST;
+
+GSocketAddressFamily  g_socket_address_get_family      (GSocketAddress *address);
+
+GSocketAddress *      g_socket_address_new_from_native (gpointer        native,
+							gsize           len);
+
+gboolean              g_socket_address_to_native       (GSocketAddress *address,
+							gpointer        dest,
+							gsize           destlen);
+
+gssize                g_socket_address_get_native_size (GSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_SOCKET_ADDRESS_H__ */
diff --git a/gio/gsocketconnectable.c b/gio/gsocketconnectable.c
new file mode 100644
index 0000000..c72dd7c
--- /dev/null
+++ b/gio/gsocketconnectable.c
@@ -0,0 +1,269 @@
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include "gsocketconnectable.h"
+#include "gsimpleasyncresult.h"
+#include "glibintl.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketconnectable
+ * @short_description: Interface for potential socket endpoints.
+ *
+ * Objects that describe one or more potential socket endpoints
+ * implement #GSocketConnectable. The caller can then use
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() to try out each
+ * #GSocketAddress in turn until it suceeds in connecting to one of
+ * them.
+ **/
+
+static void g_socket_connectable_base_init  (gpointer g_class);
+static void g_socket_connectable_class_init (gpointer g_class,
+					     gpointer class_data);
+
+static void            g_socket_connectable_real_get_next_async  (GSocketConnectable   *connectable,
+								  GCancellable         *cancellable,
+								  GAsyncReadyCallback   callback,
+								  gpointer              user_data);
+static GSocketAddress *g_socket_connectable_real_get_next_finish (GSocketConnectable   *connectable,
+								  GAsyncResult         *result,
+								  GError              **error);
+
+GType
+g_socket_connectable_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      const GTypeInfo connectable_info =
+      {
+        sizeof (GSocketConnectableIface), /* class_size */
+	g_socket_connectable_base_init,		/* base_init */
+	NULL,		/* base_finalize */
+	g_socket_connectable_class_init,
+	NULL,		/* class_finalize */
+	NULL,		/* class_data */
+	0,
+	0,              /* n_preallocs */
+	NULL
+      };
+      GType g_define_type_id =
+	g_type_register_static (G_TYPE_INTERFACE, I_("GSocketConnectable"),
+				&connectable_info, 0);
+
+      g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_OBJECT);
+
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
+
+static void
+g_socket_connectable_class_init (gpointer g_class,
+				 gpointer class_data)
+{
+  GSocketConnectableIface *iface = g_class;
+
+  iface->get_next_async = g_socket_connectable_real_get_next_async;
+  iface->get_next_finish = g_socket_connectable_real_get_next_finish;
+}
+
+static void
+g_socket_connectable_base_init (gpointer g_class)
+{
+}
+
+/**
+ * g_socket_connectable_get_next:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @error: a #GError.
+ *
+ * Retrieves the next #GSocketAddress from @connectable. Note that
+ * this may block for some amount of time. (Eg, @connectable may need
+ * to do a DNS lookup before it can return an address.) Use
+ * g_socket_connectable_get_next_async() if you need to avoid
+ * blocking.
+ *
+ * If @connectable is unable to yield any addresses (eg, because of a
+ * DNS error), then the first call to g_socket_connectable_get_next()
+ * will return an appropriate error in *@error. However, if the first
+ * call to g_socket_connectable_get_next() succeeds, then any further
+ * internal errors (other than @cancellable being triggered) will be
+ * ignored.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next (GSocketConnectable  *connectable,
+			       GCancellable        *cancellable,
+			       GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next) (connectable, cancellable, error);
+}
+
+/* Default implementation of get_next_async just calls the synchronous
+ * method; this can be used if the implementation already knows all of
+ * its addresses, and so the synchronous method will never block.
+ */
+static void
+g_socket_connectable_real_get_next_async (GSocketConnectable  *connectable,
+					  GCancellable        *cancellable,
+					  GAsyncReadyCallback  callback,
+					  gpointer             user_data)
+{
+  GSimpleAsyncResult *result;
+  GSocketAddress *address;
+  GError *error = NULL;
+
+  result = g_simple_async_result_new (G_OBJECT (connectable),
+				      callback, user_data,
+				      g_socket_connectable_real_get_next_async);
+  address = g_socket_connectable_get_next (connectable, cancellable, &error);
+  if (address)
+    g_simple_async_result_set_op_res_gpointer (result, address, g_object_unref);
+  else if (error)
+    {
+      g_simple_async_result_set_from_error (result, error);
+      g_error_free (error);
+    }
+  g_simple_async_result_complete_in_idle (result);
+  g_object_unref (result);
+}
+
+/**
+ * g_socket_connectable_get_next_async:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @callback: a #GAsyncReadyCallback to call when the request is satisfied
+ * @user_data: the data to pass to callback function
+ *
+ * Asynchronously retrieves the next #GSocketAddress from @connectable
+ * and then calls @callback, which must call
+ * g_socket_connectable_get_next_finish() to get the result.
+ **/
+void
+g_socket_connectable_get_next_async (GSocketConnectable  *connectable,
+				     GCancellable        *cancellable,
+				     GAsyncReadyCallback  callback,
+				     gpointer             user_data)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  (* iface->get_next_async) (connectable, cancellable, callback, user_data);
+}
+
+static GSocketAddress *
+g_socket_connectable_real_get_next_finish (GSocketConnectable  *connectable,
+					   GAsyncResult        *result,
+					   GError             **error)
+{
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (connectable), g_socket_connectable_real_get_next_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+/**
+ * g_socket_connectable_get_next_finish:
+ * @connectable: a #GSocketConnectable
+ * @result: a #GAsyncResult.
+ * @error: a #GError.
+ *
+ * Retrieves the result of a completed call to
+ * g_socket_connectable_get_next_async(). See
+ * g_socket_connectable_get_next() for more information about
+ * error handling.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next_finish (GSocketConnectable  *connectable,
+				      GAsyncResult        *result,
+				      GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+	return NULL;
+    }
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next_finish) (connectable, result, error);
+}
+
+/**
+ * g_socket_connectable_reset:
+ * @connectable: a #GSocketConnectable
+ *
+ * Resets @connectable's iterator state, so that the next call to
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() will return the first
+ * available #GSocketAddress again.
+ *
+ * You can only call this after successfully enumerating all
+ * addresses. Resetting a connectable at any other time may not
+ * necessarily work correctly.
+ **/
+void
+g_socket_connectable_reset (GSocketConnectable *connectable)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  if (iface->reset)
+    (* iface->reset) (connectable);
+}
+
+#define __G_SOCKET_CONNECTABLE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketconnectable.h b/gio/gsocketconnectable.h
new file mode 100644
index 0000000..115d6e3
--- /dev/null
+++ b/gio/gsocketconnectable.h
@@ -0,0 +1,94 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_CONNECTABLE_H__
+#define __G_SOCKET_CONNECTABLE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_CONNECTABLE            (g_socket_connectable_get_type ())
+#define G_SOCKET_CONNECTABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
+#define G_IS_SOCKET_CONNECTABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
+#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))
+
+/**
+ * GSocketConnectable:
+ *
+ * Interface for objects that enumerate #GSocketAddress<!-- -->es.
+ **/
+typedef struct _GSocketConnectableIface GSocketConnectableIface;
+
+/**
+ * GSocketConnectableIface:
+ * @g_iface: The parent interface.
+ * @get_next: Synchronously gets the next #GSocketAddress
+ * @get_next_async: Begins asynchronously getting the next #GSocketAddress
+ * @get_next_finish: Finishes asynchronously getting a #GSocketAddress
+ * @reset: Resets the enumerator
+ *
+ * Provides an interface for enumerating #GSocketAddress<!-- -->es.
+ **/
+struct _GSocketConnectableIface
+{
+  GTypeInterface g_iface;
+
+  /* Virtual Table */
+
+  GSocketAddress * (* get_next)        (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GError              **error);
+
+  void             (* get_next_async)  (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GAsyncReadyCallback   callback,
+		  			gpointer              user_data);
+  GSocketAddress * (* get_next_finish) (GSocketConnectable   *connectable,
+					GAsyncResult         *result,
+					GError              **error);
+
+  void             (* reset)           (GSocketConnectable   *connectable);
+};
+
+GType           g_socket_connectable_get_type        (void) G_GNUC_CONST;
+
+GSocketAddress *g_socket_connectable_get_next        (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GError              **error);
+
+void            g_socket_connectable_get_next_async  (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GAsyncReadyCallback   callback,
+						      gpointer              user_data);
+GSocketAddress *g_socket_connectable_get_next_finish (GSocketConnectable   *connectable,
+						      GAsyncResult         *result,
+						      GError              **error);
+
+void            g_socket_connectable_reset           (GSocketConnectable   *connectable);
+
+G_END_DECLS
+
+
+#endif /* __G_SOCKET_CONNECTABLE_H__ */
diff --git a/gio/gsrvtarget.c b/gio/gsrvtarget.c
new file mode 100644
index 0000000..6e2cb55
--- /dev/null
+++ b/gio/gsrvtarget.c
@@ -0,0 +1,353 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsrvtarget
+ * @short_description: DNS SRV record target
+ * @include: gio/gio.h
+ *
+ * SRV (service) records are used by some network protocols to provide
+ * service-specific aliasing and load-balancing. For example, XMPP
+ * (Jabber) uses SRV records to locate the XMPP server for a domain;
+ * rather than connecting directly to "example.com" or assuming a
+ * specific server hostname like "xmpp.example.com", an XMPP client
+ * would look up the "xmpp-client" SRV record for "example.com", and
+ * then connect to whatever host was pointed to by that record.
+ *
+ * Use g_resolver_lookup_service() or
+ * g_resolver_lookup_service_async() to find the #GSrvTarget<!-- -->s
+ * for a given service.
+ **/
+
+struct _GSrvTarget {
+  gchar   *hostname;
+  guint16  port;
+
+  guint16  priority;
+  guint16  weight;
+  time_t   expires;
+};
+
+/**
+ * GSrvTarget:
+ *
+ * A single target host/port that a network service is running on.
+ */
+
+GType
+g_srv_target_get_type (void)
+{
+  static volatile gsize type_volatile = 0;
+
+  if (g_once_init_enter (&type_volatile))
+    {
+      GType type = g_boxed_type_register_static (
+                        g_intern_static_string ("GSrvTarget"),
+			(GBoxedCopyFunc) g_srv_target_copy,
+			(GBoxedFreeFunc) g_srv_target_free);
+      g_once_init_leave (&type_volatile, type);
+    }
+  return type_volatile;
+}
+
+/**
+ * g_srv_target_new:
+ * @hostname: the host that the service is running on
+ * @port: the port that the service is running on
+ * @priority: the target's priority
+ * @weight: the target's weight
+ * @expires: the target's expiration time
+ *
+ * Creates a new #GSrvTarget with the given parameters.
+ *
+ * You should not need to use this; normally #GSrvTarget<!-- -->s are
+ * created by #GResolver.
+ *
+ * Return value: a new #GSrvTarget.
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_new (const gchar *hostname,
+                  guint16      port,
+                  guint16      priority,
+                  guint16      weight,
+                  time_t       expires)
+{
+  GSrvTarget *target = g_slice_new0 (GSrvTarget);
+
+  target->hostname = g_strdup (hostname);
+  target->port = port;
+  target->priority = priority;
+  target->weight = weight;
+  target->expires = expires;
+
+  return target;
+}
+
+/**
+ * g_srv_target_copy:
+ * @target: a #GSrvTarget
+ *
+ * Copies @target
+ *
+ * Return value: a copy of @target
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_copy (GSrvTarget *target)
+{
+  return g_srv_target_new (target->hostname, target->port,
+                           target->priority, target->weight,
+                           target->expires);
+}
+
+/**
+ * g_srv_target_free:
+ * @target: a #GSrvTarget
+ *
+ * Frees @target
+ *
+ * Since: 2.20
+ **/
+void
+g_srv_target_free (GSrvTarget *target)
+{
+  g_free (target->hostname);
+  g_slice_free (GSrvTarget, target);
+}
+
+/**
+ * g_srv_target_get_hostname:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's hostname (in ASCII form; if you are going to present
+ * this to the user, you should use g_hostname_is_ascii_encoded() to
+ * check if it contains encoded Unicode segments, and use
+ * g_hostname_to_unicode() to convert it if it does.)
+ *
+ * Return value: @target's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_srv_target_get_hostname (GSrvTarget *target)
+{
+  return target->hostname;
+}
+
+/**
+ * g_srv_target_get_port:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's port
+ *
+ * Return value: @target's port
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_port (GSrvTarget *target)
+{
+  return target->port;
+}
+
+/**
+ * g_srv_target_get_priority:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's priority. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's priority
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_priority (GSrvTarget *target)
+{
+  return target->priority;
+}
+
+/**
+ * g_srv_target_get_weight:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's weight. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's weight
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_weight (GSrvTarget *target)
+{
+  return target->weight;
+}
+
+/**
+ * g_srv_target_get_expires:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's expiration time.
+ *
+ * Return value: @target's expiration time
+ *
+ * Since: 2.20
+ **/
+time_t
+g_srv_target_get_expires (GSrvTarget *target)
+{
+  return target->expires;
+}
+
+gint
+compare_target (gconstpointer a, gconstpointer b)
+{
+  GSrvTarget *ta = (GSrvTarget *)a;
+  GSrvTarget *tb = (GSrvTarget *)b;
+
+  if (ta->priority == tb->priority)
+    {
+      /* Arrange targets of the same priority "in any order, except
+       * that all those with weight 0 are placed at the beginning of
+       * the list"
+       */
+      if (ta->weight == 0)
+        return -1;
+      else if (tb->weight == 0)
+        return 1;
+      else
+        return g_random_int_range (-1, 1);
+    }
+  else
+    return ta->priority - tb->priority;
+}
+
+/**
+ * g_srv_target_list_sort:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Sorts @targets in place according to the algorithm in RFC 2782.
+ *
+ * Return value: the head of the sorted list.
+ **/ 
+GList *
+g_srv_target_list_sort (GList *targets)
+{
+  gint sum, val, priority, weight;
+  GList *first, *last, *n;
+  GSrvTarget *target;
+  gpointer tmp;
+
+  if (!targets)
+    return NULL;
+
+  if (!targets->next)
+    {
+      target = targets->data;
+      if (!strcmp (target->hostname, "."))
+        {
+          /* 'A Target of "." means that the service is decidedly not
+           * available at this domain.'
+           */
+          g_srv_target_free (target);
+          g_list_free (targets);
+          return NULL;
+        }
+    }
+
+  /* Sort by priority, and partly by weight */
+  targets = g_list_sort (targets, compare_target);
+
+  /* For each group of targets with the same priority, rebalance them
+   * according to weight.
+   */
+  for (first = targets; first; first = last->next)
+    {
+      /* Skip @first to a non-0-weight target. */
+      while (first && ((GSrvTarget *)first->data)->weight == 0)
+        first = first->next;
+      if (!first)
+        break;
+
+      /* Skip @last to the last target of the same priority. */
+      priority = ((GSrvTarget *)first->data)->priority;
+      last = first;
+      while (last->next &&
+             ((GSrvTarget *)last->next->data)->priority == priority)
+        last = last->next;
+
+      /* If there's only one non-0 weight target at this priority,
+       * we can move on to the next priority level.
+       */
+      if (last == first)
+        continue;
+
+      /* Randomly reorder the non-0 weight targets, giving precedence
+       * to the ones with higher weight. RFC 2782 describes this in
+       * terms of assigning a running sum to each target and building
+       * a new list. We do things slightly differently, but should get
+       * the same result.
+       */
+      for (n = first, sum = 0; n != last->next; n = n->next)
+        sum += ((GSrvTarget *)n->data)->weight;
+      while (first != last)
+        {
+          val = g_random_int_range (0, sum);
+          for (n = first; n != last; n = n->next)
+            {
+              weight = ((GSrvTarget *)n->data)->weight;
+              if (val < weight)
+                break;
+              val -= weight;
+            }
+
+          tmp = first->data;
+          first->data = n->data;
+          n->data = tmp;
+
+          sum -= weight;
+          first = first->next;
+        }
+    }
+
+  return targets;
+}
+
+#define __G_SRV_TARGET_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsrvtarget.h b/gio/gsrvtarget.h
new file mode 100644
index 0000000..995b09a
--- /dev/null
+++ b/gio/gsrvtarget.h
@@ -0,0 +1,54 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SRV_TARGET_H__
+#define __G_SRV_TARGET_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+GType g_srv_target_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SRV_TARGET (g_srv_target_get_type ())
+
+GSrvTarget  *g_srv_target_new          (const gchar *hostname,
+				        guint16      port,
+				        guint16      priority,
+				        guint16      weight,
+				        time_t       expires);
+GSrvTarget  *g_srv_target_copy         (GSrvTarget  *target);
+void         g_srv_target_free         (GSrvTarget  *target);
+
+const gchar *g_srv_target_get_hostname (GSrvTarget  *target);
+guint16      g_srv_target_get_port     (GSrvTarget  *target);
+guint16      g_srv_target_get_priority (GSrvTarget  *target);
+guint16      g_srv_target_get_weight   (GSrvTarget  *target);
+time_t       g_srv_target_get_expires  (GSrvTarget  *target);
+
+GList       *g_srv_target_list_sort    (GList       *targets);
+
+G_END_DECLS
+
+#endif /* __G_SRV_TARGET_H__ */
+
diff --git a/gio/gthreadedresolver.c b/gio/gthreadedresolver.c
new file mode 100644
index 0000000..0440a3d
--- /dev/null
+++ b/gio/gthreadedresolver.c
@@ -0,0 +1,617 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gthreadedresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GThreadedResolver, g_threaded_resolver, G_TYPE_RESOLVER)
+
+static void threaded_resolver_thread (gpointer thread_data, gpointer pool_data);
+
+static void
+g_threaded_resolver_init (GThreadedResolver *gtr)
+{
+  if (g_thread_supported ())
+    {
+      gtr->thread_pool = g_thread_pool_new (threaded_resolver_thread, gtr,
+					    -1, FALSE, NULL);
+    }
+}
+
+static void
+finalize (GObject *object)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (object);
+
+  g_thread_pool_free (gtr->thread_pool, FALSE, FALSE);
+
+  G_OBJECT_CLASS (g_threaded_resolver_parent_class)->finalize (object);
+}
+
+/* A GThreadedResolverRequest represents a request in progress
+ * (usually, but see case 1). It is refcounted, to make sure that it
+ * doesn't get freed too soon. In particular, it can't be freed until
+ * (a) the resolver thread has finished resolving, (b) the calling
+ * thread has received an answer, and (c) no other thread could be in
+ * the process of trying to cancel it.
+ *
+ * The possibilities:
+ *
+ * 1. Synchronous non-cancellable request: in this case, the request
+ *    is simply done in the calling thread, without using
+ *    GThreadedResolverRequest at all.
+ *
+ * 2. Synchronous cancellable request: A req is created with a GCond,
+ *    and 3 refs (for the resolution thread, the calling thread, and
+ *    the cancellation signal handler).
+ *
+ *      a. If the resolution completes successfully, the thread pool
+ *         function (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (dropping one ref on req)
+ *         and signal the GCond, and then unref the req. The calling
+ *         thread receives the signal from the GCond, processes the
+ *         response, and unrefs the req, causing it to be freed.
+ *
+ *      b. If the resolution is cancelled before completing,
+ *         request_cancelled() will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the signal handler (as above, unreffing the req), set
+ *         req->error to indicate that it was cancelled, and signal
+ *         the GCond. The calling thread receives the signal from the
+ *         GCond, processes the response, and unrefs the req.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * 3. Asynchronous request: A req is created with a GSimpleAsyncResult
+ *    (and no GCond). The calling thread's ref on req is set up to be
+ *    automatically dropped when the async_result is freed. Two
+ *    sub-possibilities:
+ *
+ *      a. If the resolution completes, the thread pool function
+ *         (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (if it was present)
+ *         (unreffing the req), queue the async_result to complete in
+ *         an idle handler, unref the async_result (which is still
+ *         reffed by the idle handler though), and then unref the req.
+ *         The main thread then invokes the async_result's callback
+ *         and processes the response. When it finishes, the
+ *         async_result drops the ref that was taken by
+ *         g_simple_async_result_complete_in_idle(), which causes the
+ *         async_result to be freed, which causes req to be unreffed
+ *         and freed.
+ *
+ *      b. If the resolution is cancelled, request_cancelled() will
+ *         call g_threaded_resolver_request_complete(), which will
+ *         detach the signal handler (as above, unreffing the req) set
+ *         req->error to indicate that it was cancelled, and queue and
+ *         unref the async_result. The main thread completes the
+ *         async_request and unrefs it and the req, as above.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * g_threaded_resolver_request_complete() ensures that if the request
+ * completes and cancels "at the same time" that only one of the two
+ * conditions gets processed.
+ */
+
+typedef struct _GThreadedResolverRequest GThreadedResolverRequest;
+typedef void (*GThreadedResolverResolveFunc) (GThreadedResolverRequest *, GError **);
+typedef void (*GThreadedResolverFreeFunc) (GThreadedResolverRequest *);
+
+struct _GThreadedResolverRequest {
+  GThreadedResolverResolveFunc resolve_func;
+  GThreadedResolverFreeFunc free_func;
+
+  union {
+    struct {
+      gchar *hostname;
+      GList *addresses;
+    } name;
+    struct {
+      GInetAddress *address;
+      gchar *name;
+    } address;
+    struct {
+      gchar *rrname;
+      GList *targets;
+    } service;
+  } u;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  GMutex *mutex;
+  guint ref_count;
+
+  GCond *cond;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+
+};
+
+static void g_threaded_resolver_request_unref (GThreadedResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable, gpointer req);
+static void request_cancelled_disconnect_notify (gpointer req, GClosure *closure);
+
+static GThreadedResolverRequest *
+g_threaded_resolver_request_new (GThreadedResolverResolveFunc  resolve_func,
+                                 GThreadedResolverFreeFunc     free_func,
+				 GCancellable                 *cancellable)
+{
+  GThreadedResolverRequest *req;
+
+  req = g_slice_new0 (GThreadedResolverRequest);
+  req->resolve_func = resolve_func;
+  req->free_func = free_func;
+
+  /* Initial refcount is 2; one for the caller and one for resolve_func */
+  req->ref_count = 2;
+
+  if (g_thread_supported ())
+    req->mutex = g_mutex_new ();
+  /* Initially locked; caller must unlock */
+  g_mutex_lock (req->mutex);
+
+  if (cancellable)
+    {
+      req->ref_count++;
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect_data (cancellable, "cancelled",
+			     G_CALLBACK (request_cancelled), req,
+			     request_cancelled_disconnect_notify, 0);
+    }
+
+  return req;
+}
+
+static void
+g_threaded_resolver_request_unref (GThreadedResolverRequest *req)
+{
+  guint ref_count;
+
+  g_mutex_lock (req->mutex);
+  ref_count = --req->ref_count;
+  g_mutex_unlock (req->mutex);
+  if (ref_count > 0)
+    return;
+
+  g_mutex_free (req->mutex);
+
+  if (req->cond)
+    g_cond_free (req->cond);
+
+  if (req->error)
+    g_error_free (req->error);
+
+  if (req->free_func)
+    req->free_func (req);
+
+  /* We don't have to free req->cancellable or req->async_result,
+   * since (if set), they must already have been freed by
+   * request_complete() in order to get here.
+   */
+
+  g_slice_free (GThreadedResolverRequest, req);
+}
+
+static void
+g_threaded_resolver_request_complete (GThreadedResolverRequest *req,
+				      gboolean                  cancelled)
+{
+  g_mutex_lock (req->mutex);
+  if (req->complete)
+    {
+      /* The req was cancelled, and now it has finished resolving as
+       * well. But we have nowhere to send the result, so just return.
+       */
+      g_mutex_unlock (req->mutex);
+      return;
+    }
+
+  req->complete = TRUE;
+  g_mutex_unlock (req->mutex);
+
+  if (req->cancellable)
+    {
+      /* Possibly propagate a cancellation error */
+      if (cancelled && !req->error)
+        g_cancellable_set_error_if_cancelled (req->cancellable, &req->error);
+
+      /* Drop the signal handler's ref on @req */
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (req->cond)
+    g_cond_signal (req->cond);
+  else if (req->async_result)
+    {
+      if (req->error)
+        g_simple_async_result_set_from_error (req->async_result, req->error);
+      g_simple_async_result_complete_in_idle (req->async_result);
+
+      /* Drop our ref on the async_result, which will eventually cause
+       * it to drop its ref on req.
+       */
+      g_object_unref (req->async_result);
+      req->async_result = NULL;
+    }
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GThreadedResolverRequest *req = user_data;
+
+  g_threaded_resolver_request_complete (req, TRUE);
+
+  /* We can't actually cancel the resolver thread; it will eventually
+   * complete on its own and call request_complete() again, which will
+   * do nothing the second time.
+   */
+}
+
+static void
+request_cancelled_disconnect_notify (gpointer  req,
+                                     GClosure *closure)
+{
+  g_threaded_resolver_request_unref (req);
+}
+
+static void
+threaded_resolver_thread (gpointer thread_data,
+                          gpointer pool_data)
+{
+  GThreadedResolverRequest *req = thread_data;
+
+  req->resolve_func (req, &req->error);
+  g_threaded_resolver_request_complete (req, FALSE);
+  g_threaded_resolver_request_unref (req);
+}  
+
+static void
+resolve_sync (GThreadedResolver         *gtr,
+              GThreadedResolverRequest  *req,
+              GError                   **error)
+{
+  if (!req->cancellable || !gtr->thread_pool)
+    {
+      req->resolve_func (req, error);
+      return;
+    }
+
+  req->cond = g_cond_new ();
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_cond_wait (req->cond, req->mutex);
+  g_mutex_unlock (req->mutex);
+
+  if (req->error)
+    {
+      g_propagate_error (error, req->error);
+      req->error = NULL;
+    }
+}
+
+static void
+resolve_async (GThreadedResolver        *gtr,
+               GThreadedResolverRequest *req,
+               GAsyncReadyCallback       callback,
+               gpointer                  user_data,
+               gpointer                  tag)
+{
+  req->async_result = g_simple_async_result_new (G_OBJECT (gtr),
+                                                 callback, user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_mutex_unlock (req->mutex);
+}
+
+static GThreadedResolverRequest *
+resolve_finish (GResolver     *resolver,
+                GAsyncResult  *result,
+		gpointer       tag,
+                GError       **error)
+{
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), tag), NULL);
+
+  return g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result));
+}
+
+static void
+do_lookup_by_name (GThreadedResolverRequest  *req,
+                   GError                   **error)
+{
+  struct addrinfo *res = NULL;
+  gint retval;
+
+  retval = getaddrinfo (req->u.name.hostname, NULL,
+                        &_g_resolver_addrinfo_hints, &res);
+  req->u.name.addresses =
+    _g_resolver_addresses_from_addrinfo (req->u.name.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+}
+
+static GList *
+lookup_by_name (GResolver     *resolver,
+                const gchar   *hostname,
+                GCancellable  *cancellable,
+                GError       **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, NULL, cancellable);
+  req->u.name.hostname = (gchar *)hostname;
+  resolve_sync (gtr, req, error);
+
+  addresses = req->u.name.addresses;
+  g_threaded_resolver_request_unref (req);
+  return addresses;
+}
+
+static void
+free_lookup_by_name (GThreadedResolverRequest *req)
+{
+  g_free (req->u.name.hostname);
+  if (req->u.name.addresses)
+    g_resolver_free_addresses (req->u.name.addresses);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, free_lookup_by_name,
+                                         cancellable);
+  req->u.name.hostname = g_strdup (hostname);
+  resolve_async (gtr, req, callback, user_data, lookup_by_name_async);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = resolve_finish (resolver, result, lookup_by_name_async, error);
+  addresses = req->u.name.addresses;
+  req->u.name.addresses = NULL;
+  return addresses;
+}
+
+
+static void
+do_lookup_by_address (GThreadedResolverRequest  *req,
+                      GError                   **error)
+{
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+  gchar name[NI_MAXHOST];
+  gint retval;
+
+  _g_resolver_address_to_sockaddr (req->u.address.address,
+                                   &sockaddr, &sockaddr_size);
+
+  retval = getnameinfo ((struct sockaddr *)&sockaddr, sockaddr_size,
+                        name, sizeof (name), NULL, 0, NI_NAMEREQD);
+  req->u.address.name = _g_resolver_name_from_nameinfo (req->u.address.address,
+                                                        name, retval, error);
+}
+
+static gchar *
+lookup_by_address (GResolver        *resolver,
+                   GInetAddress     *address,
+                   GCancellable     *cancellable,
+                   GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address, NULL, cancellable);
+  req->u.address.address = address;
+  resolve_sync (gtr, req, error);
+
+  name = req->u.address.name;
+  g_threaded_resolver_request_unref (req);
+  return name;
+}
+
+static void
+free_lookup_by_address (GThreadedResolverRequest *req)
+{
+  g_object_unref (req->u.address.address);
+  if (req->u.address.name)
+    g_free (req->u.address.name);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address,
+                                         free_lookup_by_address,
+                                         cancellable);
+  req->u.address.address = g_object_ref (address);
+  resolve_async (gtr, req, callback, user_data, lookup_by_address_async);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = resolve_finish (resolver, result, lookup_by_address_async, error);
+  name = req->u.address.name;
+  req->u.address.name = NULL;
+  return name;
+}
+
+
+static void
+do_lookup_service (GThreadedResolverRequest *req,
+                   GError   **error)
+{
+#if defined(G_OS_UNIX)
+  gint len, herr;
+  guchar answer[1024];
+#elif defined(G_OS_WIN32)
+  DNS_STATUS status;
+  DNS_RECORD *results;
+#endif
+
+#if defined(G_OS_UNIX)
+  len = res_query (req->u.service.rrname, C_IN, T_SRV, answer, sizeof (answer));
+  herr = h_errno;
+  req->u.service.targets = _g_resolver_targets_from_res_query (req->u.service.rrname, answer, len, herr, error);
+#elif defined(G_OS_WIN32)
+  status = DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV,
+                       DNS_QUERY_STANDARD, NULL, &results, NULL);
+  req->u.service.targets = _g_resolver_targets_from_DnsQuery (req->u.service.rrname, status, results, error);
+  DnsRecordListFree (results, DnsFreeRecordList);
+#endif
+}
+
+static GList *
+lookup_service (GResolver        *resolver,
+                const gchar      *rrname,
+		GCancellable     *cancellable,
+                GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = g_threaded_resolver_request_new (do_lookup_service, NULL, cancellable);
+  req->u.service.rrname = (char *)rrname;
+  resolve_sync (gtr, req, error);
+
+  targets = req->u.service.targets;
+  g_threaded_resolver_request_unref (req);
+  return targets;
+}
+
+static void
+free_lookup_service (GThreadedResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.targets)
+    g_resolver_free_targets (req->u.service.targets);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_service,
+                                         free_lookup_service,
+                                         cancellable);
+  req->u.service.rrname = g_strdup (rrname);
+  resolve_async (gtr, req, callback, user_data, lookup_service_async);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = resolve_finish (resolver, result, lookup_service_async, error);
+  targets = req->u.service.targets;
+  req->u.service.targets = NULL;
+  return targets;
+}
+
+
+static void
+g_threaded_resolver_class_init (GThreadedResolverClass *threaded_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (threaded_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (threaded_class);
+
+  resolver_class->lookup_by_name           = lookup_by_name;
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address        = lookup_by_address;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service           = lookup_service;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = finalize;
+}
+
+#define __G_THREADED_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gthreadedresolver.h b/gio/gthreadedresolver.h
new file mode 100644
index 0000000..79d3327
--- /dev/null
+++ b/gio/gthreadedresolver.h
@@ -0,0 +1,50 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_THREADED_RESOLVER_H__
+#define __G_THREADED_RESOLVER_H__
+
+#include <gio/gresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_THREADED_RESOLVER         (g_threaded_resolver_get_type ())
+#define G_THREADED_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolver))
+#define G_THREADED_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+#define G_IS_THREADED_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THREADED_RESOLVER))
+#define G_IS_THREADED_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THREADED_RESOLVER))
+#define G_THREADED_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+
+typedef struct {
+  GResolver parent_instance;
+
+  GThreadPool *thread_pool;
+} GThreadedResolver;
+
+typedef struct {
+  GResolverClass parent_class;
+
+} GThreadedResolverClass;
+
+GType g_threaded_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixresolver.c b/gio/gunixresolver.c
new file mode 100644
index 0000000..36bb046
--- /dev/null
+++ b/gio/gunixresolver.c
@@ -0,0 +1,433 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <resolv.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "gunixresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GUnixResolver, g_unix_resolver, G_TYPE_THREADED_RESOLVER)
+
+static gboolean g_unix_resolver_watch (GIOChannel   *iochannel,
+                                       GIOCondition  condition,
+                                       gpointer      user_data);
+
+static void
+g_unix_resolver_init (GUnixResolver *gur)
+{
+  gint fd;
+  GIOChannel *io;
+
+  /* FIXME: how many workers? */
+  gur->asyncns = _g_asyncns_new (2);
+
+  fd = _g_asyncns_fd (gur->asyncns);
+  io = g_io_channel_unix_new (fd);
+  gur->watch = g_io_add_watch (io, G_IO_IN | G_IO_HUP | G_IO_ERR,
+                               g_unix_resolver_watch, gur);
+  g_io_channel_unref (io);
+}
+
+static void
+g_unix_resolver_finalize (GObject *object)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (object);
+
+  if (gur->watch)
+    g_source_remove (gur->watch);
+  _g_asyncns_free (gur->asyncns);
+
+  G_OBJECT_CLASS (g_unix_resolver_parent_class)->finalize (object);
+}
+
+/* The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: An appropriate _g_asyncns_query_t is created, and
+ *    then a GUnixResolverRequest is created with that query and a
+ *    GSimpleAsyncResult. Two sub-possibilities:
+ *
+ *      a. The resolution completes: g_unix_resolver_watch() sees that
+ *         the request has completed, and calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         "cancelled" signal handler (if it was present) and then
+ *         immediately completes the async_result (since
+ *         g_unix_resolver_watch() is already run from main-loop
+ *         time.) After completing the async_result, it unrefs it,
+ *         causing the req to be freed as well.
+ *
+ *      b. The resolution is cancelled: request_cancelled() calls
+ *         _g_asyncns_cancel() to cancel the resolution. Then it calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         signal handler, and queues async_result to complete in an
+ *         idle handler. It then unrefs the async_result to ensure
+ *         that after its callback runs, it will be destroyed, in turn
+ *         causing the req to be freed. Because the asyncns resolution
+ *         was cancelled, g_unix_resolver_watch() will never be
+ *         triggered for this req.
+ *
+ *    Since there's only a single thread, it's not possible for the
+ *    request to both complete and be cancelled "at the same time",
+ *    and each of the two possibilities takes steps to block the other
+ *    from being able to happen later, so it's always safe to free req
+ *    after the async_result completes.
+ */
+
+typedef struct _GUnixResolverRequest GUnixResolverRequest;
+typedef void (*GUnixResolverFreeFunc) (GUnixResolverRequest *);
+
+struct _GUnixResolverRequest {
+  GUnixResolver *gur;
+
+  _g_asyncns_query_t *qy;
+  union {
+    gchar *hostname;
+    GInetAddress *address;
+    gchar *service;
+  } u;
+  GUnixResolverFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GSimpleAsyncResult *async_result;
+
+};
+
+static void g_unix_resolver_request_free (GUnixResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable,
+                               gpointer      user_data);
+
+static GUnixResolverRequest *
+g_unix_resolver_request_new (GUnixResolver         *gur,
+                             _g_asyncns_query_t    *qy,
+                             GUnixResolverFreeFunc  free_func,
+                             GCancellable          *cancellable,
+                             GSimpleAsyncResult    *async_result)
+{
+  GUnixResolverRequest *req;
+
+  req = g_slice_new0 (GUnixResolverRequest);
+  req->gur = g_object_ref (gur);
+  req->qy = qy;
+  req->free_func = free_func;
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  req->async_result = g_object_ref (async_result);
+
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, (GDestroyNotify)g_unix_resolver_request_free);
+
+  return req;
+}
+
+static void
+g_unix_resolver_request_free (GUnixResolverRequest *req)
+{
+  /* If the user didn't call _finish the qy will still be around. */
+  if (req->qy)
+    _g_asyncns_cancel (req->gur->asyncns, req->qy);
+
+  /* We don't have to free req->cancellable and req->async_result,
+   * since they must already have been freed if we're here.
+   */
+
+  g_slice_free (GUnixResolverRequest, req);
+}
+
+static void
+g_unix_resolver_request_complete (GUnixResolverRequest *req,
+                                  gboolean              need_idle)
+{
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (need_idle)
+    g_simple_async_result_complete_in_idle (req->async_result);
+  else
+    g_simple_async_result_complete (req->async_result);
+
+  /* If we completed_in_idle, that will have taken an extra ref on
+   * req->async_result; if not, then we're already done. Either way we
+   * need to unref the async_result to make sure it eventually is
+   * destroyed, causing req to be freed.
+   */
+  g_object_unref (req->async_result);
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GUnixResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  _g_asyncns_cancel (req->gur->asyncns, req->qy);
+  req->qy = NULL;
+
+  g_cancellable_set_error_if_cancelled (cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_error_free (error);
+
+  g_unix_resolver_request_complete (req, TRUE);
+}
+
+static gboolean
+g_unix_resolver_watch (GIOChannel   *iochannel,
+                       GIOCondition  condition,
+                       gpointer      user_data)
+{
+  GUnixResolver *gur = user_data;
+  _g_asyncns_query_t *qy;
+  GUnixResolverRequest *req;
+
+  if (condition & (G_IO_HUP | G_IO_ERR))
+    {
+      /* Shouldn't happen. Should we create a new asyncns? FIXME */
+      g_warning ("asyncns died");
+      gur->watch = 0;
+      return FALSE;
+    }
+
+  while (_g_asyncns_wait (gur->asyncns, FALSE) == 0 &&
+         (qy = _g_asyncns_getnext (gur->asyncns)) != NULL)
+    {
+      req = _g_asyncns_getuserdata (gur->asyncns, qy);
+      g_unix_resolver_request_complete (req, FALSE);
+    }
+
+  return TRUE;
+}
+
+static GUnixResolverRequest *
+resolve_async (GUnixResolver         *gur,
+               _g_asyncns_query_t    *qy,
+               GUnixResolverFreeFunc  free_func,
+               GCancellable          *cancellable,
+               GAsyncReadyCallback    callback,
+               gpointer               user_data,
+               gpointer               tag)
+{
+  GSimpleAsyncResult *result;
+  GUnixResolverRequest *req;
+
+  result = g_simple_async_result_new (G_OBJECT (gur), callback, user_data, tag);
+  req = g_unix_resolver_request_new (gur, qy, free_func, cancellable, result);
+  g_object_unref (result);
+  _g_asyncns_setuserdata (gur->asyncns, qy, req);
+
+  return req;
+}
+
+static void
+lookup_by_name_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.hostname);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_getaddrinfo (gur->asyncns, hostname, NULL,
+                               &_g_resolver_addrinfo_hints);
+  req = resolve_async (gur, qy, lookup_by_name_free, cancellable,
+                       callback, user_data, lookup_by_name_async);
+  req->u.hostname = g_strdup (hostname);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  struct addrinfo *res;
+  gint retval;
+  GList *addresses;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getaddrinfo_done (req->gur->asyncns, req->qy, &res);
+  req->qy = NULL;
+  addresses = _g_resolver_addresses_from_addrinfo (req->u.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+
+  return addresses;
+}
+
+
+static void
+lookup_by_address_free (GUnixResolverRequest *req)
+{
+  g_object_unref (req->u.address);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+
+  _g_resolver_address_to_sockaddr (address, &sockaddr, &sockaddr_size);
+  qy = _g_asyncns_getnameinfo (gur->asyncns,
+                               (struct sockaddr *)&sockaddr, sockaddr_size,
+                               NI_NAMEREQD, TRUE, FALSE);
+  req = resolve_async (gur, qy, lookup_by_address_free, cancellable,
+                       callback, user_data, lookup_by_address_async);
+  req->u.address = g_object_ref (address);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  gchar host[NI_MAXHOST], *name;
+  gint retval;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getnameinfo_done (req->gur->asyncns, req->qy,
+                                        host, sizeof (host), NULL, 0);
+  req->qy = NULL;
+  name = _g_resolver_name_from_nameinfo (req->u.address, host, retval, error);
+
+  return name;
+}
+
+
+static void
+lookup_service_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.service);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_res_query (gur->asyncns, rrname, C_IN, T_SRV);
+  req = resolve_async (gur, qy, lookup_service_free, cancellable,
+                       callback, user_data, lookup_service_async);
+  req->u.service = g_strdup (rrname);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  guchar *answer;
+  gint len, herr;
+  GList *targets;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  len = _g_asyncns_res_done (req->gur->asyncns, req->qy, &answer);
+  req->qy = NULL;
+  if (len < 0)
+    herr = h_errno;
+  else
+    herr = 0;
+
+  targets = _g_resolver_targets_from_res_query (req->u.service, answer, len, herr, error);
+  _g_asyncns_freeanswer (answer);
+
+  return targets;
+}
+
+
+static void
+g_unix_resolver_class_init (GUnixResolverClass *unix_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (unix_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (unix_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = g_unix_resolver_finalize;
+}
+
+#define __G_UNIX_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixresolver.h b/gio/gunixresolver.h
new file mode 100644
index 0000000..cf7765b
--- /dev/null
+++ b/gio/gunixresolver.h
@@ -0,0 +1,53 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_UNIX_RESOLVER_H__
+#define __G_UNIX_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+#include "libasyncns/asyncns.h"
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_RESOLVER         (g_unix_resolver_get_type ())
+#define G_UNIX_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_RESOLVER, GUnixResolver))
+#define G_UNIX_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+#define G_IS_UNIX_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_RESOLVER))
+#define G_IS_UNIX_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_RESOLVER))
+#define G_UNIX_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+  _g_asyncns_t *asyncns;
+  guint watch;
+
+} GUnixResolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GUnixResolverClass;
+
+GType g_unix_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixsocketaddress.c b/gio/gunixsocketaddress.c
new file mode 100644
index 0000000..419ea22
--- /dev/null
+++ b/gio/gunixsocketaddress.c
@@ -0,0 +1,204 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "gunixsocketaddress.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gunixsocketaddress
+ * @short_description: Unix socket addresses
+ *
+ * Support for UNIX-domain (aka local) sockets.
+ **/
+
+/**
+ * GUnixSocketAddress:
+ *
+ * A UNIX-domain (local) socket address, corresponding to a
+ * <type>struct sockaddr_un</type>.
+ **/
+G_DEFINE_TYPE (GUnixSocketAddress, g_unix_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum
+{
+  PROP_0,
+  PROP_PATH,
+};
+
+struct _GUnixSocketAddressPrivate
+{
+  char *path;
+};
+
+static void
+g_unix_socket_address_finalize (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  g_free (address->priv->path);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize)
+    (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_unix_socket_address_dispose (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_unix_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_value_set_string (value, address->priv->path);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketAddressFamily
+g_unix_socket_address_get_family (GSocketAddress *address)
+{
+  g_assert (PF_UNIX == G_SOCKET_ADDRESS_UNIX);
+
+  return G_SOCKET_ADDRESS_UNIX;
+}
+
+static void
+g_unix_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_free (address->priv->path);
+        address->priv->path = g_value_dup_string (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static gssize
+g_unix_socket_address_get_native_size (GSocketAddress *address)
+{
+  return sizeof (struct sockaddr_un);
+}
+
+static gboolean
+g_unix_socket_address_to_native (GSocketAddress *address,
+				 gpointer        dest,
+				 gsize           destlen)
+{
+  GUnixSocketAddress *addr = G_UNIX_SOCKET_ADDRESS (address);
+  struct sockaddr_un *sock;
+
+  if (destlen < sizeof (*sock))
+    return FALSE;
+
+  sock = (struct sockaddr_un *) dest;
+  sock->sun_family = AF_UNIX;
+  g_strlcpy (sock->sun_path, addr->priv->path, sizeof (sock->sun_path));
+
+  return TRUE;
+}
+
+static void
+g_unix_socket_address_class_init (GUnixSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GUnixSocketAddressPrivate));
+
+  gobject_class->finalize = g_unix_socket_address_finalize;
+  gobject_class->dispose = g_unix_socket_address_dispose;
+  gobject_class->set_property = g_unix_socket_address_set_property;
+  gobject_class->get_property = g_unix_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_unix_socket_address_get_family;
+  gsocketaddress_class->to_native = g_unix_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_unix_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_PATH,
+                                   g_param_spec_string ("path",
+                                                        _("Path"),
+                                                        _("UNIX socket path"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB));
+}
+
+static void
+g_unix_socket_address_init (GUnixSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_UNIX_SOCKET_ADDRESS,
+                                               GUnixSocketAddressPrivate);
+
+  address->priv->path = NULL;
+}
+
+/**
+ * g_unix_socket_address_new:
+ * @path: the socket path
+ *
+ * Creates a new #GUnixSocketAddress for @path.
+ *
+ * Returns: a new #GUnixSocketAddress
+ */
+GSocketAddress *
+g_unix_socket_address_new (const gchar *path)
+{
+  return g_object_new (G_TYPE_UNIX_SOCKET_ADDRESS,
+		       "path", path,
+		       NULL);
+}
+
+#define __G_UNIX_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixsocketaddress.h b/gio/gunixsocketaddress.h
new file mode 100644
index 0000000..3ab1766
--- /dev/null
+++ b/gio/gunixsocketaddress.h
@@ -0,0 +1,61 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#ifndef __G_UNIX_SOCKET_ADDRESS_H__
+#define __G_UNIX_SOCKET_ADDRESS_H__
+
+#include <gio/gsocketaddress.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_SOCKET_ADDRESS         (g_unix_socket_address_get_type ())
+#define G_UNIX_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
+#define G_UNIX_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+#define G_IS_UNIX_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+
+typedef struct _GUnixSocketAddress        GUnixSocketAddress;
+typedef struct _GUnixSocketAddressClass   GUnixSocketAddressClass;
+typedef struct _GUnixSocketAddressPrivate GUnixSocketAddressPrivate;
+
+struct _GUnixSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GUnixSocketAddressPrivate *priv;
+};
+
+struct _GUnixSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_unix_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_unix_socket_address_new         (const gchar *path);
+
+G_END_DECLS
+
+#endif /* __G_UNIX_SOCKET_ADDRESS_H__ */
diff --git a/gio/gwin32resolver.c b/gio/gwin32resolver.c
new file mode 100644
index 0000000..cab45cc
--- /dev/null
+++ b/gio/gwin32resolver.c
@@ -0,0 +1,481 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gwin32resolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GWin32Resolver, g_win32_resolver, G_TYPE_THREADED_RESOLVER)
+
+static void
+g_win32_resolver_init (GWin32Resolver *gwr)
+{
+}
+
+/* This is simpler than GThreadedResolver since we don't have to worry
+ * about multiple application-level threads, but more complicated than
+ * GUnixResolver, since we do have to deal with multiple threads of
+ * our own.
+ *
+ * The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: A GWin32ResolverRequest is created with
+ *    appropriate query-specific information, a Windows event handle,
+ *    and a GSimpleAsyncResult. This is then handed to the
+ *    Windows-internal thread pool, which does the raw DNS query part
+ *    of the operation (being careful to not call any glib methods
+ *    that might fail when called from another thread when
+ *    g_thread_init() has not been called). The main thread sets up a
+ *    GSource to asynchronously poll the event handle. There are two
+ *    sub-possibilities:
+ *
+ *      a. The resolution completes: the threadpool function calls
+ *         SetEvent() on the event handle and then returns.
+ *
+ *      b. The resolution is cancelled: request_cancelled()
+ *         disconnects the "cancelled" signal handler, and queues an
+ *         idle handler to complete the async_result.
+ *
+ *    Since we can't free the request from the threadpool thread
+ *    (because of glib locking issues), we *always* have to have it
+ *    call SetEvent and trigger the callback to indicate that it is
+ *    done. But this means that it's possible for the request to be
+ *    cancelled (queuing an idle handler to return that result) and
+ *    then have the resolution thread complete before the idle handler
+ *    runs. So the event callback and the idle handler need to both
+ *    watch out for this, making sure we don't complete the same
+ *    result twice.
+ */
+
+typedef struct GWin32ResolverRequest GWin32ResolverRequest;
+typedef void (*GWin32ResolverRequestFreeFunc) (GWin32ResolverRequest *);
+
+struct GWin32ResolverRequest {
+  GWin32ResolverRequestFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  HANDLE *event;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+  guint cancelled_idle;
+
+  union {
+    struct {
+      gchar *name;
+      gint retval;
+      struct addrinfo *res;
+    } name;
+
+    struct {
+      GInetAddress *iaddr;
+      struct sockaddr_storage addr;
+      gsize addrlen;
+      gint retval;
+      gchar *namebuf;
+    } address;
+
+    struct {
+      gchar *rrname;
+      DNS_STATUS retval;
+      DNS_RECORD *results;
+    } service;
+  } u;
+
+};
+
+static GSource *g_win32_handle_source_add (HANDLE      handle,
+                                           GSourceFunc callback,
+                                           gpointer    user_data);
+
+static gboolean request_completed (gpointer      user_data);
+static void     request_cancelled (GCancellable *cancellable,
+                                   gpointer      user_data);
+
+GWin32ResolverRequest *
+g_win32_resolver_request_new (GResolver                     *resolver,
+                              GWin32ResolverRequestFreeFunc  free_func,
+                              GCancellable                  *cancellable,
+                              GAsyncReadyCallback            callback,
+                              gpointer                       user_data,
+                              gpointer                       tag)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_slice_new0 (GWin32ResolverRequest);
+  req->free_func = free_func;
+
+  req->async_result = g_simple_async_result_new (G_OBJECT (resolver), callback,
+                                                 user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+
+  req->event = CreateEvent (NULL, FALSE, FALSE, NULL);
+  g_win32_handle_source_add (req->event, request_completed, req);  
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  return req;
+}
+
+static gboolean
+request_completed (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  /* Clean up cancellation-related stuff first */
+  if (req->cancelled_idle)
+    {
+      g_source_remove (req->cancelled_idle);
+      req->cancelled_idle = 0;
+    }
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+    }
+
+  /* Now complete the result (assuming it wasn't already completed) */
+  if (req->async_result)
+    {
+      g_simple_async_result_complete (req->async_result);
+      g_object_unref (req->async_result);
+    }
+
+  /* And free req */
+  CloseHandle (req->event);
+  req->free_func (req);
+  g_slice_free (GWin32ResolverRequest, req);
+
+  return FALSE;
+}
+
+static gboolean
+request_cancelled_idle (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  req->cancelled_idle = 0;
+
+  g_cancellable_set_error_if_cancelled (req->cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_simple_async_result_complete (req->async_result);
+
+  g_object_unref (req->async_result);
+  req->async_result = NULL;
+
+  /* request_completed will eventually be called to free req */
+
+  return FALSE;
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  /* We need to wait until main-loop-time to actually complete the
+   * result; we don't use _complete_in_idle() here because we need to
+   * keep track of the source id.
+   */
+  req->cancelled_idle = g_idle_add (request_cancelled_idle, req);
+}
+
+static DWORD WINAPI
+lookup_by_name_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.name.retval = getaddrinfo (req->u.name.name, NULL,
+                                    &_g_resolver_addrinfo_hints,
+                                    &req->u.name.res);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_name (GWin32ResolverRequest *req)
+{
+  g_free (req->u.name.name);
+  if (req->u.name.res)
+    freeaddrinfo (req->u.name.res);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_name,
+                                      cancellable, callback, user_data,
+                                      lookup_by_name_async);
+  req->u.name.name = g_strdup (hostname);
+
+  QueueUserWorkItem (lookup_by_name_in_thread, req, 0);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_addresses_from_addrinfo (req->u.name.name, req->u.name.res,
+                                              req->u.name.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_by_addresses_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.address.retval =
+    getnameinfo ((struct sockaddr *)&req->u.address.addr,
+                 req->u.address.addrlen,
+                 req->u.address.namebuf, NI_MAXHOST, NULL, 0, NI_NAMEREQD);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_address (GWin32ResolverRequest *req)
+{
+  g_object_unref (req->u.address.iaddr);
+  g_free (req->u.address.namebuf);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_address,
+                                      cancellable, callback, user_data,
+                                      lookup_by_address_async);
+
+  req->u.address.iaddr = g_object_ref (address);
+  _g_resolver_address_to_sockaddr (address, &req->u.address.addr,
+                                   &req->u.address.addrlen);
+  req->u.address.namebuf = g_malloc (NI_MAXHOST);
+
+  QueueUserWorkItem (lookup_by_addresses_in_thread, req, 0);
+}
+
+static char *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_name_from_nameinfo (req->u.address.iaddr,
+                                         req->u.address.namebuf,
+                                         req->u.address.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_service_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.service.retval =
+    DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV, DNS_QUERY_STANDARD,
+                NULL, &req->u.service.results, NULL);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_service (GWin32ResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.results)
+    DnsRecordListFree (req->u.service.results, DnsFreeRecordList);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_service,
+                                      cancellable, callback, user_data,
+                                      lookup_service_async);
+  req->u.service.rrname = g_strdup (rrname);
+
+  QueueUserWorkItem (lookup_service_in_thread, req, 0);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_targets_from_DnsQuery (req->u.service.rrname,
+                                            req->u.service.retval,
+                                            req->u.service.results, error);
+}
+
+
+static void
+g_win32_resolver_class_init (GWin32ResolverClass *win32_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (win32_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+}
+
+
+/* Windows HANDLE GSource */
+
+typedef struct {
+  GSource source;
+  GPollFD pollfd;
+} GWin32HandleSource;
+
+static gboolean
+g_win32_handle_source_prepare (GSource *source,
+                               gint    *timeout)
+{
+  *timeout = -1;
+  return FALSE;
+}
+
+static gboolean
+g_win32_handle_source_check (GSource *source)
+{
+  GWin32HandleSource *hsource = (GWin32HandleSource *)source;
+
+  return hsource->pollfd.revents;
+}
+
+static gboolean
+g_win32_handle_source_dispatch (GSource     *source,
+                                GSourceFunc  callback,
+                                gpointer     user_data)
+{
+  return (*callback) (user_data);
+}
+
+static void
+g_win32_handle_source_finalize (GSource *source)
+{
+  ;
+}
+
+GSourceFuncs g_win32_handle_source_funcs = {
+  g_win32_handle_source_prepare,
+  g_win32_handle_source_check,
+  g_win32_handle_source_dispatch,
+  g_win32_handle_source_finalize
+};
+
+static GSource *
+g_win32_handle_source_add (HANDLE      handle,
+                           GSourceFunc callback,
+                           gpointer    user_data)
+{
+  GWin32HandleSource *hsource;
+  GSource *source;
+
+  source = g_source_new (&g_win32_handle_source_funcs, sizeof (GWin32HandleSource));
+  hsource = (GWin32HandleSource *)source;
+  hsource->pollfd.fd = (gint)handle;
+  hsource->pollfd.events = G_IO_IN;
+  hsource->pollfd.revents = 0;
+  g_source_add_poll (source, &hsource->pollfd);
+
+  g_source_set_callback (source, callback, user_data, NULL);
+  g_source_attach (source, NULL);
+  return source;
+}
+
+#define __G_WIN32_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gwin32resolver.h b/gio/gwin32resolver.h
new file mode 100644
index 0000000..5cc6a2c
--- /dev/null
+++ b/gio/gwin32resolver.h
@@ -0,0 +1,49 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_WIN32_RESOLVER_H__
+#define __G_WIN32_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_WIN32_RESOLVER         (g_win32_resolver_get_type ())
+#define G_WIN32_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_RESOLVER, GWin32Resolver))
+#define G_WIN32_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+#define G_IS_WIN32_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_RESOLVER))
+#define G_IS_WIN32_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_RESOLVER))
+#define G_WIN32_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+} GWin32Resolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GWin32ResolverClass;
+
+GType g_win32_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/libasyncns/Makefile.am b/gio/libasyncns/Makefile.am
new file mode 100644
index 0000000..80b20a2
--- /dev/null
+++ b/gio/libasyncns/Makefile.am
@@ -0,0 +1,15 @@
+## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/Makefile.decl
+
+INCLUDES = -I$(top_srcdir)
+
+noinst_LTLIBRARIES = libasyncns.la
+
+libasyncns_la_SOURCES = \
+	asyncns.c \
+	asyncns.h \
+	g-asyncns.h
+
+libasyncns_la_LIBADD = $(LIBASYNCNS_LIBADD)
+
+EXTRA_DIST += README update.sh
diff --git a/gio/libasyncns/README b/gio/libasyncns/README
new file mode 100644
index 0000000..b926291
--- /dev/null
+++ b/gio/libasyncns/README
@@ -0,0 +1,7 @@
+The sources are derived from Lennart Poettering's libasyncns library:
+
+ http://0pointer.de/lennart/projects/libasyncns/
+
+The 'update.sh' script in this directory, when pointed at
+the original sources updates the files in this directory
+to the new version
diff --git a/gio/libasyncns/asyncns.c b/gio/libasyncns/asyncns.c
new file mode 100644
index 0000000..3c4db73
--- /dev/null
+++ b/gio/libasyncns/asyncns.c
@@ -0,0 +1,1498 @@
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include "g-asyncns.h"
+#endif
+
+/* #undef HAVE_PTHREAD */
+
+#include <assert.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/select.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <dirent.h>
+
+#if HAVE_ARPA_NAMESER_COMPAT_H
+#include <arpa/nameser_compat.h>
+#endif
+
+#ifdef HAVE_SYS_PRCTL_H
+#include <sys/prctl.h>
+#endif
+
+#if HAVE_PTHREAD
+#include <pthread.h>
+#endif
+
+#include "asyncns.h"
+
+#ifndef MSG_NOSIGNAL
+#define MSG_NOSIGNAL 0
+#endif
+
+#define MAX_WORKERS 16
+#define MAX_QUERIES 256
+#define BUFSIZE (10240)
+
+typedef enum {
+    REQUEST_ADDRINFO,
+    RESPONSE_ADDRINFO,
+    REQUEST_NAMEINFO,
+    RESPONSE_NAMEINFO,
+    REQUEST_RES_QUERY,
+    REQUEST_RES_SEARCH,
+    RESPONSE_RES,
+    REQUEST_TERMINATE,
+    RESPONSE_DIED
+} query_type_t;
+
+enum {
+    REQUEST_RECV_FD = 0,
+    REQUEST_SEND_FD = 1,
+    RESPONSE_RECV_FD = 2,
+    RESPONSE_SEND_FD = 3,
+    MESSAGE_FD_MAX = 4
+};
+
+struct asyncns {
+    int fds[4];
+
+#ifndef HAVE_PTHREAD
+    pid_t workers[MAX_WORKERS];
+#else
+    pthread_t workers[MAX_WORKERS];
+#endif
+    unsigned valid_workers;
+
+    unsigned current_id, current_index;
+    _g_asyncns_query_t* queries[MAX_QUERIES];
+
+    _g_asyncns_query_t *done_head, *done_tail;
+
+    int n_queries;
+    int dead;
+};
+
+struct _g_asyncns_query {
+    _g_asyncns_t *asyncns;
+    int done;
+    unsigned id;
+    query_type_t type;
+    _g_asyncns_query_t *done_next, *done_prev;
+    int ret;
+    int _errno;
+    int _h_errno;
+    struct addrinfo *addrinfo;
+    char *serv, *host;
+    void *userdata;
+};
+
+typedef struct rheader {
+    query_type_t type;
+    unsigned id;
+    size_t length;
+} rheader_t;
+
+typedef struct addrinfo_request {
+    struct rheader header;
+    int hints_is_null;
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t node_len, service_len;
+} addrinfo_request_t;
+
+typedef struct addrinfo_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+    /* followed by addrinfo_serialization[] */
+} addrinfo_response_t;
+
+typedef struct addrinfo_serialization {
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t ai_addrlen;
+    size_t canonname_len;
+    /* Followed by ai_addr amd ai_canonname with variable lengths */
+} addrinfo_serialization_t;
+
+typedef struct nameinfo_request {
+    struct rheader header;
+    int flags;
+    socklen_t sockaddr_len;
+    int gethost, getserv;
+} nameinfo_request_t;
+
+typedef struct nameinfo_response {
+    struct rheader header;
+    size_t hostlen, servlen;
+    int ret;
+    int _errno;
+    int _h_errno;
+} nameinfo_response_t;
+
+typedef struct res_query_request {
+    struct rheader header;
+    int class;
+    int type;
+    size_t dname_len;
+} res_request_t;
+
+typedef struct res_query_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+} res_response_t;
+
+#ifndef HAVE_STRNDUP
+
+static char *strndup(const char *s, size_t l) {
+    size_t a;
+    char *n;
+
+    a = strlen(s);
+    if (a > l)
+        a = l;
+
+    if (!(n = malloc(a+1)))
+        return NULL;
+
+    memcpy(n, s, a);
+    n[a] = 0;
+
+    return n;
+}
+
+#endif
+
+#ifndef HAVE_PTHREAD
+
+static int close_allv(const int except_fds[]) {
+    struct rlimit rl;
+    int fd;
+
+#ifdef __linux__
+
+    DIR *d;
+
+    assert(except_fds);
+
+    if ((d = opendir("/proc/self/fd"))) {
+
+        struct dirent *de;
+
+        while ((de = readdir(d))) {
+            int found;
+            long l;
+            char *e = NULL;
+            int i;
+
+            if (de->d_name[0] == '.')
+                continue;
+
+            errno = 0;
+            l = strtol(de->d_name, &e, 10);
+            if (errno != 0 || !e || *e) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            fd = (int) l;
+
+            if ((long) fd != l) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            if (fd < 3)
+                continue;
+
+            if (fd == dirfd(d))
+                continue;
+
+            found = 0;
+            for (i = 0; except_fds[i] >= 0; i++)
+                if (except_fds[i] == fd) {
+                    found = 1;
+                    break;
+                }
+
+            if (found)
+                continue;
+
+            if (close(fd) < 0) {
+                int saved_errno;
+
+                saved_errno = errno;
+                closedir(d);
+                errno = saved_errno;
+
+                return -1;
+            }
+        }
+
+        closedir(d);
+        return 0;
+    }
+
+#endif
+
+    if (getrlimit(RLIMIT_NOFILE, &rl) < 0)
+        return -1;
+
+    for (fd = 0; fd < (int) rl.rlim_max; fd++) {
+        int i;
+
+        if (fd <= 3)
+            continue;
+
+        for (i = 0; except_fds[i] >= 0; i++)
+            if (except_fds[i] == fd)
+                continue;
+
+        if (close(fd) < 0 && errno != EBADF)
+            return -1;
+    }
+
+    return 0;
+}
+
+static int reset_sigsv(const int except[]) {
+    int sig;
+    assert(except);
+
+    for (sig = 1; sig < NSIG; sig++) {
+        int reset = 1;
+
+        switch (sig) {
+            case SIGKILL:
+            case SIGSTOP:
+                reset = 0;
+                break;
+
+            default: {
+                int i;
+
+                for (i = 0; except[i] > 0; i++) {
+                    if (sig == except[i]) {
+                        reset = 0;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (reset) {
+            struct sigaction sa;
+
+            memset(&sa, 0, sizeof(sa));
+            sa.sa_handler = SIG_DFL;
+
+            /* On Linux the first two RT signals are reserved by
+             * glibc, and sigaction() will return EINVAL for them. */
+            if ((sigaction(sig, &sa, NULL) < 0))
+                if (errno != EINVAL)
+                    return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int ignore_sigsv(const int ignore[]) {
+    int i;
+    assert(ignore);
+
+    for (i = 0; ignore[i] > 0; i++) {
+        struct sigaction sa;
+
+        memset(&sa, 0, sizeof(sa));
+        sa.sa_handler = SIG_IGN;
+
+        if ((sigaction(ignore[i], &sa, NULL) < 0))
+            return -1;
+    }
+
+    return 0;
+}
+
+#endif
+
+static int fd_nonblock(int fd) {
+    int i;
+    assert(fd >= 0);
+
+    if ((i = fcntl(fd, F_GETFL, 0)) < 0)
+        return -1;
+
+    if (i & O_NONBLOCK)
+        return 0;
+
+    return fcntl(fd, F_SETFL, i | O_NONBLOCK);
+}
+
+static int fd_cloexec(int fd) {
+    int v;
+    assert(fd >= 0);
+
+    if ((v = fcntl(fd, F_GETFD, 0)) < 0)
+        return -1;
+
+    if (v & FD_CLOEXEC)
+        return 0;
+
+    return fcntl(fd, F_SETFD, v | FD_CLOEXEC);
+}
+
+static int send_died(int out_fd) {
+    rheader_t rh;
+    assert(out_fd > 0);
+
+    memset(&rh, 0, sizeof(rh));
+    rh.type = RESPONSE_DIED;
+    rh.id = 0;
+    rh.length = sizeof(rh);
+
+    return send(out_fd, &rh, rh.length, MSG_NOSIGNAL);
+}
+
+static void *serialize_addrinfo(void *p, const struct addrinfo *ai, size_t *length, size_t maxlength) {
+    addrinfo_serialization_t s;
+    size_t cnl, l;
+    assert(p);
+    assert(ai);
+    assert(length);
+    assert(*length <= maxlength);
+
+    cnl = (ai->ai_canonname ? strlen(ai->ai_canonname)+1 : 0);
+    l = sizeof(addrinfo_serialization_t) + ai->ai_addrlen + cnl;
+
+    if (*length + l > maxlength)
+        return NULL;
+
+    s.ai_flags = ai->ai_flags;
+    s.ai_family = ai->ai_family;
+    s.ai_socktype = ai->ai_socktype;
+    s.ai_protocol = ai->ai_protocol;
+    s.ai_addrlen = ai->ai_addrlen;
+    s.canonname_len = cnl;
+
+    memcpy((uint8_t*) p, &s, sizeof(addrinfo_serialization_t));
+    memcpy((uint8_t*) p + sizeof(addrinfo_serialization_t), ai->ai_addr, ai->ai_addrlen);
+
+    if (ai->ai_canonname)
+        strcpy((char*) p + sizeof(addrinfo_serialization_t) + ai->ai_addrlen, ai->ai_canonname);
+
+    *length += l;
+    return (uint8_t*) p + l;
+}
+
+static int send_addrinfo_reply(int out_fd, unsigned id, int ret, struct addrinfo *ai, int _errno, int _h_errno) {
+    addrinfo_response_t data[BUFSIZE/sizeof(addrinfo_response_t) + 1];
+    addrinfo_response_t *resp = data;
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_ADDRINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(addrinfo_response_t);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    if (ret == 0 && ai) {
+        void *p = data + 1;
+        struct addrinfo *k;
+
+        for (k = ai; k; k = k->ai_next) {
+
+            if (!(p = serialize_addrinfo(p, k, &resp->header.length, (char*) data + BUFSIZE - (char*) p))) {
+                resp->ret = EAI_MEMORY;
+                break;
+            }
+        }
+    }
+
+    if (ai)
+        freeaddrinfo(ai);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_nameinfo_reply(int out_fd, unsigned id, int ret, const char *host, const char *serv, int _errno, int _h_errno) {
+    nameinfo_response_t data[BUFSIZE/sizeof(nameinfo_response_t) + 1];
+    size_t hl, sl;
+    nameinfo_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    sl = serv ? strlen(serv)+1 : 0;
+    hl = host ? strlen(host)+1 : 0;
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_NAMEINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(nameinfo_response_t) + hl + sl;
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+    resp->hostlen = hl;
+    resp->servlen = sl;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (host)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t), host, hl);
+
+    if (serv)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t) + hl, serv, sl);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_res_reply(int out_fd, unsigned id, const unsigned char *answer, int ret, int _errno, int _h_errno) {
+    res_response_t data[BUFSIZE/sizeof(res_response_t) + 1];
+    res_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_RES;
+    resp->header.id = id;
+    resp->header.length = sizeof(res_response_t) + (ret < 0 ? 0 : ret);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (ret > 0)
+        memcpy((uint8_t *)data + sizeof(res_response_t), answer, ret);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int handle_request(int out_fd, const rheader_t *req, size_t length) {
+    assert(out_fd >= 0);
+    assert(req);
+    assert(length >= sizeof(rheader_t));
+    assert(length == req->length);
+
+    switch (req->type) {
+        case REQUEST_ADDRINFO: {
+            struct addrinfo ai, *result = NULL;
+            const addrinfo_request_t *ai_req = (const addrinfo_request_t*) req;
+            const char *node, *service;
+            int ret;
+
+            assert(length >= sizeof(addrinfo_request_t));
+            assert(length == sizeof(addrinfo_request_t) + ai_req->node_len + ai_req->service_len);
+
+            memset(&ai, 0, sizeof(ai));
+            ai.ai_flags = ai_req->ai_flags;
+            ai.ai_family = ai_req->ai_family;
+            ai.ai_socktype = ai_req->ai_socktype;
+            ai.ai_protocol = ai_req->ai_protocol;
+
+            node = ai_req->node_len ? (const char*) req + sizeof(addrinfo_request_t) : NULL;
+            service = ai_req->service_len ? (const char*) req + sizeof(addrinfo_request_t) + ai_req->node_len : NULL;
+
+            ret = getaddrinfo(node, service,
+                              ai_req->hints_is_null ? NULL : &ai,
+                              &result);
+
+            /* send_addrinfo_reply() frees result */
+            return send_addrinfo_reply(out_fd, req->id, ret, result, errno, h_errno);
+        }
+
+        case REQUEST_NAMEINFO: {
+            int ret;
+            const nameinfo_request_t *ni_req = (const nameinfo_request_t*) req;
+            char hostbuf[NI_MAXHOST], servbuf[NI_MAXSERV];
+            struct sockaddr_storage sa;
+
+            assert(length >= sizeof(nameinfo_request_t));
+            assert(length == sizeof(nameinfo_request_t) + ni_req->sockaddr_len);
+
+            memcpy(&sa, (const uint8_t *)req + sizeof(nameinfo_request_t), ni_req->sockaddr_len);
+
+            ret = getnameinfo((struct sockaddr *)&sa, ni_req->sockaddr_len,
+                              ni_req->gethost ? hostbuf : NULL, ni_req->gethost ? sizeof(hostbuf) : 0,
+                              ni_req->getserv ? servbuf : NULL, ni_req->getserv ? sizeof(servbuf) : 0,
+                              ni_req->flags);
+
+            return send_nameinfo_reply(out_fd, req->id, ret,
+                                       ret == 0 && ni_req->gethost ? hostbuf : NULL,
+                                       ret == 0 && ni_req->getserv ? servbuf : NULL,
+                                       errno, h_errno);
+        }
+
+        case REQUEST_RES_QUERY:
+        case REQUEST_RES_SEARCH: {
+            int ret;
+            HEADER answer[BUFSIZE/sizeof(HEADER) + 1];
+            const res_request_t *res_req = (const res_request_t *)req;
+            const char *dname;
+
+            assert(length >= sizeof(res_request_t));
+            assert(length == sizeof(res_request_t) + res_req->dname_len);
+
+            dname = (const char *) req + sizeof(res_request_t);
+
+            if (req->type == REQUEST_RES_QUERY)
+                ret = res_query(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+            else
+                ret = res_search(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+
+            return send_res_reply(out_fd, req->id, (unsigned char *) answer, ret, errno, h_errno);
+        }
+
+        case REQUEST_TERMINATE:
+            /* Quit */
+            return -1;
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+#ifndef HAVE_PTHREAD
+
+static int process_worker(int in_fd, int out_fd) {
+    int have_death_sig = 0;
+    int good_fds[3];
+    int ret = 1;
+
+    const int ignore_sigs[] = {
+        SIGINT,
+        SIGHUP,
+        SIGPIPE,
+        SIGUSR1,
+        SIGUSR2,
+        -1
+    };
+
+    assert(in_fd > 2);
+    assert(out_fd > 2);
+
+    close(0);
+    close(1);
+    close(2);
+
+    if (open("/dev/null", O_RDONLY) != 0)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 1)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 2)
+        goto fail;
+
+    if (chdir("/") < 0)
+        goto fail;
+
+    if (geteuid() == 0) {
+        struct passwd *pw;
+        int r;
+
+        if ((pw = getpwnam("nobody"))) {
+#ifdef HAVE_SETRESUID
+            r = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
+#elif HAVE_SETREUID
+            r = setreuid(pw->pw_uid, pw->pw_uid);
+#else
+            if ((r = setuid(pw->pw_uid)) >= 0)
+                r = seteuid(pw->pw_uid);
+#endif
+            if (r < 0)
+                goto fail;
+        }
+    }
+
+    if (reset_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    if (ignore_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    good_fds[0] = in_fd; good_fds[1] = out_fd; good_fds[2] = -1;
+    if (close_allv(good_fds) < 0)
+        goto fail;
+
+#ifdef PR_SET_PDEATHSIG
+    if (prctl(PR_SET_PDEATHSIG, SIGTERM) >= 0)
+        have_death_sig = 1;
+#endif
+
+    if (!have_death_sig)
+        fd_nonblock(in_fd);
+
+    while (getppid() > 1) { /* if the parent PID is 1 our parent process died. */
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if (!have_death_sig) {
+            fd_set fds;
+            struct timeval tv = { 0, 500000 };
+
+            FD_ZERO(&fds);
+            FD_SET(in_fd, &fds);
+
+            if (select(in_fd+1, &fds, NULL, NULL, &tv) < 0)
+                break;
+
+            if (getppid() == 1)
+                break;
+        }
+
+        if ((length = recv(in_fd, buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (handle_request(out_fd, buf, (size_t) length) < 0)
+            break;
+    }
+
+    ret = 0;
+
+fail:
+    send_died(out_fd);
+
+    return ret;
+}
+
+#else
+
+static void* thread_worker(void *p) {
+    _g_asyncns_t *asyncns = p;
+    sigset_t fullset;
+
+    /* No signals in this thread please */
+    sigfillset(&fullset);
+    pthread_sigmask(SIG_BLOCK, &fullset, NULL);
+
+    while (!asyncns->dead) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if ((length = recv(asyncns->fds[REQUEST_RECV_FD], buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (asyncns->dead)
+            break;
+
+        if (handle_request(asyncns->fds[RESPONSE_SEND_FD], buf, (size_t) length) < 0)
+            break;
+    }
+
+    send_died(asyncns->fds[RESPONSE_SEND_FD]);
+
+    return NULL;
+}
+
+#endif
+
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc) {
+    _g_asyncns_t *asyncns = NULL;
+    int i;
+    assert(n_proc >= 1);
+
+    if (n_proc > MAX_WORKERS)
+        n_proc = MAX_WORKERS;
+
+    if (!(asyncns = malloc(sizeof(_g_asyncns_t)))) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    asyncns->dead = 0;
+    asyncns->valid_workers = 0;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        asyncns->fds[i] = -1;
+
+    memset(asyncns->queries, 0, sizeof(asyncns->queries));
+
+    if (socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds) < 0 ||
+        socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds+2) < 0)
+        goto fail;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        fd_cloexec(asyncns->fds[i]);
+
+    for (asyncns->valid_workers = 0; asyncns->valid_workers < n_proc; asyncns->valid_workers++) {
+
+#ifndef HAVE_PTHREAD
+        if ((asyncns->workers[asyncns->valid_workers] = fork()) < 0)
+            goto fail;
+        else if (asyncns->workers[asyncns->valid_workers] == 0) {
+            int ret;
+
+            close(asyncns->fds[REQUEST_SEND_FD]);
+            close(asyncns->fds[RESPONSE_RECV_FD]);
+            ret = process_worker(asyncns->fds[REQUEST_RECV_FD], asyncns->fds[RESPONSE_SEND_FD]);
+            close(asyncns->fds[REQUEST_RECV_FD]);
+            close(asyncns->fds[RESPONSE_SEND_FD]);
+            _exit(ret);
+        }
+#else
+        int r;
+
+        if ((r = pthread_create(&asyncns->workers[asyncns->valid_workers], NULL, thread_worker, asyncns)) != 0) {
+            errno = r;
+            goto fail;
+        }
+#endif
+    }
+
+#ifndef HAVE_PTHREAD
+    close(asyncns->fds[REQUEST_RECV_FD]);
+    close(asyncns->fds[RESPONSE_SEND_FD]);
+    asyncns->fds[REQUEST_RECV_FD] = asyncns->fds[RESPONSE_SEND_FD] = -1;
+#endif
+
+    asyncns->current_index = asyncns->current_id = 0;
+    asyncns->done_head = asyncns->done_tail = NULL;
+    asyncns->n_queries = 0;
+
+    fd_nonblock(asyncns->fds[RESPONSE_RECV_FD]);
+
+    return asyncns;
+
+fail:
+    if (asyncns)
+        _g_asyncns_free(asyncns);
+
+    return NULL;
+}
+
+void _g_asyncns_free(_g_asyncns_t *asyncns) {
+    int i;
+    int saved_errno = errno;
+    unsigned p;
+
+    assert(asyncns);
+
+    asyncns->dead = 1;
+
+    if (asyncns->fds[REQUEST_SEND_FD] >= 0) {
+        rheader_t req;
+
+        memset(&req, 0, sizeof(req));
+        req.type = REQUEST_TERMINATE;
+        req.length = sizeof(req);
+        req.id = 0;
+
+        /* Send one termination packet for each worker */
+        for (p = 0; p < asyncns->valid_workers; p++)
+            send(asyncns->fds[REQUEST_SEND_FD], &req, req.length, MSG_NOSIGNAL);
+    }
+
+    /* Now terminate them and wait until they are gone. */
+    for (p = 0; p < asyncns->valid_workers; p++) {
+#ifndef HAVE_PTHREAD
+        kill(asyncns->workers[p], SIGTERM);
+        for (;;) {
+            if (waitpid(asyncns->workers[p], NULL, 0) >= 0 || errno != EINTR)
+                break;
+        }
+#else
+        for (;;) {
+            if (pthread_join(asyncns->workers[p], NULL) != EINTR)
+                break;
+        }
+#endif
+    }
+
+    /* Close all communication channels */
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        if (asyncns->fds[i] >= 0)
+            close(asyncns->fds[i]);
+
+    for (p = 0; p < MAX_QUERIES; p++)
+        if (asyncns->queries[p])
+            _g_asyncns_cancel(asyncns, asyncns->queries[p]);
+
+    free(asyncns);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_fd(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+
+    return asyncns->fds[RESPONSE_RECV_FD];
+}
+
+static _g_asyncns_query_t *lookup_query(_g_asyncns_t *asyncns, unsigned id) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if ((q = asyncns->queries[id % MAX_QUERIES]))
+        if (q->id == id)
+            return q;
+
+    return NULL;
+}
+
+static void complete_query(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(asyncns);
+    assert(q);
+    assert(!q->done);
+
+    q->done = 1;
+
+    if ((q->done_prev = asyncns->done_tail))
+        asyncns->done_tail->done_next = q;
+    else
+        asyncns->done_head = q;
+
+    asyncns->done_tail = q;
+    q->done_next = NULL;
+}
+
+static void *unserialize_addrinfo(void *p, struct addrinfo **ret_ai, size_t *length) {
+    addrinfo_serialization_t s;
+    size_t l;
+    struct addrinfo *ai;
+    assert(p);
+    assert(ret_ai);
+    assert(length);
+
+    if (*length < sizeof(addrinfo_serialization_t))
+        return NULL;
+
+    memcpy(&s, p, sizeof(s));
+
+    l = sizeof(addrinfo_serialization_t) + s.ai_addrlen + s.canonname_len;
+    if (*length < l)
+        return NULL;
+
+    if (!(ai = malloc(sizeof(struct addrinfo))))
+        goto fail;
+
+    ai->ai_addr = NULL;
+    ai->ai_canonname = NULL;
+    ai->ai_next = NULL;
+
+    if (s.ai_addrlen && !(ai->ai_addr = malloc(s.ai_addrlen)))
+        goto fail;
+
+    if (s.canonname_len && !(ai->ai_canonname = malloc(s.canonname_len)))
+        goto fail;
+
+    ai->ai_flags = s.ai_flags;
+    ai->ai_family = s.ai_family;
+    ai->ai_socktype = s.ai_socktype;
+    ai->ai_protocol = s.ai_protocol;
+    ai->ai_addrlen = s.ai_addrlen;
+
+    if (ai->ai_addr)
+        memcpy(ai->ai_addr, (uint8_t*) p + sizeof(addrinfo_serialization_t), s.ai_addrlen);
+
+    if (ai->ai_canonname)
+        memcpy(ai->ai_canonname, (uint8_t*) p + sizeof(addrinfo_serialization_t) + s.ai_addrlen, s.canonname_len);
+
+    *length -= l;
+    *ret_ai = ai;
+
+    return (uint8_t*) p + l;
+
+
+fail:
+    if (ai)
+        _g_asyncns_freeaddrinfo(ai);
+
+    return NULL;
+}
+
+static int handle_response(_g_asyncns_t *asyncns, rheader_t *resp, size_t length) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(resp);
+    assert(length >= sizeof(rheader_t));
+    assert(length == resp->length);
+
+    if (resp->type == RESPONSE_DIED) {
+        asyncns->dead = 1;
+        return 0;
+    }
+
+    if (!(q = lookup_query(asyncns, resp->id)))
+        return 0;
+
+    switch (resp->type) {
+        case RESPONSE_ADDRINFO: {
+            const addrinfo_response_t *ai_resp = (addrinfo_response_t*) resp;
+            void *p;
+            size_t l;
+            struct addrinfo *prev = NULL;
+
+            assert(length >= sizeof(addrinfo_response_t));
+            assert(q->type == REQUEST_ADDRINFO);
+
+            q->ret = ai_resp->ret;
+            q->_errno = ai_resp->_errno;
+            q->_h_errno = ai_resp->_h_errno;
+            l = length - sizeof(addrinfo_response_t);
+            p = (uint8_t*) resp + sizeof(addrinfo_response_t);
+
+            while (l > 0 && p) {
+                struct addrinfo *ai = NULL;
+                p = unserialize_addrinfo(p, &ai, &l);
+
+                if (!p || !ai) {
+                    q->ret = EAI_MEMORY;
+                    break;
+                }
+
+                if (prev)
+                    prev->ai_next = ai;
+                else
+                    q->addrinfo = ai;
+
+                prev = ai;
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_NAMEINFO: {
+            const nameinfo_response_t *ni_resp = (nameinfo_response_t*) resp;
+
+            assert(length >= sizeof(nameinfo_response_t));
+            assert(q->type == REQUEST_NAMEINFO);
+
+            q->ret = ni_resp->ret;
+            q->_errno = ni_resp->_errno;
+            q->_h_errno = ni_resp->_h_errno;
+
+            if (ni_resp->hostlen)
+                if (!(q->host = strndup((const char*) ni_resp + sizeof(nameinfo_response_t), ni_resp->hostlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            if (ni_resp->servlen)
+                if (!(q->serv = strndup((const char*) ni_resp + sizeof(nameinfo_response_t) + ni_resp->hostlen, ni_resp->servlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_RES: {
+            const res_response_t *res_resp = (res_response_t *)resp;
+
+            assert(length >= sizeof(res_response_t));
+            assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+
+            q->ret = res_resp->ret;
+            q->_errno = res_resp->_errno;
+            q->_h_errno = res_resp->_h_errno;
+
+            if (res_resp->ret >= 0)  {
+                if (!(q->serv = malloc(res_resp->ret))) {
+                    q->ret = -1;
+                    q->_errno = ENOMEM;
+                } else
+                    memcpy(q->serv, (char *)resp + sizeof(res_response_t), res_resp->ret);
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block) {
+    int handled = 0;
+    assert(asyncns);
+
+    for (;;) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t l;
+
+        if (asyncns->dead) {
+            errno = ECHILD;
+            return -1;
+        }
+
+        if (((l = recv(asyncns->fds[RESPONSE_RECV_FD], buf, sizeof(buf), 0)) < 0)) {
+            fd_set fds;
+
+            if (errno != EAGAIN)
+                return -1;
+
+            if (!block || handled)
+                return 0;
+
+            FD_ZERO(&fds);
+            FD_SET(asyncns->fds[RESPONSE_RECV_FD], &fds);
+
+            if (select(asyncns->fds[RESPONSE_RECV_FD]+1, &fds, NULL, NULL, NULL) < 0)
+                return -1;
+
+            continue;
+        }
+
+        if (handle_response(asyncns, buf, (size_t) l) < 0)
+            return -1;
+
+        handled = 1;
+    }
+}
+
+static _g_asyncns_query_t *alloc_query(_g_asyncns_t *asyncns) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if (asyncns->n_queries >= MAX_QUERIES) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    while (asyncns->queries[asyncns->current_index]) {
+
+        asyncns->current_index++;
+        asyncns->current_id++;
+
+        while (asyncns->current_index >= MAX_QUERIES)
+            asyncns->current_index -= MAX_QUERIES;
+    }
+
+    if (!(q = asyncns->queries[asyncns->current_index] = malloc(sizeof(_g_asyncns_query_t)))) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    asyncns->n_queries++;
+
+    q->asyncns = asyncns;
+    q->done = 0;
+    q->id = asyncns->current_id;
+    q->done_next = q->done_prev = NULL;
+    q->ret = 0;
+    q->_errno = 0;
+    q->_h_errno = 0;
+    q->addrinfo = NULL;
+    q->userdata = NULL;
+    q->host = q->serv = NULL;
+
+    return q;
+}
+
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints) {
+    addrinfo_request_t data[BUFSIZE/sizeof(addrinfo_request_t) + 1];
+    addrinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(node || service);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(addrinfo_request_t));
+
+    req->node_len = node ? strlen(node)+1 : 0;
+    req->service_len = service ? strlen(service)+1 : 0;
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_ADDRINFO;
+    req->header.length = sizeof(addrinfo_request_t) + req->node_len + req->service_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    if (!(req->hints_is_null = !hints)) {
+        req->ai_flags = hints->ai_flags;
+        req->ai_family = hints->ai_family;
+        req->ai_socktype = hints->ai_socktype;
+        req->ai_protocol = hints->ai_protocol;
+    }
+
+    if (node)
+        strcpy((char*) req + sizeof(addrinfo_request_t), node);
+
+    if (service)
+        strcpy((char*) req + sizeof(addrinfo_request_t) + req->node_len, service);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_ADDRINFO);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    *ret_res = q->addrinfo;
+    q->addrinfo = NULL;
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv) {
+    nameinfo_request_t data[BUFSIZE/sizeof(nameinfo_request_t) + 1];
+    nameinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(sa);
+    assert(salen > 0);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(nameinfo_request_t));
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_NAMEINFO;
+    req->header.length = sizeof(nameinfo_request_t) + salen;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->flags = flags;
+    req->sockaddr_len = salen;
+    req->gethost = gethost;
+    req->getserv = getserv;
+
+    memcpy((uint8_t*) req + sizeof(nameinfo_request_t), sa, salen);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_NAMEINFO);
+    assert(!ret_host || hostlen);
+    assert(!ret_serv || servlen);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    if (ret_host && q->host) {
+        strncpy(ret_host, q->host, hostlen);
+        ret_host[hostlen-1] = 0;
+    }
+
+    if (ret_serv && q->serv) {
+        strncpy(ret_serv, q->serv, servlen);
+        ret_serv[servlen-1] = 0;
+    }
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+static _g_asyncns_query_t * _g_asyncns_res(_g_asyncns_t *asyncns, query_type_t qtype, const char *dname, int class, int type) {
+    res_request_t data[BUFSIZE/sizeof(res_request_t) + 1];
+    res_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(dname);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(res_request_t));
+
+    req->dname_len = strlen(dname) + 1;
+
+    req->header.id = q->id;
+    req->header.type = q->type = qtype;
+    req->header.length = sizeof(res_request_t) + req->dname_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->class = class;
+    req->type = type;
+
+    strcpy((char*) req + sizeof(res_request_t), dname);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_QUERY, dname, class, type);
+}
+
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_SEARCH, dname, class, type);
+}
+
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+    assert(answer);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return -ECHILD;
+    }
+
+    if (!q->done) {
+        errno = EAGAIN;
+        return -EAGAIN;
+    }
+
+    *answer = (unsigned char *)q->serv;
+    q->serv = NULL;
+
+    ret = q->ret;
+
+    if (ret < 0) {
+        errno = q->_errno;
+        h_errno = q->_h_errno;
+    }
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret < 0 ? -errno : ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->done_head;
+}
+
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->n_queries;
+}
+
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q) {
+    int i;
+    int saved_errno = errno;
+
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(asyncns->n_queries > 0);
+
+    if (q->done) {
+
+        if (q->done_prev)
+            q->done_prev->done_next = q->done_next;
+        else
+            asyncns->done_head = q->done_next;
+
+        if (q->done_next)
+            q->done_next->done_prev = q->done_prev;
+        else
+            asyncns->done_tail = q->done_prev;
+    }
+
+    i = q->id % MAX_QUERIES;
+    assert(asyncns->queries[i] == q);
+    asyncns->queries[i] = NULL;
+
+    _g_asyncns_freeaddrinfo(q->addrinfo);
+    free(q->host);
+    free(q->serv);
+
+    asyncns->n_queries--;
+    free(q);
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai) {
+    int saved_errno = errno;
+
+    while (ai) {
+        struct addrinfo *next = ai->ai_next;
+
+        free(ai->ai_addr);
+        free(ai->ai_canonname);
+        free(ai);
+
+        ai = next;
+    }
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeanswer(unsigned char *answer) {
+    int saved_errno = errno;
+
+    if (!answer)
+        return;
+
+    /* Please note that this function is new in libasyncns 0.4. In
+     * older versions you were supposed to free the answer directly
+     * with free(). Hence, if this function is changed to do more than
+     * just a simple free() this must be considered ABI/API breakage! */
+
+    free(answer);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q) {
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+
+    return q->done;
+}
+
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    q->userdata = userdata;
+}
+
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    return q->userdata;
+}
diff --git a/gio/libasyncns/asyncns.h b/gio/libasyncns/asyncns.h
new file mode 100644
index 0000000..b3d49ff
--- /dev/null
+++ b/gio/libasyncns/asyncns.h
@@ -0,0 +1,163 @@
+#ifndef fooasyncnshfoo
+#define fooasyncnshfoo
+
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+/** \mainpage
+ *
+ * \section moo Method of operation
+ *
+ * To use libasyncns allocate an _g_asyncns_t object with
+ * _g_asyncns_new(). This will spawn a number of worker threads (or processes, depending on what is available) which
+ * are subsequently used to process the queries the controlling
+ * program issues via _g_asyncns_getaddrinfo() and
+ * _g_asyncns_getnameinfo(). Use _g_asyncns_free() to shut down the worker
+ * threads/processes.
+ *
+ * Since libasyncns may fork off new processes you have to make sure that
+ * your program is not irritated by spurious SIGCHLD signals.
+ */
+
+/** \example asyncns-test.c
+ * An example program */
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/** An opaque libasyncns session structure */
+typedef struct asyncns _g_asyncns_t;
+
+/** An opaque libasyncns query structure */
+typedef struct _g_asyncns_query _g_asyncns_query_t;
+
+/** Allocate a new libasyncns session with n_proc worker processes/threads */
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc);
+
+/** Free a libasyncns session. This destroys all attached
+ * _g_asyncns_query_t objects automatically */
+void _g_asyncns_free(_g_asyncns_t *asyncns);
+
+/** Return the UNIX file descriptor to select() for readability
+ * on. Use this function to integrate libasyncns with your custom main
+ * loop. */
+int _g_asyncns_fd(_g_asyncns_t *asyncns);
+
+/** Process pending responses. After this function is called you can
+ * get the next completed query object(s) using _g_asyncns_getnext(). If
+ * block is non-zero wait until at least one response has been
+ * processed. If block is zero, process all pending responses and
+ * return. */
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block);
+
+/** Issue a name to address query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getaddrinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getaddrinfo_done().*/
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints);
+
+/** Retrieve the results of a preceding _g_asyncns_getaddrinfo()
+ * call. Returns a addrinfo structure and a return value compatible
+ * with libc's getaddrinfo(3). The query object q is destroyed by this
+ * call and may not be used any further. Make sure to free the
+ * returned addrinfo structure with _g_asyncns_freeaddrinfo() and not
+ * libc's freeaddrinfo(3)! If the query is not completed yet EAI_AGAIN
+ * is returned.*/
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res);
+
+/** Issue an address to name query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getnameinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getnameinfo_done(). Set gethost (resp. getserv) to non-zero
+ * if you want to query the hostname (resp. the service name). */
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv);
+
+/** Retrieve the results of a preceding _g_asyncns_getnameinfo()
+ * call. Returns the hostname and the service name in ret_host and
+ * ret_serv. The query object q is destroyed by this call and may not
+ * be used any further. If the query is not completed yet EAI_AGAIN is
+ * returned. */
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen);
+
+/** Issue a resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_query(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Issue an resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_search(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Retrieve the results of a preceding _g_asyncns_res_query() or
+ * _g_asyncns_res_search call.  The query object q is destroyed by this
+ * call and may not be used any further. Returns a pointer to the
+ * answer of the res_query call. If the query is not completed yet
+ * -EAGAIN is returned, on failure -errno is returned, otherwise the
+ * length of answer is returned. Make sure to free the answer is a
+ * call to _g_asyncns_freeanswer(). */
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer);
+
+/** Return the next completed query object. If no query has been
+ * completed yet, return NULL. Please note that you need to run
+ * _g_asyncns_wait() before this function will return sensible data.  */
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns);
+
+/** Return the number of query objects (completed or not) attached to
+ * this session */
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns);
+
+/** Cancel a currently running query. q is is destroyed by this call
+ * and may not be used any futher. */
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q);
+
+/** Free the addrinfo structure as returned by
+ * _g_asyncns_getaddrinfo_done(). Make sure to use this functions instead
+ * of the libc's freeaddrinfo()! */
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai);
+
+/** Free the answer data as returned by _g_asyncns_res_done().*/
+void _g_asyncns_freeanswer(unsigned char *answer);
+
+/** Returns non-zero when the query operation specified by q has been completed */
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q);
+
+/** Assign some opaque userdata with a query object */
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata);
+
+/** Return userdata assigned to a query object. Use
+ * _g_asyncns_setuserdata() to set this data. If no data has been set
+ * prior to this call it returns NULL. */
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gio/libasyncns/g-asyncns.h b/gio/libasyncns/g-asyncns.h
new file mode 100644
index 0000000..a40fadb
--- /dev/null
+++ b/gio/libasyncns/g-asyncns.h
@@ -0,0 +1,28 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_ASYNCNS_H__
+
+#include "config.h"
+
+#define _GNU_SOURCE
+#undef HAVE_PTHREAD
+
+#include "asyncns.h"
+
+#endif
diff --git a/gio/libasyncns/update.sh b/gio/libasyncns/update.sh
new file mode 100644
index 0000000..4c43ca5
--- /dev/null
+++ b/gio/libasyncns/update.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+if test $# = 1 ; then 
+  ORIGINAL=$1
+else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+if test -f $ORIGINAL/libasyncns/asyncns.c ; then : ; else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+for i in asyncns.c asyncns.h ; do
+  sed -e 's/\([^a-z]\)asyncns_/\1_g_asyncns_/g' \
+      -e 's/^asyncns_/_g_asyncns_/' \
+      -e 's/<config\.h>/"g-asyncns\.h"/' \
+    $ORIGINAL/libasyncns/$i > $i
+done
diff --git a/gio/pltcheck.sh b/gio/pltcheck.sh
index e09a587..be29be8 100755
--- a/gio/pltcheck.sh
+++ b/gio/pltcheck.sh
@@ -9,7 +9,7 @@ if ! which readelf 2>/dev/null >/dev/null; then
 	exit 0
 fi
 
-SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_build_filename\|\<g_byte_array\|\<g_child_watch\|\<g_convert\|\<g_dir_\|\<g_error_\|\<g_clear_error\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_\|\<g_enum_\|\<g_flags_\|\<g_checksum\|\<g_io_add_watch\|\<g_bit_\|\<g_poll\|\<g_boxed'
+SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_bit_\|\<g_boxed\|\<g_build_filename\|\<g_byte_array\|\<g_checksum\|\<g_child_watch\|\<g_clear_error\|\<g_convert\|\<g_dir_\|\<g_enum_\|\<g_error_\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_flags_\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_hostname_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_add_watch\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_poll\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_random_int_range\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_'
 
 for so in .libs/lib*.so; do
 	echo Checking $so for local PLT entries
diff --git a/gio/tests/.gitignore b/gio/tests/.gitignore
index 8985d06..da2fa91 100644
--- a/gio/tests/.gitignore
+++ b/gio/tests/.gitignore
@@ -11,3 +11,4 @@ live-g-file
 memory-input-stream
 memory-output-stream
 filter-streams
+connectable
diff --git a/gio/tests/Makefile.am b/gio/tests/Makefile.am
index 70a9ae8..eddaaa2 100644
--- a/gio/tests/Makefile.am
+++ b/gio/tests/Makefile.am
@@ -9,7 +9,7 @@ INCLUDES = 			\
 	-I$(top_srcdir)/gio 	\
 	$(GLIB_DEBUG_FLAGS)
 
-noinst_PROGRAMS = $(TEST_PROGS)
+noinst_PROGRAMS = $(TEST_PROGS) $(SAMPLE_PROGS)
 progs_ldadd     = 					\
 	$(top_builddir)/glib/libglib-2.0.la 		\
 	$(top_builddir)/gobject/libgobject-2.0.la	\
@@ -29,6 +29,8 @@ TEST_PROGS +=	 		\
 	filter-streams		\
 	simple-async-result
 
+SAMPLE_PROGS = resolver
+
 if OS_UNIX
 TEST_PROGS += live-g-file unix-streams desktop-app-info
 endif
@@ -76,4 +78,8 @@ sleepy_stream_LDADD		= $(progs_ldadd)
 filter_streams_SOURCES		= filter-streams.c
 filter_streams_LDADD		= $(progs_ldadd)
 
+resolver_SOURCES	  = resolver.c
+resolver_LDADD		  = $(progs_ldadd) \
+	$(top_builddir)/gthread/libgthread-2.0.la
+
 DISTCLEAN_FILES = applications/mimeinfo.cache
diff --git a/gio/tests/resolver.c b/gio/tests/resolver.c
new file mode 100644
index 0000000..4f0b71b
--- /dev/null
+++ b/gio/tests/resolver.c
@@ -0,0 +1,502 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <gio/gio.h>
+
+static GResolver *resolver;
+static GCancellable *cancellable;
+static GMainLoop *loop;
+static int nlookups = 0;
+
+static void
+usage (void)
+{
+	fprintf (stderr, "Usage: resolver [-t] [-s] [hostname | IP | service/protocol/domain ] ...\n");
+	fprintf (stderr, "       resolver [-t] [-s] -c [hostname | IP | service/protocol/domain ]\n");
+	fprintf (stderr, "       Use -t to enable threading.\n");
+	fprintf (stderr, "       Use -s to do synchronous lookups.\n");
+	fprintf (stderr, "       Both together will result in simultaneous lookups in multiple threads\n");
+	fprintf (stderr, "       Use -c (and only a single resolvable argument) to test GSocketConnectable.\n");
+	exit (1);
+}
+
+G_LOCK_DEFINE_STATIC (response);
+
+static void
+done_lookup (void)
+{
+  nlookups--;
+  if (nlookups == 0)
+    {
+      /* In the sync case we need to make sure we don't call
+       * g_main_loop_quit before the loop is actually running...
+       */
+      g_idle_add ((GSourceFunc)g_main_loop_quit, loop);
+    }
+}
+
+static void
+print_resolved_name (const char *phys,
+                     char       *name,
+                     GError     *error)
+{
+  G_LOCK (response);
+  printf ("Address: %s\n", phys);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      printf ("Name:    %s\n", name);
+      g_free (name);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_addresses (const char *name,
+                          GList      *addresses,
+			  GError     *error)
+{
+  char *phys;
+  GList *a;
+
+  G_LOCK (response);
+  printf ("Name:    %s\n", name);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (a = addresses; a; a = a->next)
+	{
+	  phys = g_inet_address_to_string (a->data);
+	  printf ("Address: %s\n", phys);
+	  g_free (phys);
+          g_object_unref (a->data);
+	}
+      g_list_free (addresses);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_service (const char *service,
+                        GList      *targets,
+			GError     *error)
+{
+  GList *t;  
+
+  G_LOCK (response);
+  printf ("Service: %s\n", service);
+  if (error)
+    {
+      printf ("Error: %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (t = targets; t; t = t->next)
+	{
+	  printf ("%s:%u (pri %u, weight %u)\n",
+		  g_srv_target_get_hostname (t->data),
+		  g_srv_target_get_port (t->data),
+		  g_srv_target_get_priority (t->data),
+		  g_srv_target_get_weight (t->data));
+          g_srv_target_free (t->data);
+	}
+      g_list_free (targets);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+lookup_one_sync (const char *arg)
+{
+  GError *error = NULL;
+
+  if (strchr (arg, '/'))
+    {
+      GList *targets;
+      /* service/protocol/domain */
+      char **parts = g_strsplit (arg, "/", 3);
+
+      if (!parts || !parts[2])
+	usage ();
+
+      targets = g_resolver_lookup_service (resolver,
+                                           parts[0], parts[1], parts[2],
+                                           cancellable, &error);
+      print_resolved_service (arg, targets, error);
+    }
+  else if (g_hostname_is_ip_address (arg))
+    {
+      GInetAddress *addr = g_inet_address_new_from_string (arg);
+      char *name;
+
+      name = g_resolver_lookup_by_address (resolver, addr, cancellable, &error);
+      print_resolved_name (arg, name, error);
+      g_object_unref (addr);
+    }
+  else
+    {
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver, arg, cancellable, &error);
+      print_resolved_addresses (arg, addresses, error);
+    }
+}
+
+static gpointer
+lookup_thread (gpointer arg)
+{
+  lookup_one_sync (arg);
+  return NULL;
+}
+
+static void
+start_threaded_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    g_thread_create (lookup_thread, argv[i], FALSE, NULL);
+}
+
+static void
+start_sync_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    lookup_one_sync (argv[i]);
+}
+
+static void
+lookup_by_addr_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *phys = user_data;
+  GError *error = NULL;
+  char *name;
+
+  name = g_resolver_lookup_by_address_finish (resolver, result, &error);
+  print_resolved_name (phys, name, error);
+}
+
+static void
+lookup_by_name_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *name = user_data;
+  GError *error = NULL;
+  GList *addresses;
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  print_resolved_addresses (name, addresses, error);
+}
+
+static void
+lookup_service_callback (GObject *source, GAsyncResult *result,
+			 gpointer user_data)
+{
+  const char *service = user_data;
+  GError *error = NULL;
+  GList *targets;
+
+  targets = g_resolver_lookup_service_finish (resolver, result, &error);
+  print_resolved_service (service, targets, error);
+}
+
+static void
+start_async_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    {
+      if (strchr (argv[i], '/'))
+	{
+	  /* service/protocol/domain */
+	  char **parts = g_strsplit (argv[i], "/", 3);
+
+	  if (!parts || !parts[2])
+	    usage ();
+
+	  g_resolver_lookup_service_async (resolver,
+					   parts[0], parts[1], parts[2],
+					   cancellable,
+					   lookup_service_callback, argv[i]);
+	}
+      else if (g_hostname_is_ip_address (argv[i]))
+	{
+          GInetAddress *addr = g_inet_address_new_from_string (argv[i]);
+
+	  g_resolver_lookup_by_address_async (resolver, addr, cancellable,
+                                              lookup_by_addr_callback, argv[i]);
+	  g_object_unref (addr);
+	}
+      else
+	{
+	  g_resolver_lookup_by_name_async (resolver, argv[i], cancellable,
+                                           lookup_by_name_callback,
+                                           argv[i]);
+	}
+    }
+}
+
+static void
+print_connectable_sockaddr (GSocketAddress *sockaddr,
+                            GError         *error)
+{
+  char *phys;
+
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else if (!G_IS_INET_SOCKET_ADDRESS (sockaddr))
+    {
+      printf ("Error:   Unexpected sockaddr type '%s'\n", g_type_name_from_instance ((GTypeInstance *)sockaddr));
+      g_object_unref (sockaddr);
+    }
+  else
+    {
+      GInetSocketAddress *isa = G_INET_SOCKET_ADDRESS (sockaddr);
+      phys = g_inet_address_to_string (g_inet_socket_address_get_address (isa));
+      printf ("Address: %s%s%s:%d\n",
+              strchr (phys, ':') ? "[" : "", phys, strchr (phys, ':') ? "]" : "",
+              g_inet_socket_address_get_port (isa));
+      g_free (phys);
+      g_object_unref (sockaddr);
+    }
+}
+
+static void
+do_sync_connectable (GSocketConnectable *connectable)
+{
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  while ((sockaddr = g_socket_connectable_get_next (connectable, cancellable, &error)))
+    print_connectable_sockaddr (sockaddr, error);
+
+  g_object_unref (connectable);
+  done_lookup ();
+}
+
+static void do_async_connectable (GSocketConnectable *connectable);
+
+static void
+got_next_async (GObject *source, GAsyncResult *result, gpointer user_data)
+{
+  GSocketConnectable *connectable = G_SOCKET_CONNECTABLE (source);
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  sockaddr = g_socket_connectable_get_next_finish (connectable, result, &error);
+  if (sockaddr || error)
+    print_connectable_sockaddr (sockaddr, error);
+  if (sockaddr)
+    do_async_connectable (connectable);
+  else
+    {
+      g_object_unref (connectable);
+      done_lookup ();
+    }
+}
+
+static void
+do_async_connectable (GSocketConnectable *connectable)
+{
+  g_socket_connectable_get_next_async (connectable, cancellable,
+                                       got_next_async, NULL);
+}
+
+static void
+do_connectable (const char *arg, gboolean synchronous)
+{
+  char **parts;
+  GSocketConnectable *connectable;
+
+  if (strchr (arg, '/'))
+    {
+      /* service/protocol/domain */
+      parts = g_strsplit (arg, "/", 3);
+      if (!parts || !parts[2])
+	usage ();
+
+      connectable = g_network_service_new (parts[0], parts[1], parts[2]);
+    }
+  else
+    {
+      guint16 port;
+
+      parts = g_strsplit (arg, ":", 2);
+      if (parts && parts[1])
+	{
+	  arg = parts[0];
+	  port = strtoul (parts[1], NULL, 10);
+	}
+      else
+	port = 0;
+
+      if (g_hostname_is_ip_address (arg))
+	{
+	  GInetAddress *addr = g_inet_address_new_from_string (arg);
+	  GSocketAddress *sockaddr = g_inet_socket_address_new (addr, port);
+
+	  g_object_unref (addr);
+	  connectable = G_SOCKET_CONNECTABLE (sockaddr);
+	}
+      else
+        connectable = g_network_address_new (arg, port);
+    }
+
+  if (synchronous)
+    do_sync_connectable (connectable);
+  else
+    do_async_connectable (connectable);
+}
+
+#ifdef G_OS_UNIX
+static int cancel_fds[2];
+
+static void
+interrupted (int sig)
+{
+  signal (SIGINT, SIG_DFL);
+  write (cancel_fds[1], "x", 1);
+}
+
+static gboolean
+async_cancel (GIOChannel *source, GIOCondition cond, gpointer cancellable)
+{
+  g_cancellable_cancel (cancellable);
+  return FALSE;
+}
+#endif
+
+int
+main (int argc, char **argv)
+{
+  gboolean threaded = FALSE, synchronous = FALSE;
+  gboolean use_connectable = FALSE;
+#ifdef G_OS_UNIX
+  GIOChannel *chan;
+  guint watch;
+#endif
+
+  /* We can't use GOptionContext because we use the arguments to
+   * decide whether or not to call g_thread_init().
+   */
+  while (argc >= 2 && argv[1][0] == '-')
+    {
+      if (!strcmp (argv[1], "-t"))
+        {
+          g_thread_init (NULL);
+          threaded = TRUE;
+        }
+      else if (!strcmp (argv[1], "-s"))
+        synchronous = TRUE;
+      else if (!strcmp (argv[1], "-c"))
+        use_connectable = TRUE;
+      else
+        usage ();
+
+      argv++;
+      argc--;
+    }
+  g_type_init ();
+
+  if (argc < 2 || (argc > 2 && use_connectable))
+    usage ();
+
+  resolver = g_resolver_get_default ();
+
+  cancellable = g_cancellable_new ();
+
+#ifdef G_OS_UNIX
+  /* Set up cancellation; we want to cancel if the user ^C's the
+   * program, but we can't cancel directly from an interrupt.
+   */
+  signal (SIGINT, interrupted);
+
+  if (pipe (cancel_fds) == -1)
+    {
+      perror ("pipe");
+      exit (1);
+    }
+  chan = g_io_channel_unix_new (cancel_fds[0]);
+  watch = g_io_add_watch (chan, G_IO_IN, async_cancel, cancellable);
+  g_io_channel_unref (chan);
+#endif
+
+  nlookups = argc - 1;
+  loop = g_main_loop_new (NULL, TRUE);
+
+  if (use_connectable)
+    do_connectable (argv[1], synchronous);
+  else
+    {
+      if (threaded && synchronous)
+        start_threaded_lookups (argv + 1, argc - 1);
+      else if (synchronous)
+        start_sync_lookups (argv + 1, argc - 1);
+      else
+        start_async_lookups (argv + 1, argc - 1);
+    }
+
+  g_main_run (loop);
+  g_main_loop_unref (loop);
+
+#ifdef G_OS_UNIX
+  g_source_remove (watch);
+#endif
+  g_object_unref (cancellable);
+
+  return 0;
+}
diff --git a/glib/Makefile.am b/glib/Makefile.am
index c6f20bb..eb220e6 100644
--- a/glib/Makefile.am
+++ b/glib/Makefile.am
@@ -116,6 +116,7 @@ libglib_2_0_la_SOURCES = 	\
 	gfileutils.c		\
 	ghash.c			\
 	ghook.c			\
+	ghostutils.c		\
 	giochannel.c    	\
 	gkeyfile.c        	\
 	glibintl.h		\
@@ -199,6 +200,7 @@ glibsubinclude_HEADERS =   \
 	gfileutils.h	\
 	ghash.h		\
 	ghook.h		\
+	ghostutils.h	\
 	gi18n.h		\
 	gi18n-lib.h	\
 	giochannel.h	\
diff --git a/glib/ghostutils.c b/glib/ghostutils.c
new file mode 100644
index 0000000..63e1dff
--- /dev/null
+++ b/glib/ghostutils.c
@@ -0,0 +1,758 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include "glib.h"
+#include "glibintl.h"
+
+#include <string.h>
+
+#include "galias.h"
+
+/**
+ * SECTION:ghostutils
+ * @short_description: Internet hostname utilities
+ * @include: glib.h
+ *
+ * Functions for manipulating internet hostnames; in particular, for
+ * converting between Unicode and ASCII-encoded forms of
+ * Internationalized Domain Names (IDNs).
+ *
+ * The <ulink
+ * link="http://www.ietf.org/rfc/rfc3490.txt">Internationalized Domain
+ * Names for Applications (IDNA)</ulink> standards allow for the use
+ * of Unicode domain names in applications, while providing
+ * backward-compatibility with the old ASCII-only DNS, by defining an
+ * ASCII-Compatible Encoding of any given Unicode name, which can be
+ * used with non-IDN-aware applications and protocols. (For example,
+ * "Παν語.org" maps to "xn--4wa8awb4637h.org".)
+ **/
+
+#define IDNA_ACE_PREFIX     "xn--"
+#define IDNA_ACE_PREFIX_LEN 4
+
+/* Punycode constants, from RFC 3492. */
+
+#define PUNYCODE_BASE          36
+#define PUNYCODE_TMIN           1
+#define PUNYCODE_TMAX          26
+#define PUNYCODE_SKEW          38
+#define PUNYCODE_DAMP         700
+#define PUNYCODE_INITIAL_BIAS  72
+#define PUNYCODE_INITIAL_N   0x80
+
+#define PUNYCODE_IS_BASIC(cp) ((guint)(cp) < 0x80)
+
+/* Encode/decode a single base-36 digit */
+static inline gchar
+encode_digit (guint dig)
+{
+  if (dig < 26)
+    return dig + 'a';
+  else
+    return dig - 26 + '0';
+}
+
+static inline guint
+decode_digit (gchar dig)
+{
+  if (dig >= 'A' && dig <= 'Z')
+    return dig - 'A';
+  else if (dig >= 'a' && dig <= 'z')
+    return dig - 'a';
+  else if (dig >= '0' && dig <= '9')
+    return dig - '0' + 26;
+  else
+    return G_MAXUINT;
+}
+
+/* Punycode bias adaptation algorithm, RFC 3492 section 6.1 */
+static guint
+adapt (guint    delta,
+       guint    numpoints,
+       gboolean firsttime)
+{
+  guint k;
+
+  delta = firsttime ? delta / PUNYCODE_DAMP : delta / 2;
+  delta += delta / numpoints;
+
+  k = 0;
+  while (delta > ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2)
+    {
+      delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
+      k += PUNYCODE_BASE;
+    }
+
+  return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
+	      (delta + PUNYCODE_SKEW));
+}
+
+/* Punycode encoder, RFC 3492 section 6.3. The algorithm is
+ * sufficiently bizarre that it's not really worth trying to explain
+ * here.
+ */
+static gboolean
+punycode_encode (const gchar *input_utf8,
+                 gsize        input_utf8_length,
+		 GString     *output)
+{
+  guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
+  gunichar n, m, *input;
+  glong input_length;
+  gboolean success = FALSE;
+
+  /* Convert from UTF-8 to Unicode code points */
+  input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
+			  &input_length, NULL);
+  if (!input)
+    return FALSE;
+
+  /* Copy basic chars */
+  for (j = num_basic_chars = 0; j < input_length; j++)
+    {
+      if (PUNYCODE_IS_BASIC (input[j]))
+	{
+	  g_string_append_c (output, g_ascii_tolower (input[j]));
+	  num_basic_chars++;
+	}
+    }
+  if (num_basic_chars)
+    g_string_append_c (output, '-');
+
+  handled_chars = num_basic_chars;
+
+  /* Encode non-basic chars */
+  delta = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+  n = PUNYCODE_INITIAL_N;
+  while (handled_chars < input_length)
+    {
+      /* let m = the minimum {non-basic} code point >= n in the input */
+      for (m = G_MAXUINT, j = 0; j < input_length; j++)
+	{
+	  if (input[j] >= n && input[j] < m)
+	    m = input[j];
+	}
+
+      if (m - n > (G_MAXUINT - delta) / (handled_chars + 1))
+	goto fail;
+      delta += (m - n) * (handled_chars + 1);
+      n = m;
+
+      for (j = 0; j < input_length; j++)
+	{
+	  if (input[j] < n)
+	    {
+	      if (++delta == 0)
+		goto fail;
+	    }
+	  else if (input[j] == n)
+	    {
+	      q = delta;
+	      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+		{
+		  if (k <= bias)
+		    t = PUNYCODE_TMIN;
+		  else if (k >= bias + PUNYCODE_TMAX)
+		    t = PUNYCODE_TMAX;
+		  else
+		    t = k - bias;
+		  if (q < t)
+		    break;
+		  digit = t + (q - t) % (PUNYCODE_BASE - t);
+		  g_string_append_c (output, encode_digit (digit));
+		  q = (q - t) / (PUNYCODE_BASE - t);
+		}
+
+	      g_string_append_c (output, encode_digit (q));
+	      bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);
+	      delta = 0;
+	      handled_chars++;
+	    }
+	}
+
+      delta++;
+      n++;
+    }
+
+  success = TRUE;
+
+ fail:
+  g_free (input);
+  return success;
+}
+
+/* From RFC 3454, Table B.1 */
+#define idna_is_junk(ch) ((ch) == 0x00AD || (ch) == 0x1806 || (ch) == 0x200B || (ch) == 0x2060 || (ch) == 0xFEFF || (ch) == 0x034F || (ch) == 0x180B || (ch) == 0x180C || (ch) == 0x180D || (ch) == 0x200C || (ch) == 0x200D || ((ch) >= 0xFE00 && (ch) <= 0xFE0F))
+
+/* Scan @str for "junk" and return a cleaned-up string if any junk
+ * is found. Else return %NULL.
+ */
+static gchar *
+remove_junk (const gchar *str,
+             gint         len)
+{
+  GString *cleaned = NULL;
+  const gchar *p;
+  gunichar ch;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      ch = g_utf8_get_char (p);
+      if (idna_is_junk (ch))
+	{
+	  if (!cleaned)
+	    {
+	      cleaned = g_string_new (NULL);
+	      g_string_append_len (cleaned, str, p - str);
+	    }
+	}
+      else if (cleaned)
+	g_string_append_unichar (cleaned, ch);
+    }
+
+  if (cleaned)
+    return g_string_free (cleaned, FALSE);
+  else
+    return NULL;
+}
+
+static inline gboolean
+contains_uppercase_letters (const gchar *str,
+                            gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      if (g_unichar_isupper (g_utf8_get_char (p)))
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static inline gboolean
+contains_non_ascii (const gchar *str,
+                    gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p++)
+    {
+      if ((guchar)*p > 0x80)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+/* RFC 3454, Appendix C. ish. */
+static inline gboolean
+idna_is_prohibited (gunichar ch)
+{
+  switch (g_unichar_type (ch))
+    {
+    case G_UNICODE_CONTROL:
+    case G_UNICODE_FORMAT:
+    case G_UNICODE_UNASSIGNED:
+    case G_UNICODE_PRIVATE_USE:
+    case G_UNICODE_SURROGATE:
+    case G_UNICODE_LINE_SEPARATOR:
+    case G_UNICODE_PARAGRAPH_SEPARATOR:
+    case G_UNICODE_SPACE_SEPARATOR:
+      return TRUE;
+
+    case G_UNICODE_OTHER_SYMBOL:
+      if (ch == 0xFFFC || ch == 0xFFFD ||
+	  (ch >= 0x2FF0 && ch <= 0x2FFB))
+	return TRUE;
+      return FALSE;
+
+    case G_UNICODE_NON_SPACING_MARK:
+      if (ch == 0x0340 || ch == 0x0341)
+	return TRUE;
+      return FALSE;
+
+    default:
+      return FALSE;
+    }
+}
+
+/* RFC 3491 IDN cleanup algorithm. */
+static gchar *
+nameprep (const gchar *hostname,
+          gint         len)
+{
+  gchar *name, *tmp = NULL, *p;
+
+  /* It would be nice if we could do this without repeatedly
+   * allocating strings and converting back and forth between
+   * gunichars and UTF-8... The code does at least avoid doing most of
+   * the sub-operations when they would just be equivalent to a
+   * g_strdup().
+   */
+
+  /* Remove presentation-only characters */
+  name = remove_junk (hostname, len);
+  if (name)
+    {
+      tmp = name;
+      len = -1;
+    }
+  else
+    name = (gchar *)hostname;
+
+  /* Convert to lowercase */
+  if (contains_uppercase_letters (name, len))
+    {
+      name = g_utf8_strdown (name, len);
+      g_free (tmp);
+      tmp = name;
+      len = -1;
+    }
+
+  /* If there are no UTF8 characters, we're done. */
+  if (!contains_non_ascii (name, len))
+    {
+      if (name == (gchar *)hostname)
+        return len == -1 ? g_strdup (hostname) : g_strndup (hostname, len);
+      else
+        return name;
+    }
+
+  /* Normalize */
+  name = g_utf8_normalize (name, len, G_NORMALIZE_NFKC);
+  g_free (tmp);
+  tmp = name;
+
+  /* KC normalization may have created more capital letters (eg,
+   * angstrom -> capital A with ring). So we have to lowercasify a
+   * second time. (This is more-or-less how the nameprep algorithm
+   * does it. If tolower(nfkc(tolower(X))) is guaranteed to be the
+   * same as tolower(nfkc(X)), then we could skip the first tolower,
+   * but I'm not sure it is.)
+   */
+  if (contains_uppercase_letters (name, -1))
+    {
+      name = g_utf8_strdown (name, -1);
+      g_free (tmp);
+      tmp = name;
+    }
+
+  /* Check for prohibited characters */
+  for (p = name; *p; p = g_utf8_next_char (p))
+    {
+      if (idna_is_prohibited (g_utf8_get_char (p)))
+	{
+	  name = NULL;
+          g_free (tmp);
+	  goto done;
+	}
+    }
+
+  /* FIXME: We're supposed to verify certain constraints on bidi
+   * characters, but glib does not appear to have that information.
+   */
+
+ done:
+  return name;
+}
+
+/**
+ * g_hostname_to_ascii:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical ASCII form; an ASCII-only
+ * string containing no uppercase letters and not ending with a
+ * trailing dot.
+ *
+ * Return value: an ASCII hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_ascii (const gchar *hostname)
+{
+  gchar *name, *label, *p;
+  GString *out;
+  gssize llen, oldlen;
+  gboolean unicode;
+
+  out = g_string_new (NULL);
+  label = name = nameprep (hostname, -1);
+
+  do
+    {
+      unicode = FALSE;
+      for (p = label; *p && *p != '.'; p++)
+	{
+	  if ((guchar)*p > 0x80)
+	    unicode = TRUE;
+	}
+
+      oldlen = out->len;
+      llen = p - label;
+      if (unicode)
+	{
+          if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+            goto fail;
+
+	  g_string_append (out, IDNA_ACE_PREFIX);
+	  if (!punycode_encode (label, llen, out))
+	    goto fail;
+	}
+      else
+        g_string_append_len (out, label, llen);
+
+      if (out->len - oldlen > 63)
+	goto fail;
+
+      label += llen;
+      if (*label && *++label)
+        g_string_append_c (out, '.');
+    }
+  while (*label);
+
+  g_free (name);
+  return g_string_free (out, FALSE);
+
+ fail:
+  g_free (name);
+  g_string_free (out, TRUE);
+  return NULL;
+}
+
+/**
+ * g_hostname_is_non_ascii:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains Unicode characters. If this returns
+ * %TRUE, you need to encode the hostname with g_hostname_to_ascii()
+ * before using it in non-IDN-aware contexts.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any non-ASCII characters
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_non_ascii (const gchar *hostname)
+{
+  return contains_non_ascii (hostname, -1);
+}
+
+/* Punycode decoder, RFC 3492 section 6.2. As with punycode_encode(),
+ * read the RFC if you want to understand what this is actually doing.
+ */
+static gboolean
+punycode_decode (const gchar *input,
+                 gsize        input_length,
+                 GString     *output)
+{
+  GArray *output_chars;
+  gunichar n;
+  guint i, bias;
+  guint oldi, w, k, digit, t;
+  const gchar *split;
+
+  n = PUNYCODE_INITIAL_N;
+  i = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+
+  split = input + input_length - 1;
+  while (split > input && *split != '-')
+    split--;
+  if (split > input)
+    {
+      output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
+					split - input);
+      input_length -= (split - input) + 1;
+      while (input < split)
+	{
+	  gunichar ch = (gunichar)*input++;
+	  if (!PUNYCODE_IS_BASIC (ch))
+	    goto fail;
+	  g_array_append_val (output_chars, ch);
+	}
+      input++;
+    }
+  else
+    output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
+
+  while (input_length)
+    {
+      oldi = i;
+      w = 1;
+      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+	{
+	  if (!input_length--)
+	    goto fail;
+	  digit = decode_digit (*input++);
+	  if (digit >= PUNYCODE_BASE)
+	    goto fail;
+	  if (digit > (G_MAXUINT - i) / w)
+	    goto fail;
+	  i += digit * w;
+	  if (k <= bias)
+	    t = PUNYCODE_TMIN;
+	  else if (k >= bias + PUNYCODE_TMAX)
+	    t = PUNYCODE_TMAX;
+	  else
+	    t = k - bias;
+	  if (digit < t)
+	    break;
+	  if (w > G_MAXUINT / (PUNYCODE_BASE - t))
+	    goto fail;
+	  w *= (PUNYCODE_BASE - t);
+	}
+
+      bias = adapt (i - oldi, output_chars->len + 1, oldi == 0);
+
+      if (i / (output_chars->len + 1) > G_MAXUINT - n)
+	goto fail;
+      n += i / (output_chars->len + 1);
+      i %= (output_chars->len + 1);
+
+      g_array_insert_val (output_chars, i++, n);
+    }
+
+  for (i = 0; i < output_chars->len; i++)
+    g_string_append_unichar (output, g_array_index (output_chars, gunichar, i));
+  g_array_free (output_chars, TRUE);
+  return TRUE;
+
+ fail:
+  g_array_free (output_chars, TRUE);
+  return FALSE;
+}
+
+/**
+ * g_hostname_to_unicode:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical presentation form; a UTF-8
+ * string in Unicode normalization form C, containing no uppercase
+ * letters, no forbidden characters, and no ASCII-encoded segments,
+ * and not ending with a trailing dot.
+ *
+ * Of course if @hostname is not an internationalized hostname, then
+ * the canonical presentation form will be entirely ASCII.
+ *
+ * Return value: a UTF-8 hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_unicode (const gchar *hostname)
+{
+  GString *out;
+  gssize llen;
+
+  out = g_string_new (NULL);
+
+  do
+    {
+      llen = strcspn (hostname, ".");
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	{
+	  hostname += IDNA_ACE_PREFIX_LEN;
+	  llen -= IDNA_ACE_PREFIX_LEN;
+	  if (!punycode_decode (hostname, llen, out))
+	    {
+	      g_string_free (out, TRUE);
+	      return NULL;
+	    }
+	}
+      else
+        {
+          gchar *canonicalized = nameprep (hostname, llen);
+
+          g_string_append (out, canonicalized);
+          g_free (canonicalized);
+        }
+
+      hostname += llen;
+      if (*hostname && *++hostname)
+        g_string_append_c (out, '.');
+    }
+  while (*hostname);
+
+  return g_string_free (out, FALSE);
+}
+
+/**
+ * g_hostname_is_ascii_encoded:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains segments with an ASCII-compatible
+ * encoding of an Internationalized Domain Name. If this returns
+ * %TRUE, you should decode the hostname with g_hostname_to_unicode()
+ * before displaying it to the user.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any ASCII-encoded
+ * segments.
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ascii_encoded (const gchar *hostname)
+{
+  while (1)
+    {
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	return TRUE;
+      hostname = strchr (hostname, '.');
+      if (!hostname++)
+	return FALSE;
+    }
+}
+
+/**
+ * g_hostname_is_ip_address:
+ * @hostname: a hostname (or IP address in string form)
+ *
+ * Tests if @hostname is the string form of an IPv4 or IPv6 address.
+ * (Eg, "192.168.0.1".)
+ *
+ * Return value: %TRUE if @hostname is an IP address
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ip_address (const gchar *hostname)
+{
+  gchar *p, *end;
+  gint nsegments, octet;
+
+  /* On Linux we could implement this using inet_pton, but the Windows
+   * equivalent of that requires linking against winsock, so we just
+   * figure this out ourselves. Tested by tests/hostutils.c.
+   */
+
+  p = (char *)hostname;
+
+  if (strchr (p, ':'))
+    {
+      gboolean skipped;
+
+      /* If it contains a ':', it's an IPv6 address (assuming it's an
+       * IP address at all). This consists of eight ':'-separated
+       * segments, each containing a 1-4 digit hex number, except that
+       * optionally: (a) the last two segments can be replaced by an
+       * IPv4 address, and (b) a single span of 1 to 8 "0000" segments
+       * can be replaced with just "::".
+       */
+
+      nsegments = 0;
+      skipped = FALSE;
+      while (*p && nsegments < 8)
+        {
+          /* Each segment after the first must be preceded by a ':'.
+           * (We also handle half of the "string starts with ::" case
+           * here.)
+           */
+          if (p != (char *)hostname || (p[0] == ':' && p[1] == ':'))
+            {
+              if (*p != ':')
+                return FALSE;
+              p++;
+            }
+
+          /* If there's another ':', it means we're skipping some segments */
+          if (*p == ':' && !skipped)
+            {
+              skipped = TRUE;
+              nsegments++;
+
+              /* Handle the "string ends with ::" case */
+              if (!p[1])
+                p++;
+
+              continue;
+            }
+
+          /* Read the segment, make sure it's valid. */
+          for (end = p; g_ascii_isxdigit (*end); end++)
+            ;
+          if (end == p || end > p + 4)
+            return FALSE;
+
+          if (*end == '.')
+            {
+              if ((nsegments == 6 && !skipped) || (nsegments <= 6 && skipped))
+                goto parse_ipv4;
+              else
+                return FALSE;
+            }
+
+          nsegments++;
+          p = end;
+        }
+
+      return !*p && (nsegments == 8 || skipped);
+    }
+
+ parse_ipv4:
+
+  /* Parse IPv4: N.N.N.N, where each N <= 255 and doesn't have leading 0s. */
+  for (nsegments = 0; nsegments < 4; nsegments++)
+    {
+      if (nsegments != 0)
+        {
+          if (*p != '.')
+            return FALSE;
+          p++;
+        }
+
+      /* Check the segment; a little tricker than the IPv6 case since
+       * we can't allow extra leading 0s, and we can't assume that all
+       * strings of valid length are within range.
+       */
+      octet = 0;
+      if (*p == '0')
+        end = p + 1;
+      else
+        {
+          for (end = p; g_ascii_isdigit (*end); end++)
+            octet = 10 * octet + (*end - '0');
+        }
+      if (end == p || end > p + 3 || octet > 255)
+        return FALSE;
+
+      p = end;
+    }
+
+  /* If there's nothing left to parse, then it's ok. */
+  return !*p;
+}
+
+#define __G_HOST_UTILS_C__
+#include "galiasdef.c"
diff --git a/glib/ghostutils.h b/glib/ghostutils.h
new file mode 100644
index 0000000..0349da3
--- /dev/null
+++ b/glib/ghostutils.h
@@ -0,0 +1,40 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
+#error "Only <glib.h> can be included directly."
+#endif
+
+#ifndef __G_HOST_UTILS_H__
+#define __G_HOST_UTILS_H__
+
+#include <glib/gtypes.h>
+
+G_BEGIN_DECLS
+
+gboolean  g_hostname_is_non_ascii     (const gchar *hostname);
+gboolean  g_hostname_is_ascii_encoded (const gchar *hostname);
+gboolean  g_hostname_is_ip_address    (const gchar *hostname);
+
+gchar    *g_hostname_to_ascii         (const gchar *hostname);
+gchar    *g_hostname_to_unicode       (const gchar *hostname);
+
+G_END_DECLS
+
+#endif /* __G_HOST_UTILS_H__ */
diff --git a/glib/glib.h b/glib/glib.h
index 000d417..f8acdd2 100644
--- a/glib/glib.h
+++ b/glib/glib.h
@@ -47,6 +47,7 @@
 #include <glib/gfileutils.h>
 #include <glib/ghash.h>
 #include <glib/ghook.h>
+#include <glib/ghostutils.h>
 #include <glib/giochannel.h>
 #include <glib/gkeyfile.h>
 #include <glib/glist.h>
diff --git a/glib/glib.symbols b/glib/glib.symbols
index 333164f..061a693 100644
--- a/glib/glib.symbols
+++ b/glib/glib.symbols
@@ -1637,6 +1637,16 @@ g_win32_locale_filename_from_utf8
 #endif
 #endif
 
+#if IN_HEADER(__G_HOST_UTILS_H__)
+#if IN_FILE(__G_HOST_UTILS_C__)
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+g_hostname_is_ip_address
+g_hostname_to_ascii
+g_hostname_to_unicode
+#endif
+#endif
+
 #ifdef INCLUDE_VARIABLES
 g_ascii_table
 g_utf8_skip
diff --git a/glib/gmarkup.c b/glib/gmarkup.c
index ccc7626..b1f4f46 100644
--- a/glib/gmarkup.c
+++ b/glib/gmarkup.c
@@ -2930,7 +2930,7 @@ g_markup_collect_attributes (const gchar         *element_name,
             /* duplicate! */
             break;
 
-        /* j is now the first occurance of attribute_names[i] */
+        /* j is now the first occurrence of attribute_names[i] */
         if (i == j)
           g_set_error (error, G_MARKUP_ERROR,
                        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
diff --git a/glib/gregex.c b/glib/gregex.c
index ba9174a..f92f0a9 100644
--- a/glib/gregex.c
+++ b/glib/gregex.c
@@ -2379,7 +2379,7 @@ interpolation_list_needs_match (GList *list)
  * @match_options: options for the match
  * @error: location to store the error occuring, or %NULL to ignore errors
  *
- * Replaces all occurances of the pattern in @regex with the
+ * Replaces all occurrences of the pattern in @regex with the
  * replacement text. Backreferences of the form '\number' or 
  * '\g&lt;number&gt;' in the replacement text are interpolated by the 
  * number-th captured subexpression of the match, '\g&lt;name&gt;' refers 
@@ -2491,7 +2491,7 @@ literal_replacement (const GMatchInfo *match_info,
  * @match_options: options for the match
  * @error: location to store the error occuring, or %NULL to ignore errors
  *
- * Replaces all occurances of the pattern in @regex with the
+ * Replaces all occurrences of the pattern in @regex with the
  * replacement text. @replacement is replaced literally, to
  * include backreferences use g_regex_replace().
  *
@@ -2535,8 +2535,8 @@ g_regex_replace_literal (const GRegex      *regex,
  * @user_data: user data to pass to the function
  * @error: location to store the error occuring, or %NULL to ignore errors
  *
- * Replaces occurances of the pattern in regex with the output of 
- * @eval for that occurance.
+ * Replaces occurrences of the pattern in regex with the output of 
+ * @eval for that occurrence.
  *
  * Setting @start_position differs from just passing over a shortened 
  * string and setting #G_REGEX_MATCH_NOTBOL in the case of a pattern 
diff --git a/glib/tests/.gitignore b/glib/tests/.gitignore
index 5e91729..76c25a8 100644
--- a/glib/tests/.gitignore
+++ b/glib/tests/.gitignore
@@ -1,5 +1,6 @@
 array-test
 fileutils
+hostutils
 keyfile
 markup-subparser
 option-context
diff --git a/glib/tests/Makefile.am b/glib/tests/Makefile.am
index 3d497ac..673d338 100644
--- a/glib/tests/Makefile.am
+++ b/glib/tests/Makefile.am
@@ -44,6 +44,9 @@ markup_subparser_LDADD    = $(progs_ldadd)
 TEST_PROGS         += array-test
 array_test_LDADD    = $(progs_ldadd)
 
+TEST_PROGS         += hostutils
+hostutils_LDADD     = $(progs_ldadd)
+
 if OS_UNIX
 
 # some testing of gtester funcitonality
diff --git a/glib/tests/hostutils.c b/glib/tests/hostutils.c
new file mode 100644
index 0000000..515145a
--- /dev/null
+++ b/glib/tests/hostutils.c
@@ -0,0 +1,267 @@
+/* 
+ * Copyright (C) 2008 Red Hat, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <glib/glib.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+static const struct {
+  const gchar *ascii_name, *unicode_name;
+} idn_test_domains[] = {
+  /* "example.test" in various languages */
+  { "xn--mgbh0fb.xn--kgbechtv", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa5\xd8\xae\xd8\xaa\xd8\xa8\xd8\xa7\xd8\xb1" },
+  { "xn--fsqu00a.xn--0zwm56d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb5\x8b\xe8\xaf\x95" },
+  { "xn--fsqu00a.xn--g6w251d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb8\xac\xe8\xa9\xa6" },
+  { "xn--hxajbheg2az3al.xn--jxalpdlp", "\xcf\x80\xce\xb1\xcf\x81\xce\xac\xce\xb4\xce\xb5\xce\xb9\xce\xb3\xce\xbc\xce\xb1.\xce\xb4\xce\xbf\xce\xba\xce\xb9\xce\xbc\xce\xae" },
+  { "xn--p1b6ci4b4b3a.xn--11b5bs3a9aj6g", "\xe0\xa4\x89\xe0\xa4\xa6\xe0\xa4\xbe\xe0\xa4\xb9\xe0\xa4\xb0\xe0\xa4\xa3.\xe0\xa4\xaa\xe0\xa4\xb0\xe0\xa5\x80\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb7\xe0\xa4\xbe" },
+  { "xn--r8jz45g.xn--zckzah", "\xe4\xbe\x8b\xe3\x81\x88.\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88" },
+  { "xn--9n2bp8q.xn--9t4b11yi5a", "\xec\x8b\xa4\xeb\xa1\x80.\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8" },
+  { "xn--mgbh0fb.xn--hgbk6aj7f53bba", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa2\xd8\xb2\xd9\x85\xd8\xa7\xdb\x8c\xd8\xb4\xdb\x8c" },
+  { "xn--e1afmkfd.xn--80akhbyknj4f", "\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80.\xd0\xb8\xd1\x81\xd0\xbf\xd1\x8b\xd1\x82\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5" },
+  { "xn--zkc6cc5bi7f6e.xn--hlcj6aya9esc7a", "\xe0\xae\x89\xe0\xae\xa4\xe0\xae\xbe\xe0\xae\xb0\xe0\xae\xa3\xe0\xae\xae\xe0\xaf\x8d.\xe0\xae\xaa\xe0\xae\xb0\xe0\xae\xbf\xe0\xae\x9f\xe0\xaf\x8d\xe0\xae\x9a\xe0\xaf\x88" },
+  { "xn--fdbk5d8ap9b8a8d.xn--deba0ad", "\xd7\x91\xd7\xb2\xd6\xb7\xd7\xa9\xd7\xa4\xd6\xbc\xd7\x99\xd7\x9c.\xd7\x98\xd7\xa2\xd7\xa1\xd7\x98" },
+
+  /* further examples without their own IDN-ized TLD */
+  { "xn--1xd0bwwra.idn.icann.org", "\xe1\x8a\xa0\xe1\x88\x9b\xe1\x88\xad\xe1\x8a\x9b.idn.icann.org" },
+  { "xn--54b7fta0cc.idn.icann.org", "\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe.idn.icann.org" },
+  { "xn--5dbqzzl.idn.icann.org", "\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa.idn.icann.org" },
+  { "xn--j2e7beiw1lb2hqg.idn.icann.org", "\xe1\x9e\x97\xe1\x9e\xb6\xe1\x9e\x9f\xe1\x9e\xb6\xe1\x9e\x81\xe1\x9f\x92\xe1\x9e\x98\xe1\x9f\x82\xe1\x9e\x9a.idn.icann.org" },
+  { "xn--o3cw4h.idn.icann.org", "\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2.idn.icann.org" },
+  { "xn--mgbqf7g.idn.icann.org", "\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88.idn.icann.org" }
+};
+static const gint num_idn_test_domains = G_N_ELEMENTS (idn_test_domains);
+
+static void
+test_to_ascii (void)
+{
+  gint i;
+  gchar *ascii;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_non_ascii (idn_test_domains[i].unicode_name));
+      ascii = g_hostname_to_ascii (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+
+      ascii = g_hostname_to_ascii (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+    }
+}
+
+static void
+test_to_unicode (void)
+{
+  gint i;
+  gchar *unicode;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_ascii_encoded (idn_test_domains[i].ascii_name));
+      unicode = g_hostname_to_unicode (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+
+      unicode = g_hostname_to_unicode (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+    }
+}
+
+static const struct {
+  const gchar *addr;
+  gboolean is_addr;
+} ip_addr_tests[] = {
+  /* IPv6 tests */
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98::", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::", TRUE },
+  { "0123:4567:89AB:cdef:3210::", TRUE },
+  { "0123:4567:89AB:cdef::", TRUE },
+  { "0123:4567:89AB::", TRUE },
+  { "0123:4567::", TRUE },
+  { "0123::", TRUE },
+
+  { "::4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::3210:7654:ba98:FeDc", TRUE },
+  { "::7654:ba98:FeDc", TRUE },
+  { "::ba98:FeDc", TRUE },
+  { "::FeDc", TRUE },
+
+  { "0123::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::FeDc", TRUE },
+
+  { "0123::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::FeDc", TRUE },
+
+  { "0123::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::FeDc", TRUE },
+
+  { "0123::7654:ba98:FeDc", TRUE },
+  { "0123:4567::ba98:FeDc", TRUE },
+  { "0123:4567:89AB::FeDc", TRUE },
+
+  { "0123::ba98:FeDc", TRUE },
+  { "0123:4567::FeDc", TRUE },
+
+  { "0123::FeDc", TRUE },
+
+  { "::", TRUE },
+
+  { "0:12:345:6789:a:bc:def::", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef:3210::123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef::123.45.67.89", TRUE },
+  { "0123:4567:89AB::123.45.67.89", TRUE },
+  { "0123:4567::123.45.67.89", TRUE },
+  { "0123::123.45.67.89", TRUE },
+  { "::123.45.67.89", TRUE },
+
+  /* Contain non-hex chars */
+  { "012x:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:45x7:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:8xAB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:xdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:321;:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:76*4:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:b-98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:+eDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc and some trailing junk", FALSE },
+  { " 123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "012 :4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123: 567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeD ", FALSE },
+
+  /* Contains too-long/out-of-range segments */
+  { "00123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:04567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:189AB:cdef:3210:7654:ba98:FeDc", FALSE },
+
+  /* Too short */
+  { "0123:4567:89AB:cdef:3210:7654:ba98", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654", FALSE },
+  { "0123:4567:89AB:cdef:3210", FALSE },
+  { "0123", FALSE },
+  { "", FALSE },
+
+  /* Too long */
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:9999", FALSE },
+  { "0123::4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567::89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef::3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210::7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98::FeDc", FALSE },
+
+  /* Invalid use of ":"s */
+  { "0123::89AB::3210:7654:ba98:FeDc", FALSE },
+  { "::4567:89AB:cdef:3210:7654::FeDc", FALSE },
+  { "0123::89AB:cdef:3210:7654:ba98::", FALSE },
+  { ":4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:", FALSE },
+  { "0123:::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:", FALSE },
+  { ":0123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { ":::", FALSE },
+
+  /* IPv4 address at wrong place */
+  { "0123:4567:89AB:cdef:3210:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:123.45.67.89:FeDc", FALSE },
+
+
+  /* IPv4 tests */
+
+  { "123.45.67.89", TRUE },
+  { "1.2.3.4", TRUE },
+  { "1.2.3.0", TRUE },
+
+  { "023.045.067.089", FALSE },
+  { "1234.5.67.89", FALSE },
+  { "123.45.67.00", FALSE },
+  { " 1.2.3.4", FALSE },
+  { "1 .2.3.4", FALSE },
+  { "1. 2.3.4", FALSE },
+  { "1.2.3.4 ", FALSE },
+  { "1.2.3", FALSE },
+  { "1.2.3.4.5", FALSE },
+  { "1.b.3.4", FALSE },
+  { "1.2.3:4", FALSE },
+  { "1.2.3.4, etc", FALSE },
+  { "1,2,3,4", FALSE },
+  { "1.2.3.com", FALSE },
+  { "1.2.3.4.", FALSE },
+  { "1.2.3.", FALSE },
+  { ".1.2.3.4", FALSE },
+  { ".2.3.4", FALSE },
+  { "1..2.3.4", FALSE },
+  { "1..3.4", FALSE }
+};
+static const gint num_ip_addr_tests = G_N_ELEMENTS (ip_addr_tests);
+
+static void
+test_is_ip_addr (void)
+{
+  gint i;
+
+  for (i = 0; i < num_ip_addr_tests; i++)
+    {
+      if (g_hostname_is_ip_address (ip_addr_tests[i].addr) != ip_addr_tests[i].is_addr)
+	{
+	  char *msg = g_strdup_printf ("g_hostname_is_ip_address (\"%s\") == %s",
+				       ip_addr_tests[i].addr,
+				       ip_addr_tests[i].is_addr ? "TRUE" : "FALSE");
+	  g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
+	}
+    }
+}
+
+/* FIXME: test names with both unicode and ACE-encoded labels */
+/* FIXME: test invalid unicode names */
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+  
+  g_test_add_func ("/hostutils/to_ascii", test_to_ascii);
+  g_test_add_func ("/hostutils/to_unicode", test_to_unicode);
+  g_test_add_func ("/hostutils/is_ip_addr", test_is_ip_addr);
+
+  return g_test_run ();
+}
diff --git a/glibconfig.h.win32.in b/glibconfig.h.win32.in
index 92e8964..f10fa32 100644
--- a/glibconfig.h.win32.in
+++ b/glibconfig.h.win32.in
@@ -250,6 +250,9 @@ union _GSystemThread
  */
 typedef void * GPid;
 
+#define GLIB_SYSDEF_AF_INET 2
+#define GLIB_SYSDEF_AF_INET6 23
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
diff --git a/po/ChangeLog b/po/ChangeLog
index fd9ead4..2fb03ed 100644
--- a/po/ChangeLog
+++ b/po/ChangeLog
@@ -1,3 +1,35 @@
+2009-02-10  Inaki Larranaga Murgoitio  <dooteo@euskalgnu.org>
+
+	* eu.po: Updated Basque translation.
+
+2009-02-07   Clytie Siddall <clytie@riverland.net.au>
+
+	* vi.po: Updated Vietnamese translation.
+
+2009-02-06  Kjartan Maraas  <kmaraas@gnome.org>
+
+	* nb.po: Updated Norwegian bokmål translation.
+
+2009-02-06  Theppitak Karoonboonyanan  <thep@linux.thai.net>
+
+	* th.po: Updated Thai translation.
+
+2009-02-05  Takeshi AIHANA <takeshi.aihana@gmail.com>
+
+	* ja.po: Updated Japanese translation.
+
+2009-02-04  Wouter Bolsterlee  <wbolster@svn.gnome.org>
+
+	* nl.po: Dutch translation updated by Wouter Bolsterlee.
+
+2009-02-04  Sweta Kothari  <swkothar@redhat.com>
+
+	* gu.po: Committed Gujarati Translation.
+
+2009-02-03  Sweta Kothari  <swkothar@redhat.com>
+
+	* gu.po: Committed Gujarati Translation.
+
 2009-02-02  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.6 ===
@@ -13,8 +45,8 @@
 
 2009-01-30  Chao-Hsiung Liao  <j_h_liau@yahoo.com.tw>
 
-        * zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
-        * zh_TW.po: Updated Traditional Chinese translation(Taiwan).
+	* zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
+	* zh_TW.po: Updated Traditional Chinese translation(Taiwan).
 
 2009-01-28  Manoj Kumar Giri <mgiri@redhat.com>
 
@@ -66,7 +98,8 @@
 
 2009-01-04  甘露(Gan Lu) <rhythm.gan@gmail.com>
 
-        * zh_CN.po: Updated Chinese Simplified translation by Deng Xiyue <manphiz@gmail.com>.
+	* zh_CN.po: Updated Chinese Simplified translation by
+	Deng Xiyue <manphiz@gmail.com>.
 
 2008-12-15  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -74,7 +107,7 @@
 
 2008-12-15  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-	* es.po: Updated Spanish translation                    
+	* es.po: Updated Spanish translation
 
 2008-12-15  Matthias Clasen <mclasen@redhat.com>
 
@@ -106,11 +139,11 @@
 
 2008-11-13 Maxim Dziumanenko <dziumanenko@gmail.com>
 
-        * uk.po: Update Ukrainian translation.
+	* uk.po: Update Ukrainian translation.
 
 2008-11-08  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-	* es.po: Updated Spanish translation    
+	* es.po: Updated Spanish translation
 
 2008-10-16  Matthias Clasen <mclasen@redhat.com>
 
@@ -141,7 +174,7 @@
 	* ro.po: Updated Romanian translation by
 	Mişu Moldovan <dumol@gnome.ro>
 
-2008-09-18  Djihed Afifi <djihed@gmail.com> 
+2008-09-18  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Anas Afif Emad.
 
@@ -153,7 +186,7 @@
 
 	* te.po: Updated Telugu Translation.
 
-2008-09-15  Djihed Afifi <djihed@gmail.com> 
+2008-09-15  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -163,7 +196,7 @@
 
 2008-09-11  Rajesh Ranjan <rajeshkajha@yahoo.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2008-09-09  Manoj Kumar Giri  <mgiri@redhat.com>
 
@@ -224,7 +257,7 @@
 
 2008-08-25  Goran Rakic  <grakic@devbase.net>
 
-        * LINGUAS, sr@latin.po, sr@Latn.po: Conversion from sr@Latn to sr@latin.
+	* LINGUAS, sr@latin.po, sr@Latn.po: Conversion from sr@Latn to sr@latin.
 
 2008-08-24  Gintautas Miliauskas  <gintas@akl.lt>
 
@@ -232,7 +265,7 @@
 
 2008-08-24 Maxim Dziumanenko <dziumanenko@gmail.com>
 
-        * uk.po: Update Ukrainian translation.
+	* uk.po: Update Ukrainian translation.
 
 2008-08-23  Priit Laes  <plaes at svn dot gnome dot org>
 
@@ -305,7 +338,7 @@
 
 	* eu.po: Updated Basque translation.
 
-2008-08-10  Jorge Gonzalez  <jorgegonz@svn.gnome.org> 
+2008-08-10  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
 	* es.po: Updated Spanish translation
 
@@ -321,7 +354,7 @@
 
 	* gl.po: Updated Galician translation
 
-2008-08-6  Djihed Afifi <djihed@gmail.com> 
+2008-08-6  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -362,7 +395,7 @@
 
 	* gl.po: Updated Galician Translation.
 
-2008-07-29  Djihed Afifi <djihed@gmail.com> 
+2008-07-29  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -396,7 +429,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2008-07-20  Andre Klapper  <a9016009@gmx.de>
 
-        * de.po: Updated German translation
+	* de.po: Updated German translation
 
 2008-07-16  Laurent Dhima  <laurenti@alblinux.net>
 
@@ -409,13 +442,13 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2008-07-14  Chao-Hsiung Liao  <j_h_liau@yahoo.com.tw>
 
-        * zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
-        * zh_TW.po: Updated Traditional Chinese translation(Taiwan).
+	* zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
+	* zh_TW.po: Updated Traditional Chinese translation(Taiwan).
 
 2008-07-13  Chao-Hsiung Liao  <j_h_liau@yahoo.com.tw>
 
-        * zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
-        * zh_TW.po: Updated Traditional Chinese translation(Taiwan).
+	* zh_HK.po: Updated Traditional Chinese translation(Hong Kong).
+	* zh_TW.po: Updated Traditional Chinese translation(Taiwan).
 
 2008-07-10  Theppitak Karoonboonyanan  <thep@linux.thai.net>
 
@@ -442,14 +475,14 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 	* ko.po: Updated Korean translation.
 
 2008-06-12  Matthias Clasen  <mclasen@redhat.com>
-	
+
 	* === Released 2.17.2 ===
 
 2008-06-12  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.17.1 ===
 
-2008-06-11  Djihed Afifi <djihed@gmail.com> 
+2008-06-11  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -473,7 +506,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* === Released 2.17.0 ===
 
-2008-05-22  Djihed Afifi <djihed@gmail.com> 
+2008-05-22  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -561,7 +594,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 2008-03-11 Baris Cicek <baris@teamforce.name.tr>
 
 	* tr.po: Updated Turkish translation
-	
+
 2008-03-11  Inaki Larranaga Murgoitio  <dooteo@euskalgnu.org>
 
 	* eu.po: Updated Basque translation.
@@ -583,7 +616,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 	* es.po: Updated Spanish translation
 
 2008-03-10  Matthias Clasen  <mclasen@redhat.com>
-	
+
 	* === Released 2.16.1 ===
 
 2008-03-10  Kenneth Nielsen  <k.nielsen81@gmail.com>
@@ -734,7 +767,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* he.po: Updated Hebrew translation.
 
-2008-02-17  Djihed Afifi <djihed@gmail.com> 
+2008-02-17  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -745,7 +778,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 2008-02-17  David Lodge <dave@cirt.net>
 
 	* en_GB.po: Updated British English translation
-	
+
 2008-02-16  Ihar Hrachyshka <booxter@lacinka.org>
 
 	* be@latin.po: Updated Belarusian Latin translation.
@@ -782,7 +815,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* ko.po: Updated Korean translation.
 
-2008-02-6  Djihed Afifi <djihed@gmail.com> 
+2008-02-6  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -791,8 +824,8 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 	* th.po: Updated Thai translation.
 
 2008-02-04  Jovan Naumovski  <jovan@lugola.net>
- 
- 	* mk.po: Updated Macedonian translation.
+
+	* mk.po: Updated Macedonian translation.
 
 2008-02-03  Leonardo Ferreira Fontenelle  <leonardof@svn.gnome.org>
 
@@ -811,7 +844,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* sv.po: Updated Swedish translation.
 
-2008-01-31  Djihed Afifi <djihed@gmail.com> 
+2008-01-31  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Abou Manal.
 
@@ -831,7 +864,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* oc.po: Updated Occitan translation.
 
-2008-01-29  Djihed Afifi <djihed@gmail.com> 
+2008-01-29  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Abou Manal.
 
@@ -851,7 +884,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* sv.po: Updated Swedish translation.
 
-2008-01-27  Djihed Afifi <djihed@gmail.com> 
+2008-01-27  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Khaled Hosny.
 
@@ -905,7 +938,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2008-01-17 Maxim Dziumanenko <dziumanenko@gmail.com>
 
-        * uk.po: Update Ukrainian translation.
+	* uk.po: Update Ukrainian translation.
 
 2008-01-16  Inaki Larranaga Murgoitio  <dooteo@euskalgnu.org>
 
@@ -931,14 +964,14 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* it.po: Updated Italian translation.
 
-2008-01-12  Djihed Afifi <djihed@gmail.com> 
+2008-01-12  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
 2008-01-12  Baris Cicek <baris@teamforce.name.tr>
 
 	* tr.po: Updated Turkish translation
-	
+
 2008-01-12  Changwoo Ryu  <cwryu@debian.org>
 
 	* ko.po: Updated Korean translation.
@@ -947,9 +980,9 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* he.po: Updated Hebrew translation.
 
-2008-01-09  Jorge Gonzalez  <jorgegonz@svn.gnome.org>          
+2008-01-09  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-	* es.po: Updated Spanish translation.  
+	* es.po: Updated Spanish translation.
 
 008-01-07  Matthias Clasen  <mclasen@redhat.com>
 
@@ -957,8 +990,8 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2008-01-07  Luca Ferretti  <elle.uca@libero.it>
 
-	* POTFILES.in: remove deleted file gio/gdirectorymonitor.c 
-	
+	* POTFILES.in: remove deleted file gio/gdirectorymonitor.c
+
 	* it.po: Updated Italian translation.
 
 2008-01-07  Priit Laes  <plaes at svn dot gnome dot org>
@@ -973,7 +1006,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* be@latin.po: Updated Belarusian Latin translation.
 
-2008-01-04   Clytie Siddall <clytie@riverland.net.au>
+2008-01-04  Clytie Siddall <clytie@riverland.net.au>
 
 	* vi.po: Updated Vietnamese translation.
 
@@ -987,13 +1020,13 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-12-27  Inaki Larranaga Murgoitio  <dooteo@euskalgnu.org>
 
-        * eu.po: Updated Basque translation.
+	* eu.po: Updated Basque translation.
 
-2007-12-23  Jorge Gonzalez  <jorgegonz@svn.gnome.org>  
+2007-12-23  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
-2007-12-23  Djihed Afifi <djihed@gmail.com> 
+2007-12-23  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
@@ -1009,13 +1042,13 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* nb.po: Updated Norwegian bokmål translation.
 
-2007-12-17  Jorge Gonzalez  <jorgegonz@svn.gnome.org>                          
+2007-12-17  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-15  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-15  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -1024,11 +1057,11 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-12-14  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-14  Stéphane Raimbault  <stephane.raimbault@gmail.com>
 
-	* POTFILES.in: Updated file list (gio).  
+	* POTFILES.in: Updated file list (gio).
 	* fr.po: Updated French translation by Robert-André Mauchin and
 	Stéphane Raimbault.
 
@@ -1038,19 +1071,19 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-12-13  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-11  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-11 Rahul Bhalerao <b.rahul.pm@gmail.com>
-	
+
 	* mr.po: Added Marathi translations
-	
-2007-12-09  Jorge Gonzalez  <jorgegonz@svn.gnome.org> 
 
-        * es.po: Updated Spanish translation
+2007-12-09  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
+
+	* es.po: Updated Spanish translation
 
 2007-12-09  Espen Stefansen  <espens@svn.gnome.org>
 
@@ -1086,11 +1119,11 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-12-03  Andre Klapper  <a9016009@gmx.de>
 
-        * de.po: Updated German translation
+	* de.po: Updated German translation
 
 2007-12-01  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-12-01  Ihar Hrachyshka <ihar.hrachyshka@gmail.com>
 
@@ -1098,19 +1131,19 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-11-29  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation   
+	* es.po: Updated Spanish translation
 
 2007-11-28  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-11-27  Andre Klapper  <a9016009@gmx.de>
 
-        * POTFILES.in: Updated gio sources.
+	* POTFILES.in: Updated gio sources.
 
 2007-11-26  Alexander Larsson  <alexl@redhat.com>
 
-        * POTFILES.in:
+	* POTFILES.in:
 	Added gio sources
 
 2007-11-24  Claude Paroz  <claude@2xlibre.net>
@@ -1127,7 +1160,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-11-18  Jorge Gonzalez  <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-11-13  Matej Urbančič <mateju@svn.gnome.org>
 
@@ -1145,7 +1178,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* sl.po: Updated Slovenian translation.
 
-2007-10-23  Djihed Afifi <djihed@gmail.com> 
+2007-10-23  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
@@ -1153,7 +1186,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* ga.po: Updated Irish translation.
 
-2007-10-21  Djihed Afifi <djihed@gmail.com> 
+2007-10-21  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
@@ -1177,7 +1210,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* ko.po: Updated Korean translation.
 
-2007-09-17  Djihed Afifi <djihed@gmail.com> 
+2007-09-17  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
@@ -1187,7 +1220,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-09-16  Inaki Larranaga Murgoitio  <dooteo@zundan.com>
 
-        * eu.po: Updated Basque translation.
+	* eu.po: Updated Basque translation.
 
 2007-09-16  Takeshi AIHANA <takeshi.aihana@gmail.com>
 
@@ -1199,7 +1232,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-09-14  Vladimer Sichinava  <vsichi@gnome.org>
 
-        * ka.po: Updated Georgian translation.
+	* ka.po: Updated Georgian translation.
 
 2007-09-14 Gabor Kelemen  <kelemeng@gnome.hu>
 
@@ -1224,8 +1257,8 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-09-07 Maxim Dziumanenko <dziumanenko@gmail.com>
 
-    * Update Ukrainian translation.
-    
+	* Update Ukrainian translation.
+
 2007-09-07  Nickolay V. Shmyrev  <nshmyrev@yandex.ru>
 
 	* ru.po: Updated Russian translation
@@ -1242,7 +1275,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 	* da.po: Updated Danish translation
 
-2007-09-03   Clytie Siddall <clytie@riverland.net.au>
+2007-09-03  Clytie Siddall <clytie@riverland.net.au>
 
 	* vi.po: Updated Vietnamese translation.
 
@@ -1256,7 +1289,7 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 
 2007-08-31  Pramod Raghavendra <pramodleo@yahoo.co.uk>
 
-        * kn.po: Updated Kannada translation by Shankar Prasad.
+	* kn.po: Updated Kannada translation by Shankar Prasad.
 
 2007-08-30  Stéphane Raimbault  <stephane.raimbault@gmail.com>
 
@@ -1314,8 +1347,8 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 	* ta.po:  Tamil Translation updated by Tirumurthi Vasudevan
 
 2007-08-12  Jovan Naumovski  <jovan@lugola.net>
- 
- 	 * mk.po: Updated Macedonian translation.
+
+	* mk.po: Updated Macedonian translation.
 
 2007-08-11  Daniel Nylander <po@danielnylander.se>
 
@@ -1419,8 +1452,8 @@ wpV862008-07-22  Priit Laes  <plaes at svn dot gnome dot org>
 	* ko.po: Updated Korean translation by Eunju Kim.
 
 2007-07-03  Jovan Naumovski  <jovan@lugola.net>
- 
- 	 * mk.po: Updated Macedonian translation.
+
+	* mk.po: Updated Macedonian translation.
 
 2007-06-30  Takeshi AIHANA <takeshi.aihana@gmail.com>
 
@@ -1454,7 +1487,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2007-06-15  Jorge Gonzalez <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-06-13  Yair Hershkovitz  <yairhr@gmail.com>
 
@@ -1473,7 +1506,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 	* === Released 2.13.4 ===
 
 2007-06-04  Matthias Clasen  <mclasen@redhat.com>
-	
+
 	* === Released 2.13.3 ===
 
 2007-06-04  Matthias Clasen <mclasen@redhat.com>
@@ -1494,7 +1527,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2007-05-22  Jorge Gonzalez <jorgegonz@svn.gnome.org>
 
-        * es.po: Updated Spanish translation
+	* es.po: Updated Spanish translation
 
 2007-05-21  Theppitak Karoonboonyanan  <thep@linux.thai.net>
 
@@ -1536,7 +1569,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.13.1 ===
 
-2007-05-2  Djihed Afifi <djihed@gmail.com> 
+2007-05-2  Djihed Afifi <djihed@gmail.com>
 
 	* ar.po: Updated Arabic Translation by Djihed Afifi.
 
@@ -1563,8 +1596,8 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 	Alexander Shopov <ash@contact.bg>
 
 2007-03-06  Jovan Naumovski  <jovan@lugola.net>
- 
- 	 * mk.po: Updated Macedonian translation.
+
+	* mk.po: Updated Macedonian translation.
 
 2007-03-03  Thierry Randrianiriana  <randrianiriana@gmail.com>
 
@@ -1907,7 +1940,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-06-20  Rajesh Ranjan <rajeshkajha@yahoo.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-06-19  Hendrik Richter  <hendrikr@gnome.org>
 
@@ -2000,7 +2033,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-05-02  Ankit Patel  <ankit644@yahoo.com>
 
-        * gu.po: Updated Gujarati Translation.
+	* gu.po: Updated Gujarati Translation.
 
 2006-04-30  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -2029,19 +2062,19 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-04-21  Rajesh Ranjan <rajeshkajha@yahoo.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-04-19  Ankit Patel  <ankit644@yahoo.com>
 
-        * gu.po: Updated Gujarati Translation.
+	* gu.po: Updated Gujarati Translation.
 
 2006-04-18  Rajesh Ranjan <rajeshkajha@yahoo.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-04-18  Ankit Patel  <ankit644@yahoo.com>
 
-        * gu.po: Updated Gujarati Translation.
+	* gu.po: Updated Gujarati Translation.
 
 2006-04-17  Clytie Siddall <clytie@riverland.net.au>
 
@@ -2053,7 +2086,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-04-10  Vladimer Sichinava  <vlsichinava@gmail.com>
 
-        * ka.po: Updated Georgian translation.
+	* ka.po: Updated Georgian translation.
 
 2006-04-07  Ignacio Casal Quinteiro  <nacho.resa@gmail.com>
 
@@ -2084,19 +2117,19 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 2006-03-10  Guilherme de S. Pastore  <gpastore@gnome.org>
 
 	* pt_BR.po: Updated Brazilian Portuguese translation from Leandro
-	  A. F. Pereira <leandro@linuxmag.com.br>.
+	A. F. Pereira <leandro@linuxmag.com.br>.
 
 2006-03-06  Rajesh Ranjan <rranjan@redhat.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-03-06  Rajesh Ranjan <rranjan@redhat.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-03-06  Rajesh Ranjan <rranjan@redhat.com>
 
-        * hi.po: Updated Hindi Translation.
+	* hi.po: Updated Hindi Translation.
 
 2006-03-10  Subhransu Behera <sbehera@redhat.com>
 
@@ -2108,7 +2141,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-03-07  Daniel Nylander  <po@danielnylander.se>
 
-        * sv.po: Swedish translation updated.
+	* sv.po: Swedish translation updated.
 
 2006-03-03  Gabor Kelemen  <kelemeng@gnome.hu>
 
@@ -2156,7 +2189,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2006-02-07  Lukas Novotny  <lukasnov@cvs.gnome.org>
 
- 	* cs.po: Updated Czech translation.
+	* cs.po: Updated Czech translation.
 
 2006-02-04  Rhys Jones  <rhys@sucs.org>
 
@@ -2229,7 +2262,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-01-09  Ankit Patel  <ankit644@yahoo.com>
 
-        * gu.po: Updated Gujarati Translation.
+	* gu.po: Updated Gujarati Translation.
 
 2006-01-08  Takeshi AIHANA <aihana@gnome.gr.jp>
 
@@ -2391,7 +2424,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-09-01  Clytie Siddall <clytie@riverland.net.au>
 
-        * vi.po: Updated Vietnamese translation.
+	* vi.po: Updated Vietnamese translation.
 
 2005-08-31  Mugurel Tudor  <mugurelu@gnome.ro>
 
@@ -2404,7 +2437,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-08-29  Clytie Siddall <clytie@riverland.net.au>
 
-        * vi.po: Updated Vietnamese translation.
+	* vi.po: Updated Vietnamese translation.
 
 2005-08-28  Francisco Javier F. Serrador  <serrador@cvs.gnome.org>
 
@@ -2433,7 +2466,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-08-27  Clytie Siddall <clytie@riverland.net.au>
 
-        * vi.po: Updated Vietnamese translation.
+	* vi.po: Updated Vietnamese translation.
 
 2005-08-27  Christophe Merlet  <redfox@redfoxcenter.org>
 
@@ -2700,7 +2733,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-07-01  Chao-Hsiung Liao  <j_h_liau@yahoo.com.tw>
 
-        * zh_TW.po: Updated Traditional Chinese translation.
+	* zh_TW.po: Updated Traditional Chinese translation.
 
 2005-06-30  Matthias Clasen  <mclasen@redhat.com>
 
@@ -2858,7 +2891,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2005-03-30  Steve Murphy  <murf@e-tools.com>
 
-        * rw.po: Added Kinyarwanda translation.
+	* rw.po: Added Kinyarwanda translation.
 
 2005-03-30  Estêvão Samuel Procópio <tevaum@ig.com.br>
 
@@ -2871,7 +2904,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 2005-03-13  Roozbeh Pournader  <roozbeh@farsiweb.info>
 
 	* fa.po: Updated Persian translation by
-	  Hamed Malek <hamed@farsiweb.info>.
+	Hamed Malek <hamed@farsiweb.info>.
 
 2005-03-09  Ahmad Riza H Nst  <ari@160c.afraid.org>
 
@@ -3051,7 +3084,7 @@ Fri Jun 29 2007  Matthias Clasen  <mclasen@redhat.com>
 
 2004-11-21  David Lodge <dave@cirt.net>
 
-        * en_GB.po: Updated British translation.
+	* en_GB.po: Updated British translation.
 
 2004-11-20  Laurent Dhima  <laurenti@alblinux.net>
 
@@ -3294,8 +3327,8 @@ Sun Jul 18 18:03:08 2004  Soeren Sandmann  <sandmann@daimi.au.dk>
 
 2004-04-08  Guntupalli Karunakar  <karunakar@freedomink.org>
 
-        * gu.po: Added Gujurati translation by
-        Gujarati Team <magnet@magnet-i.com>.
+	* gu.po: Added Gujurati translation by
+	Gujarati Team <magnet@magnet-i.com>.
 
 2004-04-07  Iñaki Larrañaga  <dooteo@euskalgnu.org>
 
@@ -3395,7 +3428,7 @@ Mon Mar  1 16:49:51 2004  Owen Taylor  <otaylor@redhat.com>
 2004-02-23  Guntupalli Karunakar  <karunakar@freedomink.org>
 
 	* ta.po: Updated Tamil translation by
-	 Dinesh Nadarajah <dinesh_list@sbcglobal.net>
+	Dinesh Nadarajah <dinesh_list@sbcglobal.net>
 
 2004-02-20  Laurent Dhima  <laurenti@alblinux.net>
 
@@ -3517,7 +3550,7 @@ Mon Mar  1 16:49:51 2004  Owen Taylor  <otaylor@redhat.com>
 2003-11-10  Pablo Gonzalo del Campo  <pablodc@bigfoot.com>
 
 	* es.po: Updated Spanish translation by
-                 Francisco Javier F. Serrador <serrador@arrakis.es>.
+	Francisco Javier F. Serrador <serrador@arrakis.es>.
 
 2003-10-31  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -3527,7 +3560,7 @@ Mon Mar  1 16:49:51 2004  Owen Taylor  <otaylor@redhat.com>
 
 	* ja.po: Updated Japanese translation.
 
-2003-10-19   Vincent van Adrighem  <adrighem@gnome.org>
+2003-10-19  Vincent van Adrighem  <adrighem@gnome.org>
 
 	* nl.po: Dutch translation updated by Tino Meinen.
 
@@ -3817,7 +3850,7 @@ Tue Dec  3 20:40:56 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-11-25  Hasbullah Bin Pit <sebol@ikhlas.com>
 
-        * ms.po: Updated Malay Translation.
+	* ms.po: Updated Malay Translation.
 
 2002-11-22  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -3841,7 +3874,7 @@ Tue Dec  3 20:40:56 2002  Owen Taylor  <otaylor@redhat.com>
 	* be.po: Added Belarusian translation
 	* from Belarusian team <i18n@infonet.by>.
 
-2002-10-13  Laurent Dhima   <laurenti@alblinux.net>
+2002-10-13  Laurent Dhima  <laurenti@alblinux.net>
 
 	* sq.po:  added albanian translation
 
@@ -3888,9 +3921,9 @@ Tue Dec  3 20:40:56 2002  Owen Taylor  <otaylor@redhat.com>
 
 Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
- 	* README.translators: Add from GTK+.
+	* README.translators: Add from GTK+.
 
- 	* *.po: Convert all po files to UTF-8.
+	* *.po: Convert all po files to UTF-8.
 
 2002-05-18  Christian Rose  <menthos@menthos.com>
 
@@ -3898,7 +3931,7 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-05-16  Duarte Loreto <happyguy_pt@hotmail.com>
 
-        * pt.po: Updated Portuguese translation.
+	* pt.po: Updated Portuguese translation.
 
 2002-05-12  Christophe Merlet  <christophe@merlet.net>
 
@@ -3914,7 +3947,7 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-04-30  Duarte Loreto <happyguy_pt@hotmail.com>
 
-        * pt.po: Converted Portuguese translation to UTF-8.
+	* pt.po: Converted Portuguese translation to UTF-8.
 
 2002-04-29  Pablo Saratxaga  <pablo@mandrakesoft.com>
 
@@ -3937,7 +3970,7 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 2002-03-31  Abel Cheung  <maddog@linux.org.hk>
 
 	* zh_TW.po: Updated traditional Chinese translation, and removed
-	  all positional parameters :(
+	all positional parameters :(
 
 2002-03-28  Valek Filippov <frob@df.ru>
 
@@ -3965,11 +3998,11 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-03-06  Germ� Poo-Caamao <gpoo@ubiobio.cl>
 
-        * es.po: Updated spanish translation.
+	* es.po: Updated spanish translation.
 
 2002-03-04  Duarte Loreto <happyguy_pt@hotmail.com>
 
-        * pt.po: Updated Portuguese translation.
+	* pt.po: Updated Portuguese translation.
 
 2002-03-03  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -4095,7 +4128,8 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-01-28  Roy-Magne Mo <rmo@sunnmore.net>
 
-        * nn.po: Updated Norwegian (nynorsk) translation and switched to UTF-8.
+	* nn.po: Updated Norwegian (nynorsk) translation and
+	switched to UTF-8.
 
 2002-01-28  Christian Rose  <menthos@menthos.com>
 
@@ -4125,7 +4159,7 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2002-01-13  Hasbullah Bin Pit  <sebol@ikhlas.com>
 
-        * ms.po: Added Malay (Bahasa Melayu) translation.
+	* ms.po: Added Malay (Bahasa Melayu) translation.
 
 2002-01-11  Kjartan Maraas  <kmaraas@gnome.org>
 
@@ -4147,12 +4181,12 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 
 2001-12-27  Duarte Loreto <happyguy_pt@hotmail.com>
 
-        * pt.po: Added portuguese translation
+	* pt.po: Added portuguese translation
 
 2001-12-27  Jesus Bravo Alvarez  <jba@pobox.com>
 
 	* gl.po: Updated Galician translation from
-	  Manuel A. Fernandez Montecelo <manuel@sindominio.net>
+	Manuel A. Fernandez Montecelo <manuel@sindominio.net>
 
 2001-12-24  Vasif Ismailogu MD  <azerb_linux@hotmail.com>
 
@@ -4210,7 +4244,7 @@ Wed May 22 15:24:04 2002  Owen Taylor  <otaylor@redhat.com>
 2001-11-26  Jesus Bravo Alvarez  <jba@pobox.com>
 
 	* gl.po: Added Galician translation from
-	  Manuel A. Fern�dez Montecelo <manuel@sindominio.net>
+	Manuel A. Fern�dez Montecelo <manuel@sindominio.net>
 
 2001-11-23 Dirk-Jan C. Binnema <djcb@djcbsoftware.nl>
 
@@ -4322,7 +4356,7 @@ Wed Sep  5 09:27:34 2001  Owen Taylor  <otaylor@redhat.com>
 2001-09-05  Ross Golder  <ross@golder.org>
 
 	* Makefile.in.in: Updated from more recent gettext to fix
-	  problem with DESTDIR.
+	problem with DESTDIR.
 
 2001-09-02  Carlos Perell Mar� <carlos@gnome-db.org>
 
@@ -4408,11 +4442,8 @@ Wed Sep  5 09:27:34 2001  Owen Taylor  <otaylor@redhat.com>
 2001-02-08  Fatih Demir	<kabalak@kabalak.net>
 
 	* tr.po: Added the Turkish translation by
-                 Kemal Yilmaz.
+	Kemal Yilmaz.
 
 2001-01-18  Kjartan Maraas  <kmaraas@gnome.org>
 
 	* no.po: Added Norwegian translation.
-
-
-a
diff --git a/po/eu.po b/po/eu.po
index 678fb8a..b68611a 100644
--- a/po/eu.po
+++ b/po/eu.po
@@ -1,326 +1,321 @@
 # translation of eu.po to Basque
-# Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 #
 # Joseba Bidaurrazaga van Dierdonck <jepibi-san@ej-gv.es>, 2001.
 # Hizkuntza Politikarako Sailburuordetza <hizpol@ej-gv.es>, 2004.
-# Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>, 2004, 2005, 2006, 2008.
+# Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>, 2004, 2005, 2006, 2008, 2009.
 # Iñaki Larrañaga Murgoitio <dooteo@zundan.com>, 2007.
 msgid ""
 msgstr ""
 "Project-Id-Version: eu\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2008-08-30 12:45+0200\n"
+"POT-Creation-Date: 2009-02-10 16:51+0100\n"
+"PO-Revision-Date: 2009-02-10 17:15+0100\n"
 "Last-Translator: Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>\n"
 "Language-Team: Basque <itzulpena@euskalgnu.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms: nplurals=2; plural=(n != 1)\n"
+"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
 "\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "'%2$s' elementuaren ustekabeko '%1$s'atributua"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "'%2$s' elementuaren '%1$s' atributua ez da aurkitu"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Ustekabeko '%s' etiketa, '%s' espero zen"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "'%2$s' barruan ustekabeko '%1$s' etiketa"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
-msgstr ""
-"Ezin izan da baliozko laster-marken fitxategia aurkitu datuen direktorioan"
+msgstr "Ezin izan da baliozko laster-marken fitxategia aurkitu datuen direktorioan"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "'%s' URIaren laster-marka badago lehenedik ere"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "Ez da '%s' URIaren laster-markarik aurkitu"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "Ez dago '%s' URIaren laster-markan MIME-motarik definituta"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "'%s' URIaren laster-markan ez dago bandera pribaturik definituta"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "'%s' URIaren laster-markan ez dago talderik ezarrita"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr "'%s' izeneko aplikaziorik ez du erregistratu laster-markarik '%s'(e)n"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Huts egin du '%s' exekuzioko lerroa '%s' URIarekin hedatzean"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "'%s' karaktere-multzoa '%s' bihurtzea ez da onartzen"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "Ezin izan da '%s'(e)tik %s(e)rako bihurtzailea ireki"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "Byten sekuentzia baliogabea bihurketa-sarreran"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Errorea bihurtzean: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:951 ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296 ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "Karaktere-sekuentzia partziala sarreraren amaieran"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Ezin da '%s' atzerapena '%s' kode-multzo bihurtu"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "'%s' URIa ez da \"fitxategi\"-eskema erabiltzen duen URI absolutua"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "Baliteke '%s' URI fitxategi lokalak '#' ez edukitzea"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "'%s' URI baliogabea da"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "'%s' URIaren ostalari-izena baliogabea da"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "'%s' URIak ihes-karaktere baliogabeak ditu"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "'%s' bide-izena ez da bide-izen absolutua"
 
 #
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Ostalari-izen baliogabea"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Errorea '%s' direktorioa irekitzean: %s "
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Ezin izan dira %lu byte esleitu \"%s\" fitxategia irakurtzeko"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Errorea '%s' fitxategia irakurtzean: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "\"%s\" fitxategia handiegia da"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Ezin izan da '%s' fitxategitik irakurri: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Ezin izan da '%s' fitxategia ireki: %s "
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr ""
 "Ezin izan dira '%s' fitxategiko atributuak lortu, fstat() funtzioak huts "
 "egin du: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
-msgstr ""
-"Ezin izan da '%s' fitxategia ireki, fdopen() funtzioak huts egin du: %s"
+msgstr "Ezin izan da '%s' fitxategia ireki, fdopen() funtzioak huts egin du: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
 "Ezin izan da '%s' fitxategia '%s' gisa berrizendatu, g_rename() funtzioak "
 "huts egin du: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Ezin izan da '%s' fitxategia sortu: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr ""
 "Ezin izan da '%s' fitxategia idazteko ireki, fdopen() funtzioak huts egin "
 "du: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
-msgstr ""
-"Ezin izan da '%s' fitxategia idatzi, fwrite() funtzioak huts egin du: %s"
+msgstr "Ezin izan da '%s' fitxategia idatzi, fwrite() funtzioak huts egin du: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Ezin izan da '%s' fitxategia itxi, fclose() funtzioak huts egin du: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
-msgstr ""
-"'%s' fitxategia ezin izan da kendu, g_unlik() funtzioak huts egin du: %s"
+msgstr "'%s' fitxategia ezin izan da kendu, g_unlik() funtzioak huts egin du: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "'%s' txantiloia baliogabea da, ez luke '%s' eduki behar"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "'%s' txantiloiak ez dauka: XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Ezin izan da '%s' esteka sinbolikorik irakurri: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "Esteka sinbolikoak ez dira onartzen"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "Ezin izan da `%s'(e)tik `%s'(e)rako bihurtzailea ireki: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "Ezin dira datu gordinak irakurri 'g_io_channel_read_line_string'-en"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Irakurketa-bufferrean geratu diren bihurtu gabeko datuak"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "Kanala karaktere partzial batean bukatzen da"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "Ezin dira datu gordinak irakurri 'g_io_channel_read_to_end'-etik"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Ezin izan da '%s' fitxategia ireki, open() funtzioak huts egin du: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
-msgstr ""
-"Ezin izan da '%s' fitxategi-mapa ireki, mmap() funtzioak huts egin du: %s"
+msgstr "Ezin izan da '%s' fitxategi-mapa ireki, mmap() funtzioak huts egin du: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Errorea %d lerroko %d karakterean: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Errorea %d lerroan: %s"
 
-#: glib/gmarkup.c:493
-msgid ""
-"Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+#: ../glib/gmarkup.c:493
+msgid "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "'&;' entitatea hutsik dago; baliozko entitateak hauek dira: &amp; &quot; "
 "&lt; &gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -331,17 +326,17 @@ msgstr ""
 "entitate bat hasten du; & ikurrak entitatea izan behar ez badu, izenda ezazu "
 "&amp; gisa"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "'%s' karakterea ezin da erabili entitate-izenen barruan"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "'%s' entitate-izena ezezaguna da"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -349,7 +344,7 @@ msgstr ""
 "Entitatea ez da puntu eta komaz bukatzen; normalean & ikurra erabiltzen da "
 "entitatea hasteko asmorik gabe; izendatu & karakterea &amp; gisa;"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -358,18 +353,16 @@ msgstr ""
 "Ezin izan da '%-.*s' analizatu, digitu bat izan behar zuen karaktere-"
 "erreferentzia baten barruan (&#234; adibidez); agian digitua handiegia da"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
-msgstr ""
-"'%-.*s' karaktere-erreferentziak ez du baimendutako karaktere bat kodetzen"
+msgstr "'%-.*s' karaktere-erreferentziak ez du baimendutako karaktere bat kodetzen"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
-msgstr ""
-"Karaktere-erreferentzia hutsa, digitu bat eduki beharko luke; adibidez &#454;"
+msgstr "Karaktere-erreferentzia hutsa, digitu bat eduki beharko luke; adibidez &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -379,32 +372,32 @@ msgstr ""
 "erabiliko zenuen entitatea hasteko asmorik gabe. Izendatu & karakterea &amp; "
 "gisa;"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Amaitu gabeko entitate-erreferentzia"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Amaitu gabeko karaktere-erreferentzia"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "UTF-8 gisa kodetutako testu baliogabea - sekuentzia luzeegia"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "UTF-8 gisa kodetutako testu baliogabea - hasierako karaktererik gabe"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "UTF-8 gisa kodetutako testu baliogabea - '%s' ez da baliozkoa"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Dokumentuak elementu batez hasi behar du (adibidez, <book>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -413,7 +406,7 @@ msgstr ""
 "'%s' ez da karaktere balioduna '<' karakterearen atzetik; baliteke elementu "
 "baten izena ez hastea"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -422,15 +415,14 @@ msgstr ""
 "'%s' karaktere bitxia, '>' karakterea espero zen '%s' elementuaren etiketa "
 "hutsa amaitzeko"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
-msgid ""
-"Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
+msgid "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
 msgstr ""
 "'%s' karaktere bitxia, '=' espero zen '$2%s' elementuaren '$1%s' "
 "atributuaren ondoren"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -441,7 +433,7 @@ msgstr ""
 "hasiera-etiketa bukatzeko, edo bestela atributu bat. Agian karaktere "
 "baliogabea erabili duzu atributu-izen batean"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -450,7 +442,7 @@ msgstr ""
 "'%s' karaktere bitxia, komatxo irekia espero zen berdin ikurraren ondoren "
 "'$2%s' elementuaren '$1%s' atributuari balioa ematean"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -459,7 +451,7 @@ msgstr ""
 "'%s' ez da karaktere balioduna '</'; karaktereen atzetik; baliteke '%s'e(k) "
 "elementu baten izena ez hastea"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -468,25 +460,25 @@ msgstr ""
 "'%s' karaktere baliogabea da '%s' itxiera-elementuaren izenaren atzetik; "
 "baimendutako karakterea '>' da"
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "'%s' elementua itxi egin da, unean ez dago elementurik irekita"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "'%s' elementua itxi egin da, baina unean '%s' elementua dago irekita"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "Dokumentua hutsik dago edo zuriuneak bakarrik ditu"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "Dokumentua ustekabean itxi da angelu-parentesi ireki baten ondoren '<'"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -495,7 +487,7 @@ msgstr ""
 "Dokumentua ustekabean amaitu da oraindik irekita zeuden elementuekin. '%s' "
 "irekitako azken elementua da"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -504,20 +496,19 @@ msgstr ""
 "Dokumentua ustekabean amaitu da, angelu-parentesi itxia ikustea espero nuen <"
 "%s/> etiketa amaitzen"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Dokumentua ustekabean amaitu da elementu-izen baten barruan"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Dokumentua ustekabean amaitu da atributu-izen baten barruan"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
-msgstr ""
-"Dokumentua ustekabean amaitu da elementua irekitzeko etiketa baten barruan."
+msgstr "Dokumentua ustekabean amaitu da elementua irekitzeko etiketa baten barruan."
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -525,402 +516,400 @@ msgstr ""
 "Dokumentua ustekabean amaitu da atributu-izen baten ondorengo berdin "
 "ikurraren atzetik; ez dago atributu-baliorik"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "Dokumentua ustekabean amaitu da atributu-balio baten barruan"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
-msgstr ""
-"Dokumentua ustekabean amaitu da '%s' elementuaren itxiera-etiketaren barruan"
+msgstr "Dokumentua ustekabean amaitu da '%s' elementuaren itxiera-etiketaren barruan"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "Dokumentua ustekabean amaitu da iruzkin baten barruan edo prozesatzen ari "
 "zen instrukzio baten barruan"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "hondatutako objektua"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "barneko errorea edo hondatutako objektua"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "Memoriarik ez"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "atzera-jotzearen mugara gainditua"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
-msgstr ""
-"ereduak zenbait elementu ditu bat etortze partzialetan onartzen ez direnak"
+msgstr "ereduak zenbait elementu ditu bat etortze partzialetan onartzen ez direnak"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "barneko errorea"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr ""
 "aurreko erreferentizak baldintza gisa ez daude onartuta bat etortze "
 "partzialetan"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "errekurtsioaren muga gainditua"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "azpikate hutsen lan arearen muga gainditua"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "lerro-jauzien banderen baliogabeko konbinazioa"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "errore ezezaguna"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ ereduaren amaieran"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c ereduaren amaieran"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "karaktere ezezagunak jarraitzen dio \\ karaktereari"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr ""
 "hemen ez dira ihesdun letrak (\\l, \\L, \\u, \\U) erabiltzen uzten "
 "(maiuskulaz eta minuskulaz)"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "zenbakiak barrutitik kanpo {} kuantifikatzailean"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "zenbaki handiegiak {} kuantifikatzaileak"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "karaktere-klasearen amaierako ] falta da"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "karaktere-klasean baliogabeko ihes sekuentzia"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "karaktere-klaseko barrutia barrutitik kanpo"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "ezer ez errepikatzeko"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "karakete ezezaguna (? karaktereen atzetik"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "karakete ezezaguna (?< karaktereen atzetik"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "karakete ezezaguna (?P karaktereen atzetik"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "POSIX izeneko klaseak soilik onartzen dira klase baten barruan"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "amaierako ) falta da"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") dago irekierako ( gabe"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R edo (?[+-] digituak )-rekin jarraitu behar dira"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "existitzen ez den azpieredu baten erreferentzia"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "iruzkinaren ondoren ) falta da"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "adierazpen erregularra luzeegia"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "huts egin du memoria lortzean"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "'lookbehind' baieztapenak ez du luzera finkorik"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "gaizki osatutako zenbakia edo izena (?(-ren atzetik"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "baldintza taldeak bi adar baino gehiago ditu"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "baieztapena espero zen (?)-ren atzetik"
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "POSIX klasearen izen ezezaguna"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "Tartekatutako POSIX elementuak ez daude onartuta"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "\\x{...} sekuentziako karaktere-balioa luzeegia da"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "baliogabeko (?(0) baldintza"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C ez dago baimenduta 'lookbehind' baieztepenean"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "dei errekurtsiboa amaierarik gabeko begiztan sar daiteke"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "amaierako karakterea falta da azpiereduko izenean"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "bi azpiereduk izen berdina dute"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "gaizki osatutako \\P edo \\p sekuentzia"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "propietate-izen ezezaguna \\P edo \\p atzetik"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "azpiereduaren izena luzeegia (32 karaktere gehienez)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "izendun azpieredu gehiegi (10.000 gehienez)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "balio zortzitarra \\377 baino handiagoa"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE taldeak adar bat baino gehiago ditu"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "DEFINE taldea errepikatzea ez dago onartuta"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "NEWLINE aukera kontraesankorra"
 
-#: glib/gregex.c:333
-msgid ""
-"\\g is not followed by a braced name or an optionally braced non-zero number"
+#: ../glib/gregex.c:333
+msgid "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "\\g ez da prestatutako izenarekin edo zero ez den aukerazko prestatutako "
 "zenbaki batekin jarraitzen"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "ustekabeko begizta"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "kodea gainezkatua"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "konpilazioaren laneko area gainezkatua"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "ez da aurrez egiaaztatutako erreferentziatutako azpieredua aurkitu"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Errorea %s adierazpen erregularra bilatzean: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "PCRE liburutegia UTF8 euskarri gabe konpilatua"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "PCRE liburutegia UTF8 propietateen euskarri gabe konpilatua"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "Errorea %s adierazpen erregularra %d karakterean konpilatzean: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Errorea %s adierazpen erregularra optimizatzean: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "digitu hamaseitarra edo '}' espero zen"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "digitu hamaseitarra espero zen"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "'<' falta da erreferentzia sinbolikoan"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "amaitu gabeko erreferentzia sinbolikoa"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "zero luzerako erreferentzia sinbolikoa"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "digitua espero zen"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "erreferentzia sinboliko ilegala"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "'\\' katearen amaieran"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "ihes-sekuentzi ezezaguna"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "Errorea ordezko \"%s\" testua analizatzean %lu karakterean: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Komatxo arteko testua ez da komatxoekin hasten"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr ""
 "Bat ez datozen komatxoak daude komando-lerroan edo shell-ak aipatutako beste "
 "testu batean"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "Testua '\\' karakterearen atzetik amaitu da (testua '%s' zen)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
-msgstr ""
-"Testua %c(r)en komatxoak aurkitu baino lehen amaitu da (testua '%s' zen)"
+msgstr "Testua %c(r)en komatxoak aurkitu baino lehen amaitu da (testua '%s' zen)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "Testua hutsik dago (edo zuriuneak bakarrik ditu)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Ezin izan da daturik irakurri prozesu umetik"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr "Ezin izan da kanalizazioa sortu prozesu umearekin komunikatzeko (%s) "
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Ezin izan da kanalizazio umetik irakurri (%s) "
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Ezin izan da '%s' direktoriora aldatu (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Ezin izan da prozesu umea exekutatu (%s)"
 
 #
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Programaren izen baliogabea: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Kate baliogabea %d(e)ko bektorearen argumentuan: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Kate baliogabea ingurunean: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Laneko direktorio baliogabea: %s"
 
 #
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Ezin izan da laguntza-programa exekutatu (%s)"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -928,189 +917,188 @@ msgstr ""
 "Ustekabeko errorea gertatu da 'g_io_channel_win32_poll()'-en prozesu umetik "
 "datuak irakurtzean"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Ezin izan da daturik irakurri prozesu umetik (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr "Ustekabeko errorea select()-en, datuak prozesu umetik irakurtzen (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Ustekabeko errorea waitpid()-en (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "Ezin da sardetu (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Ezin izan da \"%s\" prozesu umea exekutatu (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "Ezin izan da prozesu umearen irteera edo sarrera birbideratu (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Ezin izan da prozesu umea sardetu (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Errore ezezaguna \"%s\" prozesu umea exekutatzean"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Ezin izan da nahikoa datu irakurri pid kanalizazio umetik (%s)"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "Karakterea UTF-8 barrutitik kanpo"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123 ../glib/gutf8.c:1132 ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273 ../glib/gutf8.c:1414 ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "Sekuentzia baliogabea bihurketa-sarreran"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425 ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "Karakterea UTF-16 barrutitik kanpo"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Erabilera:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[AUKERA...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Laguntzako aukerak:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Erakutsi laguntzako aukerak"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Erakutsi laguntzako aukera guztiak"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Aplikazio-aukerak:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Ezin da '%2$s'(r)en '%1$s' osoko balioa analizatu"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "%2$s(r)en '%1$s' osoko balioa barrutitik kanpo"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Ezin da '%2$s'(r)en '%1$s' balio bikoitza analizatu"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "%2$s(r)en '%1$s' balio bikoitza barrutitik kanpo"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Errorea %s aukera analizatzean"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "%s(e)ko argumentua falta da"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "%s aukera ezezaguna"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "Ezin izan da baliozko gakoa datuen direktorioan aurkitu"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Ez da fitxategi arrunta"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "Fitxategia hutsik dago"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
-msgid ""
-"Key file contains line '%s' which is not a key-value pair, group, or comment"
+msgid "Key file contains line '%s' which is not a key-value pair, group, or comment"
 msgstr ""
 "Gako-fitxategiak '%s' lerroa du, gako-balioa bikotea, taldea edo iruzkinik "
 "ez daukalarik"
 
 #
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Taldearen izen baliogabea: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "Gako-fitxategiak ez da talde batekin hasten"
 
 #
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Gakoaren izen baliogabea: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Gako-fitxategiak onartzen ez den '%s' kodeketa du"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Gako-fitxategiak ez dauka '%s' taldea"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "Gako-fitxategiak ez dauka '%s' gakoa"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "Gako-fitxategiak '%s' gakoa dauka (%s balioduna) baina ez da UTF-8"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr ""
 "Gako-fitxategiak '%s' gakoa dauka, baina dagokion balioa ezin da "
 "interpretatu."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1119,145 +1107,146 @@ msgstr ""
 "Gako-fitxategiak '%s' gakoa dauka ('%s taldean), baina dagokion balioa ezin "
 "da interpretatu."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Gako-fitxategiak ez dauka '%s' gakoa ('%s' taldean)"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "Gako-fitxategiak ihes-karakterea dauka lerro amaieran"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Gako-fitxategiak '%s' ihes-sekuentzia baliogabea dauka"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "'%s' balioa ezin da zenbaki gisa interpretatu"
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "'%s' osoko balioa barrutitik kanpo"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "'%s' balioa ezin da zenbaki mugikor gisa interpretatu."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "'%s' balioa ezin da bolear gisa interpretatu"
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Zenbaketaren balio handiegia honi pasatuta: %s"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Korrontea jadanik itxita dago"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623 ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "Eragiketa bertan behera utzi da"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Mota ezezaguna"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "%s fitxategi mota"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "%s mota"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Ustekabeko korronte-amaiera azkarregia"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Izenbagea"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "Mahaigaineko fitxategiak ez du Exec eremua zehaztu"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Ezin izan da aplikazioak eskatzen duen terminala aurkitu"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
-msgstr ""
-"Ezin da erabiltzailearen aplikazioaren %s konfigurazio-karpeta sortu: %s"
+msgstr "Ezin da erabiltzailearen aplikazioaren %s konfigurazio-karpeta sortu: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Ezin da erabiltzailearen MIMEren %s konfigurazio-karpeta sortu: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Ezin da erabiltzailearen mahaigaineko %s fitxategia sortu"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "%s(r)en definizio pertsonalizatua"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "gailuak ez dauka 'egotzi' inplementatuta"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "gailuak ez dauka euskarria eskaneatzeko inplementaziorik"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "Ezin da GEmblem kodeketaren %d bertsioa kudeatu"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "Gaizki osatutako token kopurua (%d) GEmblem kodeketan"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr ""
+msgstr "Ezin da GEmblemedIcon kodeketaren %d bertsioa kudeatu"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr ""
+msgstr "Gaizki osatutako token kopurua (%d) GEmblemedIcon kodeketan"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
-
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+msgstr "GEmblen espero zen GEmblemedIcon-entzako"
+
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "Eragiketa ez dago onartuta"
 
@@ -1269,130 +1258,130 @@ msgstr "Eragiketa ez dago onartuta"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "Ontziaren muntaia ez da existitzen"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Ezin da direktorioaren gainean kopiatu"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "Ezin da direktorioa kopiatu direktorio gainean"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Helburuko fitxategia existitzen da"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "Ezin da direktorioa errekurtsiboki kopiatu"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Esteka sinbolikoaren baliogabeko balioa eman da"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "Zakarrontzira botatzea ez dago onartuta"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Fitxategi-izenek ezin dute '%c' eduki"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "bolumenak ez dauka muntatzea inplementatuta"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Ez da aplikaziorik erregistratu fitxategi hau kudeatzeko"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Zerrendatzailea itxi da"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "Fitxategiaren zerrendatzaileak eragiketa bat du lanean"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Fitxategiaren zerrendatzailea itxi da jadanik"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "fitxategia"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Ikonoa duen fitxategia"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "Ezin da GFileIcon kodeketaren %d bertsioa kudeatu"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "Gaizki osatutako sarrerako datuak GFileIcon-entzako"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Korronteak ez du query_info onartzen"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Ez da bilaketarik onartzen korrontean"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "Trunkatzea ez da baimentzen sarrerako korrontean"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Trunkatzea ez da onartzen korrontean"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "Okerreko token kopurua (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "Ez dago %s klasearen izen motarik"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "%s motak ez du GIcon interfazea inplementatzen"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "%s mota ez du klaserik"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "Gaizko osatutako bertsio zenbakia: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
+msgstr "%s motak ez du from_tokens() inplementatzen GIcon interfazean"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "Ezin da ikonoaren kodeketaren emandako bertsioa kudeatu"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "Sarrerako korronteak ez dauka irakurtzea inplementatuta"
 
@@ -1402,361 +1391,360 @@ msgstr "Sarrerako korronteak ez dauka irakurtzea inplementatuta"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Korronteak eragiketa bat du lanean"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Ezin da lokaleko direktorio lehenetsiaren monitorizazio mota aurkitu"
 
 #
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "%s fitxategi-izen baliogabea"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Errorea fitxategi-sistemako informazioa lortzean: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Ezin da erroko direktorioa izenez aldatu"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Errorea fitxategia izenez aldatzean: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "Ezin da fitxategia izenez aldatu, fitxategi-izena badago lehendik ere"
 
 #
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "Fitxategi-izen baliogabea"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Errorea fitxategia irekitzean: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "Ezin da direktorioa ireki"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Errorea fitxategia kentzean: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Errorea fitxategia zakarrontzira botatzean: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Ezin izan da zakarrontziaren '%s' direktorioa sortu: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Ezin da zakarrontziaren goi-mailako direktorioa aurkitu"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Ezin da zakarrontziaren direktorioa aurkitu edo sortu"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Ezin da zakarrontziaren informazio-fitxategia sortu: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Ezin da fitxategia zakarrontzira bota: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Errorea direktorioa sortzean: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Errorea esteka sinbolikoa sortzean: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Errorea fitxategia lekuz aldatzean: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "Ezin da direktorioa lekuz aldatu direktorioaren gainera"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833 ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864 ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "Huts egin du babeskopia sortzean"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Errorea helburuko fitxategia kentzean: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "Muntaien artean lekuz aldatzea ez dago onartuta"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Atributuaren balioa NULL ezin da izan"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Atributu mota baliogabea (katea espero zen)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Atributu hedatuaren izen baliogabea"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Errorea '%s' atributu hedatua ezartzean: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464 ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Errorea '%s' fitxategiaren egoera irakurtzean: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (baliogabeko kodeketa)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "Errorea fitxategiaren deskriptorearen egoera irakurtzean: %s "
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Baliogabeko atributu mota (uint32 espero zen)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Baliogabeko atributu mota (uint64 espero zen)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784 ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Baliogabeko atributu mota (byte katea espero zen)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Errorea baimenak ezartzean: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880 ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Errorea jabea ezartzean: %s"
 
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "esteka sinbolikoak NULL-en desberdina izan behar du"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913 ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Errorea esteka sinbolikoa ezartzean: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
-msgstr ""
-"Errorea esteka sinbolikoa ezartzean: fitxategia ez da esteka sinboliko bat"
+msgstr "Errorea esteka sinbolikoa ezartzean: fitxategia ez da esteka sinboliko bat"
 
-#: gio/glocalfileinfo.c:2071
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
 msgstr "SELinux testuinguruak NULL-en desberdina izan behar du"
 
-#: gio/glocalfileinfo.c:2086
+#: ../gio/glocalfileinfo.c:2086
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Errorea SELinux testuingurua ezartzean: %s"
 
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
 msgstr "SELinux ez dago gaituta sistema honetan"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "%s atributuaren ezarpena ez dago onartuta"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Errorea fitxategitik irakurtzean: %s "
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Errorea fitxategian bilatzean: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Errorea fitxategia ixtean: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Ezin da lokaleko fitxategi lehenetsiaren monitorizazio mota aurkitu"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Errorea fitxategian idaztean: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Errorea babeskopiaren esteka zaharra kentzean: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Errorea babeskopiaren kopia sortzean: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Errorea aldi baterako fitxategia izenez aldatzean: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Errorea fitxategia trunkatzean: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688 ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Errorea '%s' fitxategia irekitzean: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "Helburuko fitxategia direktorio bat da"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "Helburuko fitxategia ez da fitxategi arrunta"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "Fitxategia kanpotik aldatu da"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "Baliogabeko GSeekType eman da"
 
 #
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Bilaketa-eskaera baliogabea"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "Ezin da GMemoryInputStream trunkatu"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "Datu-matrizearen gehienezko mugara iritsi da"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "Ezin da memoriaren irteeraren korrontea tamainaz aldatu"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Huts egin du memoriaren irteeraren korrontea tamainaz aldatzean"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "muntaiak ez dauka desmuntatzea inplementatuta"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "muntaiak ez dauka egoztea inplementatuta"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "muntaiak ez dauka birmuntaketa inplementatuta"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "muntaiak ez dauka eduki mota sinkronoa asmatzea inplementatuta"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "muntaiak ez dauka eduki mota sinkronoa asmatzea inplementatuta"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "Irteerako korronteak ez dauka idaztea inplementatuta"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "Iturburuko korrontea jadanik itxi da"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "izena"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Ikonoaren izena"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "izenak"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Ikonoen izenak dituen matrizea"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "erabili ikono lehenetsiak"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1765,86 +1753,86 @@ msgstr ""
 "erabiliko diren ala ez. Aurrenekoaren ondoren dauden izenak baztertzen ditu "
 "hainbat izen ematen badira."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "Ezin da GThemedIcon kodeketaren %d bertsioa kudeatu"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "Fitxategi-deskriptorea"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "Fitxategi-deskriptorea bertatik irakurtzeko"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
-msgstr "Errorea fitxategiaren deskriptorearen egoera irakurtzean: %s "
+msgstr "Itxi fitxategi-deskriptorea"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
-msgstr ""
+msgstr "Fitxategi-deskriptorea ixtea korrontea ixtean edo ez."
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Errorea UNIXetik irakurtzean: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Errorea UNIX ixtean: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Fitxategi-sistemaren erroa"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "Fitxategi-deskriptorea bertan idazteko"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Errorea UNIXen idaztean: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "bolumenak ez dauka egoztea inplementatuta"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Ezin da aplikazioa aurkitu"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Errorea aplikazioa abiaraztean: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URIak ez daude onartuta"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "asoziazioaren aldaketak ez dira onartzen win32 sisteman"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "Asoziazioa sortzea ez da onartzen win32 sisteman"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "ez ezkutatu sarrerak"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "erabili zerrenda-formatu luzea"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[FITXATEGIA...]"
+
diff --git a/po/gu.po b/po/gu.po
index ffab7cf..906ce85 100644
--- a/po/gu.po
+++ b/po/gu.po
@@ -1,19 +1,20 @@
 # translation of glib.HEAD.gu.po to Gujarati
 # Ankit Patel <ankit644@yahoo.com>, 2005, 2006.
 # Ankit Patel <ankit@redhat.com>, 2007, 2008.
+# Sweta Kothari <swkothar@redhat.com>, 2009.
 msgid ""
 msgstr ""
 "Project-Id-Version: glib.HEAD.gu\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2008-03-03 14:10+0530\n"
-"Last-Translator: Ankit Patel <ankit@redhat.com>\n"
-"Language-Team: Gujarati <fedora-trans-gu@redhat.com>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=glib&component=general\n"
+"POT-Creation-Date: 2009-02-03 11:56+0000\n"
+"PO-Revision-Date: 2009-02-04 14:19+0530\n"
+"Last-Translator: Sweta Kothari <swkothar@redhat.com>\n"
+"Language-Team: Gujarati\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms:  nplurals=2; plural=(n!=1);\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n"
 "\n"
 "\n"
 "\n"
@@ -27,294 +28,293 @@ msgstr ""
 "\n"
 "\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "ઘટક '%s' માટે અનિચ્છનીય લક્ષણ '%s'"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "ઘટક '%s' નું લક્ષણ '%s' મળ્યું નહિં"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "અનિચ્છનીય ટેગ '%s', ટેગ '%s' ઈચ્છિત"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "અનિચ્છનીય ટેગ '%s' એ '%s' માં"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "માહિતી ડિરેક્ટરીઓ માટે કોઈ માન્ય બુકમાર્ક ફાઈલ મળી નહિં"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "URI '%s' માટેની બુકમાર્ક પહેલાથી જ હાજર છે"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "URI '%s' માટે કોઈ બુકમાર્ક મળી નહિં"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "URI '%s' માટે બુકમાર્કમાં કોઈ MIME પ્રકાર વ્યાખ્યાયિત નથી"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "URI '%s' માટે બુકમાર્કમાં કોઈ ખાનગી ફ્લેગ વ્યાખ્યાયિત થયેલ નથી"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "URI '%s' માટે બુકમાર્કમાં કોઈ જૂથો સુયોજિત નથી"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr "'%s' નામવાળા કોઈ કાર્યક્રમે '%s' માટે બુકમાર્ક રજીસ્ટર કરી નથી"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "exec લીટી '%s' ને URI '%s' સાથે વિસ્તારવામાં નિષ્ફળ"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "'%s' અક્ષર સમૂહમાંથી '%s' માં રુપાંતરણ માટે આધાર નથી"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "'%s' માંથી '%s' માટેનો પરીવર્તક ખોલી શકતો નથી"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "રુપાંતર ઈનપુટની બાઇડ શ્રેણી અપ્રમાણીત છે"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "રુપાંતર વખતે ભૂલ: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:951 ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296 ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "ઈનપુટ ના છેડા પર અપૂર્ણ અક્ષર શ્રેણી છે"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "ફૈલબેક '%s' ને '%s' કોડના સમૂહમાં પરીવર્તિત કરી શકાતું નથી "
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "URI '%s' કે જે \"ફાઈલ\" યોજના વાપરે છે તે ચોક્કસ URI નથી"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "સ્થાનીય ફાઈલ URI '%s' માં કદાય '#' સમાવિષ્ટ નથી"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "'%s' URI અયોગ્ય છે"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "'%s' URIનું યજમાનનુ નામ અયોગ્ય છે"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "'%s' URI અયોગ્ય બહાર નીકળવાના અક્ષરો ધરાવે છે "
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "'%s' પથ નામ એ ચોક્કસ પથ નથી"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "અયોગ્ય યજમાન નામ"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "'%s' ડિરેક્ટરી ખોલતા ભૂલ: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "%lu બાઈટ \"%s\" ફાઈલ વાંચવા માટે આપવામાં આવતા નથી"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "'%s' ફાઈલ વાંચતી વખતની ભૂલ: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
-msgstr ""
+msgstr "ફાઇલ \"%s\" એ ઘણી વિશાળ છે"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "'%s' ફાઈલમાંથી વાંચવામા નિષ્ફળતા:  %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "'%s' ફાઈલ ખોલવામાં નિષ્ફળતા : %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr "'%s' ફાઈલની લાક્ષણિકતા મેળવતી વખતે નિષ્ફળતા: fstate() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "'%s' ફાઈલ ખોલવામાં નિષ્ફળતા: fdopen() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr "ફાઈલ '%s' નું નામ '%s' માં બદલવામાં નિષ્ફળ: g_rename() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "'%s' ફાઈલ બનાવવામાં નિષ્ફળતા : %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr "ફાઈલ '%s' ને લખવા માટે ખોલવામાં નિષ્ફળ: fdopen() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "ફાઈલ '%s' પર લખવામાં નિષ્ફળ: fwrite() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "ફાઈલ '%s' બંધ કરવામાં નિષ્ફળ: fclose() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr "વર્તમાન ફાઈલ '%s' દૂર કરી શકાઈ નહિં: g_unlink() નિષ્ફળ: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr " '%s' ટેમ્પલેટ અયોગ્ય છે, તે '%s' ધરાવતું નથી"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "ટેમ્પલેટ '%s' એ XXXXXX સમાવતું નથી"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "'%s' સાંકેતિક કડી વાંચવામાં નિષ્ફળતા: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "સાંકેતિક કડી આધાર આપતી નથી"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "'%s' માંથી '%s' માટેનું રુપાંતરક ખોલી શકાયું નહિં: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "g_10_channe_lread_line_string માં આડી હરોળ માં વાંચી શકાતું નથી"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
-msgstr ""
-"વાંચવા માટેના બફર(થોડા સમય માટેનું સંગ્રહસ્થાન) માં ઢાંકેલી ન હોય તે માહિતી છોડી દીધેલ છે"
+msgstr "વાંચવા માટેના બફર(થોડા સમય માટેનું સંગ્રહસ્થાન) માં ઢાંકેલી ન હોય તે માહિતી છોડી દીધેલ છે"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "માધ્યમ અપુર્ણ અક્ષરથી અંત પામે છે"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "g_io_channel_read_to_end માં આડી હરોળ વાંચી શકાતી નથી"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "ફાઈલ '%s' ખોલવામાં નિષ્ફળ: open() નિષ્ફળ: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "ફાઈલ '%s' નો નકશો કરવામાં નિષ્ફળ: mmap() નિષ્ફળ: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "%d લીટી પર %d અક્ષરમાં ભૂલ: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "%d લીટી પર ભૂલ: %s"
 
-#: glib/gmarkup.c:493
-msgid ""
-"Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+#: ../glib/gmarkup.c:493
+msgid "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr "'&;' વસ્તુ ખાલી દેખાય છે: યોગ્ય વસ્તુઓ છે:&amp; &quot; &lt; &gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -324,17 +324,17 @@ msgstr ""
 "વસ્તુ નામ શરુ થાય ત્યાં %s' અક્ષર યોગ્ય નથી: & અક્ષર વસ્તુની શરુઆત કરે છે; જો તે એમપરસંડ "
 "વસ્તુ ને આધાર ન આપે તો તે &amp; તરીકે દર્શાવો"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr " વસ્તુ નામની અંદર '%s' અક્ષર યોગ્ય નથી"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "'%s' વસ્તુ નામ જાણીતુ નથી"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -342,7 +342,7 @@ msgstr ""
 "વસ્તુ નો સેમીકોલન સાથે અંત થતો નથી; ઘણી વખતે એમપરસંડ(&) અક્ષર ચિન્હ વગર તમે વસ્તુ વાપરી "
 "શકો છો- એમપરસંડ &amp; તરીકે લો"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -351,16 +351,16 @@ msgstr ""
 "'%-.*s' નું પદચ્છેદન કરવામાં નિષ્ફળ, કે જે અક્ષર સંદર્ભમાં અંક હોવો જોઈએ (&#234; ઉદાહરણ "
 "તરીકે) - કદાચ અંક ખૂબ લાંબો હોય"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "અક્ષર સંદર્ભ '%-.*s' પરવાનગી આપેલ અક્ષરને એનકોડ કરતો નથી"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "ખાલી અક્ષર સંદર્ભ; સંખ્યા જેવી કે &#454; ને સમાવતી હોવી જોઇએ "
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -369,52 +369,51 @@ msgstr ""
 "અક્ષર સંદર્ભ અર્ધવિરામ થી અંત થતો નથી; તમે વસ્તુ શરુ કરવા એમપરસંડ અક્ષર ને વાપરો એમપરસંડ "
 "ને &amp; તરીકે લો"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "અપુર્ણ વસ્તુ સંદર્ભ "
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "અપુર્ણ અક્ષર સંદર્ભ "
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "અયોગ્ય UTF-8 સંગ્રહપદ્ધતિવાળું લખાણ - overlong ક્રમ"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "અયોગ્ય UTF-8 સંગ્રપદ્ધતિવાળું લખાણ - સ્ટાર અક્ષર નથી"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "અયોગ્ય UTF-8 સંગ્રહપદ્ધતિવાળું લખાણ - માન્ય '%s' નથી"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "દસ્તાવેજ કોઈ વસ્તુ સાથે શરુ થાય તે જરુરી છે(ઉદાહરણ <book>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
 "element name"
 msgstr "'%s' એ '<' અક્ષર પછી આવતો યોગ્ય અક્ષર નથી; તે કોઈ વસ્તુના નામથી શરુ થતુ નથી"
 
-#: glib/gmarkup.c:1276
-#, fuzzy, c-format
+#: ../glib/gmarkup.c:1276
+#, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
 "s'"
-msgstr "અસંગત અક્ષર '%s', વસ્તુ '%s' ની શરુઆત ટેગ ને સમાપ્ત કરવા '>' અક્ષર ની આશા છે"
+msgstr "અસંગત અક્ષર '%s', વસ્તુ ટેગ '%s' નાં ખાલી ઘટક ને સમાપ્ત કરવા '>' અક્ષર ની આશા છે"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
-msgid ""
-"Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
+msgid "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
 msgstr "અસંગત અક્ષર '%s', '%s' વસ્તુના '%s' લાક્ષણિકતા નામ પછી '=' જરુરી છે"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -424,7 +423,7 @@ msgstr ""
 "અસંગત અક્ષર '%s': '%s' વસ્તુના અંતમાં '>' અથવા '/' અથવા પરીમાણનો વિકલ્પ જરુરી છે; તમે "
 "કદાય અયોગ્ય અક્ષર લાક્ષણિકતાના નામો વાપર્યો છે"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -433,46 +432,46 @@ msgstr ""
 "અસંગત અક્ષર '%s,  '%s' વસ્તુ માટે '%s' લાક્ષણિકતાના મુલ્ય આપતી વખતે બરાબરની નિશાની "
 "પછી શરુ થતો અવતરણ ચિહ્ન જરુરી છે"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
 "begin an element name"
 msgstr "'%s' એ '<' અક્ષર પછીનો યોગ્ય અક્ષર નથી ; '%s' ક્દાચ વસ્તુ નામ સાથે શરુ થતુ નથી"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
 "allowed character is '>'"
 msgstr "'%s' એ '%s' વસ્તુનામ પછીનો બંધ કરવાનો યોગ્ય અક્ષર નથી; '>' એ યોગ્ય અક્ષર છે. "
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "'%s' વસ્તુ બંધ હતી, અત્યારે એક પણ વસ્તુ ખુલ્લી નથી"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "'%s' વસ્તુ બંધ હતી, પણ અત્યારે '%s'એ ખુલ્લી વસ્તુ છે"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "દસ્તાવેજ ખાલી છે અથવા ફક્ત ખાલી જ્ગ્યા ધરાવે છે"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "'<' ચિન્હ વાપરતા પછી દસ્તાવેજનો અણધારી રીતે અંત આવે છે"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
 "element opened"
 msgstr "વસ્તુ ખુલ્લી હોવા છતાં દસ્તાવેજનો અણધારી રીતે અંત આવે છે- છેલ્લે ખોલેલ વસ્તુ '%s' છે"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -481,19 +480,19 @@ msgstr ""
 "દસ્તાવેજનો અણધારી રીતે અંત થાય છે, તે  અંતિમ ટેગ  <%s/> માં કૌંસને બંધ કરતુ ખૂણાનુ ચિન્હ "
 "જોવા માગે છે"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "વસ્તુ નામની અંદર દસ્તાવેજનો અણધારી રીતે અંત થાય છે"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "લાક્ષણિકતાના નામની અંદર દસ્તાવેજનો અણધારી રીતે અંત થાય છે"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
-msgstr "વસ્તુની શરુઆતની ટેગમા દસ્તાવેજનો અણધારી રીતે અંત થાય છે"
+msgstr "વસ્તુની શરુઆતની ટેગમા દસ્તાવેજનો અણધારી રીતે અંત થાય છે."
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -501,571 +500,569 @@ msgstr ""
 "લાક્ષણિકતા નામ પછીની બરાબરની નિશાની પછી દસ્તાવેજ નો અણધારી રીતે અંત થાય છે. "
 "લાક્ષણિકતાના મુલ્ય નથી"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "લાક્ષણિકતા મુલ્ય અંદર હોવા છતાં દસ્તાવેજ નો અણધારી રીતે અંત થાય છે"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "'%s' વસ્તુના બંદ ટેગની અંદર દસ્તાવેજનો અણધારી રીતે અંત થાય છે"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr "ટિપ્પણી અથવા પ્રક્રિયા સુચનાની અંદર અણધારી રીતે દસ્તાવેજનો અંત થાય છે"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "ભાંગી પડેલ ઓબ્જેક્ટ"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "આંતરિક ભૂલ અથવા બગડેલ ઓબ્જેક્ટ"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "મેમરી બહાર"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "પાછળ જવાની મર્યાદાએ પહોંચી ગયા"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr "ભાત અંશતઃ જોડણી માટે આધારભૂત વસ્તુઓ સમાવતી નથી"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "આંતરિક ભૂલ"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "શરતો તરીકે પાછળના સંદર્ભો અંશતઃ સરખામણી માટે આધારભૂત નથી"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "પુનરાવર્તન મર્યાદાએ પહોંચી ગયું"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "ખાલી શબ્દમાળાઓ માટે કાર્યસ્થળ મર્યાદાએ પહોંચી ગયા"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "નવીલીટી ફ્લેગોનું અયોગ્ય જોડકું"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "અજ્ઞાત ભૂલ"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ ભાતના અંતે"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c ભાતના અંતે"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "નહિં ઓળખાયેલ અક્ષર અનુસરે છે \\"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr "કેસ-બદલતા એસ્કેપો (\\l, \\L, \\u, \\U) અંહિ માન્ય નથી"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "{} ગણકમાં નંબરો હદ બહાર છે"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "{} ગણકમાં ખૂબ મોટી સંખ્યા"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "અક્ષર વર્ગ માટે અંત કરતો ] ગુમ છે"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "અક્ષર વર્ગમાં અયોગ્ય એસ્કેપ ક્રમ"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "અક્ષર વર્ગમાં ક્રમ વિસ્તારની બહાર છે"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "પુનરાવર્તન કરવા માટે કંઈ નથી"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "(? પછી નહિં ઓળખાતો અક્ષર"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "(?< પછી નહિં ઓળખાતો અક્ષર"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "(?P પછી નહિં ઓળખાતો અક્ષર"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "POSIX named વર્ગો માત્ર વર્ગમાં જ આધારભૂત છે"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "અંત કરતો ) ગુમ છે"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") એ ખૂલતા ( વિના છે"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R અથવા (?[+-]અંકો ) ને અનુસરતા જ હોવા જોઈએ"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "બિન-હયાત ઉપભાતનો સંદર્ભ"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "ટિપ્પણી પછી ગુમ થયેલ )"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "નિયમિત સમીકરણ ખૂબ મોટું છે"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "મેમરી મેળવવામાં નિષ્ફળ"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "lookbehind ગોઠવણ એ નિયમિત લંબાઈ નથી"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "(?( પછી મલીન નંબર અથવા નામ"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "શરતી જૂથ બે કરતાં વધુ શાખાઓ સમાવે છે"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "(?( પછી ઉમેરો ઈચ્છિત છે"
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "અજ્ઞાત POSIX વર્ગ નામ"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "POSIX ક્રમાંકિત ઘટકો આધારભૂત નથી"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "\\x{...} ક્રમમાંની અક્ષર કિંમત ખૂબ મોટી છે"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "અયોગ્ય શરત (?(0)"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C lookbehind ગોઠવણીમાં માન્ય નથી"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "પુનરાવર્તી કોલ અવ્યાખ્યાયિત લુપમાં જઈ શકે"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "ઉપભાત નામમાં ગુમ થયેલ અંત કરનાર"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "બે નામવાળી ઉપભાતોને એક જ નામ હોય છે"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "મલીન \\P અથવા \\p ક્રમ"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "\\P અથવા \\p પછી અજ્ઞાત ગુણધર્મ નામ"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "ઉપભાત નામ ખૂબ લાંબુ છે (મહત્તમ ૩૨ અક્ષરો)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "ઘણાબધા નામવાળી ઉપભાતો (મહત્તમ ૧૦,૦૦૦)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "અષ્ટાંક કિંમત \\377 કરતાં મોટી છે"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE જૂથ એક શાખા કરતાં વધુ સમાવે છે"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "DEFINE જૂથનું પુનરાવર્તન કરવાનું માન્ય નથી"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "વિચલ NEWLINE વિકલ્પો"
 
-#: glib/gregex.c:333
-msgid ""
-"\\g is not followed by a braced name or an optionally braced non-zero number"
-msgstr ""
-"\\g એ કૌંસવાળા નામ દ્વારા અનુસરવામાં આવતું નથી કે વૈકલ્પિક રીતે કૌંસવાળા બિન-શૂન્ય નંબરથી"
+#: ../glib/gregex.c:333
+msgid "\\g is not followed by a braced name or an optionally braced non-zero number"
+msgstr "\\g એ કૌંસવાળા નામ દ્વારા અનુસરવામાં આવતું નથી કે વૈકલ્પિક રીતે કૌંસવાળા બિન-શૂન્ય નંબરથી"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "અનિચ્છનિય પુનરાવર્તન"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "કોડ ઉભરાટ"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "વધુ પડતું કમ્પાઈલીંગ કાર્યસ્થળ"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "પહેલાં-ચકાસાયેલ સંદર્ભવાળી ભાત મળી નહિં"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "નિયમિત સમીકરણ %s સરખાવતી વખતે ભૂલ: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "PCRE લાઈબ્રેરી UTF8 આધાર વિના કમ્પાઈલ થયેલ છે"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "PCRE લાઈબ્રેરી UTF8 ગુણધર્મો આધાર વિના કમ્પાઈલ થયેલ છે"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "નિયમિત સમીકરણ %s ને કમ્પાઈલ કરવામાં અક્ષર %d આગળ ભૂલ: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "નિયમિત સમીકરણ %s શ્રેષ્ઠ બનાવતી વખતે ભૂલ: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "હેક્ઝાડેસીમલ અંક અથવા '}' ઈચ્છિત છે"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "હેક્ઝાડેસીમલ અંક ઈચ્છિત છે"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "સંજ્ઞાકીય સંદર્ભમાં '<' ગુમ થયેલ છે"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "અપૂર્ણ સંજ્ઞાકીય સંદર્ભ"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "શૂન્ય-લંબાઈ સંજ્ઞાકીય સંદર્ભ"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "અંક ઈચ્છિત"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "અયોગ્ય સંજ્ઞાકીય સંદર્ભ"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "સ્ટ્રે અંત '\\'"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "અજ્ઞાત એસ્કેપ ક્રમ"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "બદલી લખાણ \"%s\" નું પદચ્છેદન કરતી વખતે અક્ષર %lu આગળ ભૂલ: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "અવતરણ ચિહ્નવાળુ વાક્ય અવતરણ ચિહ્નથી શરુ થતુ નથી"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr "આદેશ વાક્યમાં અથવા બીજા શેલ ચિહ્નિત બંધબેસતા ન હોય તેવા અવતરણ ચિહ્ન"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "લખાણનો '\\' અક્ષર પછી તરત જ અંત આવે છે (લખાણનો '%s' હતુ)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr "%c માટે અવતરણ ચિહ્ન મળે તે પહેલા લખાણનો અંત થાય છે(લખાણ '%s' હતુ)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "વાક્ય ખાલી છે (અથવા તેમાં ફક્ત ખાલી જગ્યા છે)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "બાળ-પ્રક્રિયા માંથી માહિતી વાંચવા માં નિષ્ફળ છે"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr " (%s) બાળપ્રક્રિયા સાથે સંપર્ક માટે પાઈપ બનાવવામાં નિષ્ફળ"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "બાળ પાઈપ (%s)માંથી વાંચવામાં નિષ્ફળ"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "'%s' ડિરેક્ટરી બદલવામાં નિષ્ફળ(%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr " (%s) બાળપ્રક્રિયા ચલાવવામાં નિષ્ફળ"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "અયોગ્ય કાર્યક્રમ નામ: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "દલીલ વેક્ટરમાં %d આગળ અયોગ્ય શબ્દમાળા: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "પર્યાવરણમાં અયોગ્ય શબ્દમાળા: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "અયોગ્ય કામ આપતી ડિરેક્ટરી: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "મદદગાર કાર્યક્રમ (%s) ચલાવવામાં નિષ્ફળ"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
-msgstr ""
-"બાળ-પ્રક્રિયામાંથી માહિતી વાંચતી વખતે g_io_channel_win32_poll() માં આવતી અણધારી ભૂલ"
+msgstr "બાળ-પ્રક્રિયામાંથી માહિતી વાંચતી વખતે g_io_channel_win32_poll() માં આવતી અણધારી ભૂલ"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "(%s) બાળપ્રક્રિયામાંથી માહિતી વાંચવામાં નિષ્ફળ"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr "(%s)બાળપ્રક્રિયામાંથી માહિતી વાંચતી વખતે select() માં આવતી અણધારી ભૂલ"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "(%s) waitpid() માં અાવતી અણાધારી ભૂલ"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "(%s) બાળપ્રક્રિયા બનાવવામાં નિષ્ફળ"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "\"%s\"બાળપ્રક્રિયા ચલાવવામાં નિષ્ફળ (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "બાળપ્રક્રિયા (%s)ના ઈનપુટ અથવા આઉટપુટને ફરીથી દિશા આપવામાં નિષ્ફળ"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "બાળપ્રક્રિયા (%s)ની બાળપ્રક્રિયા બનાવવામાં નિષ્ફળ"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "\"%s\" બાળપ્રક્રિયા ચલાવતી વખતની અજ્ઞાત ભૂલ"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "(%s)બાળ pid પાઈપમાંથી જરુરી માહિતી વાંચવામાં નિષ્ફળ"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "અક્ષર UTF-૮ ની સીમાની બહાર"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123 ../glib/gutf8.c:1132 ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273 ../glib/gutf8.c:1414 ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "પરીવર્તિત ઈનપુટની અંદર અયોગ્ય શ્રેણી"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425 ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "UTF-૧૬ ની સીમાની બહાર નો અક્ષર"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "વપરાશ:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[OPTION...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "મદદ વિકલ્પો:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "મદદ વિકલ્પો બતાવો"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "બધા મદદ વિકલ્પો બતાવો"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "કાર્યક્રમ વિકલ્પો:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "પૂર્ણાંક કિંમત '%s' ને %s માટે પદચ્છેદન કરી શકતા નથી"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "પૂર્ણાંક કિંમત '%s' એ %s માટે મર્યાદા બહાર છે"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "બમણી કિંમત '%s' ને %s માટે પદચ્છેદિત કરી શકતા નથી"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "બમણી કિંમત '%s' જે %s માટે છે તે વિસ્તારની બહાર છે"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "ભૂલ પદચ્છેદન વિકલ્પ %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "%s માટેની દલીલ ગુમ થયેલ છે"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "અજ્ઞાત વિકલ્પ %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "શોધ ડિરેક્ટરીઓમાં માન્ય કી ફાઈલ શોધી શક્યા નહિં"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "નિયમિત ફાઈલ નથી"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "ફાઈલ ખાલી છે"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
-msgid ""
-"Key file contains line '%s' which is not a key-value pair, group, or comment"
+msgid "Key file contains line '%s' which is not a key-value pair, group, or comment"
 msgstr "કી ફાઈલ વાક્ય '%s' સમાવે છે કે જે કી-કિંમત જોડ, જૂથ, અથવા ટિપ્પણી નથી"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "અયોગ્ય જૂથ નામ: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "કી ફાઈલ જૂથ સાથે શરૂ થતી નથી"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "અયોગ્ય કી નામ: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "કી ફાઈલ બિનઆધારભૂત અક્ષર સંગ્રહપદ્ધતિ '%s' સમાવે છે"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "કી ફાઈલ પાસે જૂથ '%s' નથી"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "કી ફાઈલ પાસે કી '%s' નથી"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "કી ફાઈલ '%s' કીને કિંમત '%s' સાથે સમાવે છે કે જે UTF-8 નથી"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr "કી ફાઈલ '%s' કી સમાવે છે કે જેની પાસે કિંમત છે જે ઈન્ટરપ્રીટ કરી શકાતી નથી."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1074,144 +1071,146 @@ msgstr ""
 "કી ફાઈલ '%s' કી જૂથ '%s' માં સમાવે છે કે જેની પાસે કિંમત છે કે જે ઈન્ટરપ્રીટ કરી શકાતી "
 "નથી."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "કી ફાઈલ પાસે કી '%s' એ જૂથ '%s' માં નથી"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "કી ફાઈલ એસ્કેપ અક્ષર વાક્યના અંતે સમાવે છે"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "કી ફાઈલ અયોગ્ય એસ્કેપ ક્રમ '%s' સમાવે છે"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "કિંમત '%s' નંબર તરીકે ઈન્ટરપ્રીટ કરી શકાતું નથી."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "પૂર્ણાંક કિંમત '%s' એ મર્યાદાની બહાર છે"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "કિંમત '%s' એ અપૂર્ણાંક સંખ્યા તરીકે ઈન્ટરપ્રીટ કરી શકાતું નથી."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "કિંમત '%s' બુલિયન તરીકે ઈન્ટરપ્રીટ કરી શકાતું નથી."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "%s ને ખૂબ મોટી ગણક કિંમત પસાર કરેલ છે"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "સ્ટ્રીમ પહેલાથી જ બંધ થઈ ગયેલ છે"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623 ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "પ્રક્રિયા રદ થઈ ગઈ હતી"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "અજ્ઞાત પ્રકાર"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "%s ફાઈલપ્રકાર"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "%s પ્રકાર"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "સ્ટ્રીમનો-અંત અનિચ્છનીય રીતે જલદી"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "શીર્ષકવીહિન"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "ડેસ્કટોપ ફાઈલે Exec ક્ષેત્ર સ્પષ્ટ કરેલ નથી"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "કાર્યક્રમ માટે જરૂરી ટર્મિનલ શોધવામાં અસમર્થ"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "વપરાશકર્તા કાર્યક્રમ રૂપરેખાંકન ફોલ્ડર %s બનાવી શક્યા નહિં: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "વપરાશકર્તા MIME રૂપરેખાંકન ફોલ્ડર %s બનાવી શક્યા નહિં: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "વપરાશકર્તા ડેસ્કટોપ ફાઈલ %s બનાવી શકતા નથી"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "%s માટે વૈવિધ્યપૂર્ણ વ્યાખ્યા"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "ડ્રાઈવર બહાર કાઢો અમલમાં મૂકતું નથી"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "ડ્રાઈવ મીડિયા માટે પોલીંગને અમલમાં મૂકતું નથી"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "GEmblem એનકોડીંગ ની આવૃત્તિ %d ને સંભાળી શકાતી નથી"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "GEmblem એનકોડીંગ માં ટોકનો (%d) ની મેલફોર્મ થયેલ નંબર"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr ""
+msgstr "GEmblemedIcon એનકોડીંગ નાં આવૃત્તિ %d ને સંભાળી શકાતી નથી"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr ""
+msgstr "GEmblemedIcon એનકોડીંગ માં ટોકનો (%d) ની મેલફોર્મ થયેલ નંબર"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
-
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+msgstr "GEmblemedIcon માટે GEmblem એ અપેક્ષિત છે"
+
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "પ્રક્રિયા આધારભૂત નથી"
 
@@ -1223,131 +1222,130 @@ msgstr "પ્રક્રિયા આધારભૂત નથી"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "સમાવનાર માઉન્ટ અસ્તિત્વમાં નથી"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "ડિરેક્ટરી ઉપર નકલ કરી શકતા નથી"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "ડિરેક્ટરીને ડિરેક્ટરી ઉપર નકલ કરી શકતા નથી"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "લક્ષ્ય ફાઈલ અસ્તિત્વમાં નથી"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "પુનરાવર્તિત રીતે ડિરેક્ટરીની નકલ કરી શકતા નથી"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "અયોગ્ય સાંકેતિક કડી કિંમત અપાયેલ છે"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "કચરાપેટી આધારભૂત નથી"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "ફાઈલ નામો '%c' સમાવી શકતા નથી"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "વોલ્યુમ માઉન્ટ અમલમાં મૂકતું નથી"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "આ ફાઈલ સંભાળવા માટે કોઈ કાર્યક્રમ રજીસ્ટર થયેલ નથી"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "ઈન્યૂમેરેટર બંધ થયેલ છે"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "ફાઈલ ઈન્યૂમેરેટરને ભરપૂર પ્રક્રિયા છે"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "ફાઈલ ઈન્યૂમેરેટર પહેલાથી જ બંધ થયેલ છે"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
-msgstr ""
+msgstr "ફાઇલ"
 
-#: gio/gfileicon.c:146
-#, fuzzy
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
-msgstr "'%s' URIનું યજમાનનુ નામ અયોગ્ય છે"
+msgstr "ફાઇલ આઇકોનને સમાવી રહ્યુ છે"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "GFileIcon એનકોડીંગ ની આવૃત્તિ %d ને સંભાળી શકાતી નથી"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "GFileIcon માટે મેલફોર્મ થયેલ ઇનપુટ માહિતી"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "સ્ટ્રીમ query_info ને આધાર આપતું નથી"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "સ્ટ્રીમ પર પહોંચવાનું આધારભૂત નથી"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "ઈનપુટ સ્ટ્રીમ પર કાપવાનું માન્ય નથી"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "સ્ટ્રીમ પર કાપવાનું માન્ય નથી"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "ટોકનો (%d) નાં ખોટા નંબર"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "વર્ગ નામ %s માટે પ્રકાર નથી"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "પ્રકાર %s એ GIcon ઇન્ટરફેસ ને અમલમાં મૂકતો નથી"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "પ્રકાર %s એ વર્ગ થયેલ નથી"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "મેલફોર્મ થયેલ આવૃત્તિ નંબર: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
+msgstr "પ્રકાર %s એ GIcon ઇન્ટરફેસ પર tokens() માંથી અમલીકરણ થતુ નથી (_t)"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "આઇકોન એનકોડીંગ ની પૂરી પાડેલ આવૃત્તિ ને સંભાળી શકાતી નથી"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "ઈનપુટ સ્ટ્રીમ વાંચનને અમલમાં મૂકતું નથી"
 
@@ -1357,453 +1355,444 @@ msgstr "ઈનપુટ સ્ટ્રીમ વાંચનને અમલમ
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "સ્ટ્રીમને ભરપૂર પ્રક્રિયા છે"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "મૂળભૂત સ્થાનિક ડિરેક્ટરી મોનીટર પ્રકાર શોધવામાં અસમર્થ"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "અયોગ્ય ફાઈલનામ %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "ફાઈલસિસ્ટમ જાણકારી મેળવવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "રુટ ડિરેક્ટરીનું નામ બદલી શકતા નથી"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "ફાઈલનું નામ બદલવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "ફાઈલનું નામ બદલી શકતા નથી, ફાઈલનામ પહેલાથી જ હાજર છે"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "અયોગ્ય ફાઈલનામ"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "ફાઈલ ખોલવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "ડિરેક્ટરી ખોલી શકતા નથી"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "ફાઈલ દૂર કરવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "ફાઈલને કચરાપેટીમાં નાંખવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "કચરાપેટી ડિરેક્ટરી %s બનાવવામાં અસમર્થ: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "કચરાપેટી માટે ટોચસ્તરની ડિરેક્ટરી શોધવામાં અસમર્થ"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "કચરાપેટી ડિરેક્ટરી શોધવામાં કે બનાવવામાં અસમર્થ"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "કચરાપેટી જાણકારી ફાઈલ બનાવવામાં અસમર્થ: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "ફાઈલને કચરાપેટીમાં મોકલવામાં અસમર્થ: %s"
 
-#: gio/glocalfile.c:2025
-#, fuzzy, c-format
+#: ../gio/glocalfile.c:2025
+#, c-format
 msgid "Error creating directory: %s"
-msgstr "'%s' ડિરેક્ટરી ખોલતા ભૂલ: %s"
+msgstr "ડિરેક્ટરી બનાવવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "સાંકેતિક કડી બનાવવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "ફાઈલ ખસેડવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "ડિરેક્ટરીને ડિરેક્ટરી ઉપર ખસેડી શકતા નથી"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833 ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864 ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "બેકઅપ ફાઈલ બનાવટ નિષ્ફળ"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "લક્ષ્ય ફાઈલ દૂર કરવામાં ભૂલ: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "માઉન્ટો વચ્ચે ખસેડવાનું આધારભૂત નથી"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "લક્ષણ કિંમત બિન-શૂન્ય જ હોવી જોઈએ"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "અયોગ્ય લક્ષણ પ્રકાર (શબ્દમાળા ઈચ્છિત)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "અયોગ્ય વિસ્તૃત લક્ષણ નામ"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "વિસ્તૃત લક્ષણ '%s' સુયોજીત કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464 ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "ફાઈલ '%s' કહેવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (અયોગ્ય સંગ્રહપદ્ધતિ)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "ફાઈલ વર્ણનકાર કહેવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "અયોગ્ય લક્ષણ પ્રકાર (uint32 ઈચ્છિત)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "અયોગ્ય લક્ષણ પ્રકાર (uint64 ઈચ્છિત)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784 ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "અયોગ્ય લક્ષણ પ્રકાર (બાઈટ શબ્દમાળા ઈચ્છિત)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "પરવાનગીઓ સુયોજીત કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880 ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "માલિક સુયોજીત કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "સાંકેતિક કડી non-NULL જ હોવી જોઈએ"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913 ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "સાંકેતિક કડી સુયોજીત કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
 msgstr "સાંકેતિક કડી સુયોજીત કરવામાં ભૂલ: ફાઈલ સાંકેતિક કડી નથી"
 
-#: gio/glocalfileinfo.c:2071
-#, fuzzy
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
-msgstr "સાંકેતિક કડી non-NULL જ હોવી જોઈએ"
+msgstr "SELinux સંદર્ભ non-NULL જ હોવી જોઈએ"
 
-#: gio/glocalfileinfo.c:2086
-#, fuzzy, c-format
+#: ../gio/glocalfileinfo.c:2086
+#, c-format
 msgid "Error setting SELinux context: %s"
-msgstr "માલિક સુયોજીત કરવામાં ભૂલ: %s"
+msgstr "SELinux સંદર્ભ ને સુયોજન કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
-msgstr ""
+msgstr "SELinux એ આ સિસ્ટમ પર સક્રિય થયેલ નથી"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "લક્ષણ %s સુયોજીત કરવાનું આધારભૂત નથી"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "ફાઈલમાંથી વાંચવામાં ભૂલ: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "ફાઈલમાં પહોંચવામાં ભૂલ: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "ફાઈલ બંધ કરવામાં ભૂલ: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "મૂળભૂત સ્થાનિક ફાઈલ મોનીટર પ્રકાર શોધવામાં અસમર્થ"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "ફાઈલમાં લખવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "જૂની બેકઅપ કડી દૂર કરવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "બેકઅપ નકલ બનાવવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "કામચલાઉ ફાઈલનું નામ બદલવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "ફાઈલ કાપવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688 ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "ફાઈલ '%s' ખોલવામાં ભૂલ: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "લક્ષ્ય ફાઈલ ડિરેક્ટરી છે"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "લક્ષ્ય ફાઈલ નિયમિત ફાઈલ નથી"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "ફાઈલ બાહ્ય રીતે સુધારેલ હતી"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "અયોગ્ય GSeekType પૂરું પાડેલ"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "અયોગ્ય પહોંચ અરજી"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "GMemoryInputStream કાપી શકતા નથી"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "મહત્તમ માહિતી એરે મર્યાદાએ પહોંચ્યા"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "મેમરી આઉટપુટ સ્ટ્રીમનું માપ બદલી શકાય તેમ નથી"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "મેમરી આઉટપુટ સ્ટ્રીમનું માપ બદલવામાં નિષ્ફળ"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "માઉન્ટ એ અનમાઉન્ટને અમલમાં મૂકતું નથી"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "માઉન્ટ એ બહાર કાઢોને અમલમાં મૂકતું નથી"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "માઉન્ટ એ પુનઃમાઉન્ટને અમલમાં મૂકતું નથી"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
-#, fuzzy
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
-msgstr "માઉન્ટ એ અનમાઉન્ટને અમલમાં મૂકતું નથી"
+msgstr "માઉન્ટ એ સમાવિષ્ટ પ્રકાર અંદાજિત કરવાનું અમલીકરમ કરતુ નથી"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
-#, fuzzy
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
-msgstr "માઉન્ટ એ અનમાઉન્ટને અમલમાં મૂકતું નથી"
+msgstr "માઉન્ટ એ સમાવિષ્ટ પ્રકાર અંદાજિત કરવાનું એકી સાથે અમલીકરણ કરતુ નથી"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "આઉટપુટ સ્ટ્રીમ લેખનને અમલમાં મૂકતું નથી"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "સ્રોત સ્ટ્રીમ પહેલાથી જ બંધ થઈ ગયેલ છે"
 
-#: gio/gthemedicon.c:211
-#, fuzzy
+#: ../gio/gthemedicon.c:211
 msgid "name"
-msgstr "શીર્ષકવીહિન"
+msgstr "નામ"
 
-#: gio/gthemedicon.c:212
-#, fuzzy
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
-msgstr "'%s' URIનું યજમાનનુ નામ અયોગ્ય છે"
+msgstr "આઇકોનનું નામ"
 
-#: gio/gthemedicon.c:223
-#, fuzzy
+#: ../gio/gthemedicon.c:223
 msgid "names"
-msgstr "શીર્ષકવીહિન"
+msgstr "નામો"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
-msgstr ""
+msgstr "એરે એ આઇકોન નામો ને સમાવી રહ્યુ છે"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
-msgstr ""
+msgstr "મૂળભૂત ફોલબેકો ને વાપરો"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
 msgstr ""
+"ક્યાં તો '-' અક્ષરો પર નામ ને ટૂંકું કરવા દ્રારા મૂળભૂત ફોલબેકો ને વાપર્યો હોય. "
+"પહેલા પછીનાં નામો ને અવગણો જો ઘણાબધા નામો આપેલ હોય તો."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "GThemedIcon એનકોડીંગ ની આવૃત્તિ %d ને સંભાળી શકાતુ નથી"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "ફાઇલ વર્ણનકર્તા"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "માંથી વાંચવા માટે ફાઇલ વર્ણનકર્તા"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
-msgstr "ફાઈલ વર્ણનકાર કહેવામાં ભૂલ: %s"
+msgstr "ફાઇલ વર્ણનકર્તાને બંધ કરો"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
-msgstr ""
+msgstr "ક્યાંતો ફાઇલ વર્ણનકર્તા ને બંધ કરો જ્યારે સ્ટ્રીમ એ બંધ થયેલ છે"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "unix માંથી વાંચતી વખતે ભૂલ: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "unix બંધ કરતી વખતે ભૂલ: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "ફાઈલસિસ્ટમ રુટ"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "લખવા માટે ફાઇલ વર્ણનકર્તા"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "unix માં લખતી વખતે ભૂલ: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "વોલ્યુમ બહાર કાઢોને અમલમાં મૂકતું નથી"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "કાર્યક્રમ શોધી શકતા નથી"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "કાર્યક્રમ લાવતી વખતે ભૂલ: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URIs આધારભૂત નથી"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "સંડોવણી ફેરફારો win32 પર આધારભૂત નથી"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "સંડોવણી બનાવટ win32 પર આધારભૂત નથી"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "પ્રવેશો છુપાવો નહિં"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "લાંબી યાદી બંધારણ વાપરો"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[FILE...]"
 
-#~ msgid "%u byte"
-#~ msgid_plural "%u bytes"
-#~ msgstr[0] "%u બાઈટ"
-#~ msgstr[1] "%u બાઈટો"
diff --git a/po/ja.po b/po/ja.po
index 610ac5d..e8c2ad4 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -1,16 +1,16 @@
 # Japanese translation of glib.
-# Copyright (C) 2001-2008 Free Software Foundation, Inc.
+# Copyright (C) 2001-2009 Free Software Foundation, Inc.
 # Takayuki KUSANO <AE5T-KSN@asahi-net.or.jp>, 2001-2002.
 # KAMAGASAKO Masatoshi <emerald@gnome.gr.jp>, 2003.
-# Takeshi AIHANA <takeshi.aihana@gmail.com>, 2004-2008.
+# Takeshi AIHANA <takeshi.aihana@gmail.com>, 2004-2009.
 # Ryoichi INAGAKI <ryo1@bc.wakwak.com>, 2004.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: glib trunk\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2008-08-23 12:13+0900\n"
+"POT-Creation-Date: 2009-02-05 21:30+0900\n"
+"PO-Revision-Date: 2009-02-05 21:30+0900\n"
 "Last-Translator: Takeshi AIHANA <takeshi.aihana@gmail.com>\n"
 "Language-Team: Japanese <gnome-translation@gnome.gr.jp>\n"
 "MIME-Version: 1.0\n"
@@ -18,297 +18,301 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
-msgstr "想定外の属性 '%s' (要素 '%s') です"
+msgstr "'%s' は '%s' という要素に対して想定外の属性です"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
-msgstr "属性 '%s' (要素 '%s') がありません"
+msgstr "'%s' という属性は '%s' という要素にはありません"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
-msgstr "想定外のタグ '%s' です (想定していたタグは '%s')"
+msgstr "'%s' は想定外のタグです (想定していたタグは '%s')"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
-msgstr "想定外のタグ '%s' ('%s' 内) です"
+msgstr "'%s' は '%s' の中では想定外のタグです"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "データ・ディレクトリの中に妥当なブックマーク・ファイルはありません"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
-msgstr "URI が '%s' であるブックマークは既に存在します"
-
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+msgstr "'%s' という URI のブックマークが既に存在しています"
+
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
-msgstr "URI '%s' のブックマークが見つかりませんでした"
+msgstr "'%s' という URI のブックマークが見つかりませんでした"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
-msgstr "URI '%s' のブックマークの中で MIME 型が定義されていません"
+msgstr "'%s' という URI のブックマークには MIME 型が定義されていません"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr ""
-"URI '%s' のブックマークの中でプライベートではないフラグが定義されています"
+"'%s' という URI のブックマークにはプライベートではないフラグが定義されていま"
+"す"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
-msgstr "URI '%s' のブックマークの中にグループがありません"
+msgstr "'%s' という URI のブックマークにはグループがありません"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
-msgstr "アプリケーション '%s' は '%s' のブックマークを登録していません"
+msgstr "アプリケーションの '%s' は '%s' というブックマークを登録していません"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
-msgstr "実行ラインの '%s' を URI '%s' で展開できませんでした"
+msgstr "コマンドラインの '%s' を '%s' という URI に展開できませんでした"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
-msgstr "文字セット '%s' から '%s' への変換はサポートしていません"
+msgstr "'%s' から '%s' という文字集合への変換はサポートしていません"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
-msgstr "'%s' から '%s' へのコンバータを開けませんでした"
+msgstr "'%s' から '%s' への変換処理を開けませんでした"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "変換する入力に無効なバイトの並びがあります"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "変換中にエラー: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:951 ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296 ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "入力の最後に不完全な文字シーケンスがあります"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
-msgstr "フォールバック '%s' を文字セット '%s' に変換できません"
+msgstr "フォールバック '%s' を '%s' という文字集合に変換できません"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
-msgstr "URI '%s' は \"file\" スキームの絶対 URI ではありません"
+msgstr "'%s' は \"file\" スキームの絶対 URI ではありません"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
-msgstr "ローカル・ファイルの URI '%s' は '#' は含みません"
+msgstr "'#' を含んだ '%s' はローカル・ファイルの URI としては正しくありません"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
-msgstr "URI '%s' は正しくありません"
+msgstr "'%s' という URI は正しくありません"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
-msgstr "URI のホスト名 '%s' がおかしいです"
+msgstr "URI に含まれる '%s' というホスト名は間違っています"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
-msgstr "URI '%s' に無効なエスケープ文字が含まれています"
+msgstr "'%s' という URI に無効なエスケープ文字が含まれています"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
-msgstr "パス名 '%s' が絶対パスではありません"
+msgstr "'%s' は絶対パスではありません"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "無効なホスト名です"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
-msgstr "ディレクトリ '%s' を開く時にエラー: %s"
+msgstr "'%s' を開く時にエラー: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "%lu バイトを確保できませんでした (ファイル \"%s\" の読み込みに必要)"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
-msgstr "ファイル '%s' の読み出し中にエラー: %s"
+msgstr "'%s' の読み出し中にエラー: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
-msgstr "ファイル '%s' のサイズが大きすぎます"
+msgstr "'%s' のサイズが大きすぎます"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
-msgstr "ファイル '%s' を読めません: %s"
+msgstr "'%s' が読めません: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
-msgstr "ファイル '%s' を開けません: %s"
+msgstr "'%s' を開けません: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
-msgstr "ファイル '%s' の属性の取得できません: fstat() が失敗: %s"
+msgstr "'%s' の属性の取得できません: fstat() に失敗しました: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
-msgstr "ファイル '%s' を開けません: fdopen() が失敗: %s"
+msgstr "'%s' を開けません: fdopen() に失敗しました: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
-"'%s' から '%s' へのファイル名の変更に失敗しました: g_rename() が失敗: %s"
+"'%s' から '%s' にファイル名を変更できません: g_rename() に失敗しました: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
-msgstr "ファイル '%s' の生成に失敗しました: %s"
+msgstr "'%s' というファイルを生成できませんでした: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
-msgstr "ファイル '%s' を書き込みモードで開けませんでした: fdopen() が失敗: %s"
+msgstr "'%s' を書き込みモードで開けませんでした: fdopen() に失敗しました: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
-msgstr "ファイル '%s' への書き込みに失敗しました: fwrite() が失敗: %s"
+msgstr "'%s' への書き込みに失敗しました: fwrite() に失敗しました: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
-msgstr "ファイル '%s' を閉じれません: fclose() が失敗: %s"
+msgstr "'%s' をクローズできません: fclose() に失敗しました: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
-msgstr "既存のファイル '%s' を削除できませんでした: g_unlink() が失敗: %s"
+msgstr ""
+"'%s' という既存のファイルを削除できませんでした: g_unlink() に失敗しました: %"
+"s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
-msgstr "テンプレート '%s' が正しくありません ('%s' を含めないこと)"
+msgstr "'%s' というテンプレートは間違っています ('%s' を含めないこと)"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
-msgstr "テンプレート '%s' に XXXXXX が含まれていません"
+msgstr "'%s' というテンプレートに XXXXXX が含まれていません"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "シンボリック・リンク '%s' の読み込みが失敗: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "シンボリック・リンクはサポートしていません"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "'%s' から '%s' へ変換するコンバータを開けませんでした: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "g_io_channel_read_line_string では raw モードで読めません"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "変換されていないデータが読みこみバッファに残っています"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "チャンネルが不完全な文字で終わっています"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "g_io_channel_read_to_end では raw モードで読めません"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "ファイル '%s' を開けません: open() が失敗: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "ファイル '%s' のマップに失敗しました: mmap() が失敗: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "%d 行の %d 文字目でエラー:"
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "%d 行目でエラー: %s"
 
-#: glib/gmarkup.c:493
+#: ../glib/gmarkup.c:493
 msgid ""
 "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "空のエンティティ '&;' があります; 正しいエンティティは: &amp; &quot; &lt; "
 "&gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -319,17 +323,17 @@ msgstr ""
 "表わします。もしアンパサンドがエンティティでなければ、&amp; のようにエスケー"
 "プしてください"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "文字 '%s' はエンティティ名として使えません"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "エンティティ名 '%s' というのは不明です"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -338,7 +342,7 @@ msgstr ""
 "ドを使ったのではないでしょうか。アンパサンドは &amp; のようにエスケープしてく"
 "ださい"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -347,16 +351,16 @@ msgstr ""
 "'%-.*s' をパースできません。文字参照には数字が含まれなくてはなりません (例: "
 "&#234;) おそらく数字が大きすぎます"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "文字参照 '%-.*s' が使用可能な文字をエンコードしていません"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "空の文字参照です。&#454; のように数字がなくてはなりません"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -366,32 +370,32 @@ msgstr ""
 "サンド文字を使っているのかもしれません。アンパサンドは &amp; とエスケープして"
 "ください"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "中途半端な実体参照です"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "中途半端な文字参照です"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "UTF-8 として正しくない文字列です (シーケンスが長すぎます)"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "UTF-8 として正しくない文字列です (文字で始まっていません)"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "UTF-8 として正しくない文字列です ('%s' は妥当ではありません)"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "ドキュメントは要素 (例 <book>) で始まってなくてはなりません"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -400,7 +404,7 @@ msgstr ""
 "'%s' は '<' に続く文字としては正しくありません。おそらく要素名の開始になって"
 "いません"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -409,13 +413,13 @@ msgstr ""
 "おかしな文字 '%s' があります。空の要素のタグ '%s' の最後は '>' でなくてはなり"
 "ません"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
 msgid ""
 "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
 msgstr "おかしな文字 '%s' です。属性名'%s' (要素 '%s') の後には '=' が必要です"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -426,7 +430,7 @@ msgstr ""
 "はなりません。あるいは属性になります。おかしな文字を属性名に使ったのかもしれ"
 "ません"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -435,7 +439,7 @@ msgstr ""
 "おかしな文字 '%s' です。属性 '%s' (要素 '%s') の値を設定するには等号記号の後"
 "は引用記号で始まってなくてはなりません"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -444,7 +448,7 @@ msgstr ""
 "'%s' は '</' に続く文字としては正しくありません。'%s' では要素名は始まってま"
 "せん"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -453,25 +457,25 @@ msgstr ""
 "'%s' は閉じ要素名 '%s' に続く文字としては正しくありあません。'>' のみが使用で"
 "きます"
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "要素 '%s' は閉じています。要素は何も開かれてません"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "要素'%s' が閉ました。しかし現在開いている要素は '%s' です"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "ドキュメントが空か、空白だけが含まれています"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "ドキュメントが開きカギカッコ '<' の直後で終了しています"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -480,7 +484,7 @@ msgstr ""
 "ドキュメントが突然終了しています。要素が開きっぱなしです。最後に開いた要素は "
 "'%s' です。"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -489,19 +493,19 @@ msgstr ""
 "ドキュメントはタグ <%s/> で終了しているものと想定していましたが、突然終了して"
 "います。"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "要素名の途中でドキュメントが突然終了しています"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "属性名の途中でドキュメントが突然終了しています"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "要素の開始タグの途中でドキュメントが突然終了しています"
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -509,529 +513,531 @@ msgstr ""
 "属性名の後にある等号記号の次でドキュメントが突然終了しています: 属性値があり"
 "ません"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "ドキュメントが属性値の途中で突然終了しています"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "ドキュメントが要素 '%s' の閉じタグの途中で突然終了しています"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "ドキュメントがコメントあるいはプロセシング指示子の途中で突然終了しています"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "不正なオブジェクト"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "内部エラーまたは不正なオブジェクト"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "メモリが足りません"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "バックトラック処理の上限に達しました"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr "パターンに含まれているアイテムは部分マッチングをサポートしていません"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "内部エラー"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "条件の後方参照は部分マッチングをサポートしていません"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "再帰の上限に達しました"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "空の部分文字列に対する作業領域の上限に達しました"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "改行フラグの連携が間違っています"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "原因不明のエラー"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "パタンの終端に \\ があります"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "パタンの終端に \\c があります"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "認識できない文字の後ろに \\ があります"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr ""
 "ここに大/小文字の変換を行うエスケープ (\\l、\\L、\\u、\\U) を挿入できません"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "量指定子 '{}' の中にある数値の順番が間違っています"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "量指定子 '{}' の中にある数値が大きすぎます"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "文字クラスを表す終端文字 '] ' がありません"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "文字クラスの中に無効なエスケープ・シーケンスがあります"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "文字クラスで文字の順番が間違っています"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "繰り返すものがありません"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "'(?' の後ろに認識できない文字があります"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "'(?<' の後ろに認識できない文字があります"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "(?P の後ろに認識できない文字があります"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "POSIX の名前付きクラスはクラスの内部でのみ利用できます"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "終端文字の ')' がありません"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr "開始文字 '(' が無い終端文字 ')'"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R または (?[+-]数値 が続く必要あり )"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "存在しないサブパタンへの参照です"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "コメントの後ろに ')' がありません"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "正規表現が長すぎます"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "メモリの確保に失敗しました"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "後読み (lookbehind assertion) が固定長ではありません"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "'(?(' の後ろに不正な形式の数値または名前があります"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "条件グループに二つ以上のブランチがあります"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "assertion expected after (?("
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "不明な POSIX のクラス名"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "POSIX では照合順序の要素はサポートしていません"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "\\x{...} の中にある文字値が大きすぎます"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "条件の '(?(0)' が間違っています"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "後読みのアサーションでは \\C を指定できません"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "繰り返しの呼び出しが無限ループになっています"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "サブパタンの名前に終端文字がありません"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "二つある名前付きサブパタンが同じ名前です"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "不正な \\P または \\p のシーケンスです"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "\\P または \\p の後ろにあるプロパティ名が不明です"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "サブパタンの名前が長すぎます (32 文字以下にして下さい)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "名前付きサブパタンが多すぎます (10,000 個以下にして下さい)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "８進数値が \\377 よりも大きいです"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE グループに１つ以上のブランチが含まれています"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "DEFINE グループは繰り返せません"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "NEWLINE オプションに矛盾があります"
 
-#: glib/gregex.c:333
+#: ../glib/gregex.c:333
 msgid ""
 "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "ブレース名の後ろに \\g が存在していないか、または０以外の数値でブレースしてい"
 "ます"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "想定外の繰り返しです"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "コードがオーバーフローしました"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "正規表現をコンパイルする領域で上限を超えました"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "直前にチェックしたサブパタンのリファレンスが見つかりませんでした"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "正規表現 %s でマッチングしている際にエラー: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "お使いの PCRE ライブラリは UTF-8 をサポートしていません"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "お使いの PCRE library は UTF-8 のプロパティをサポートしていません"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "正規表現 %s をコンパイルする際にエラー (%d 文字目): %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "正規表現 %s を最適化する際にエラー: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "16進数の数値または '}' を想定していました"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "16進数の数値を想定していました"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "シンボル参照の中に '<' がありません"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "中途半端なシンボル参照です"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "サイズが０のシンボル参照です"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "数値を想定していました"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "シンボル参照が間違っています"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "最後の '\\' に対応するシンボルがありません"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "不明なエスケープ・シーケンスです"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "代替文字列 \"%s\" の %lu 文字目を解析する際にエラー: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "引用テキストが引用記号で始まっていません"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr ""
 "コマンドライン、あるいはシェルの引用テキストにおいて引用記号の対応が取れてい"
 "ません"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "テキストが '\\' 文字の直後で終了しています (テキストは '%s')"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr "%c に対応する引用記号の前でテキストが終了しています (テキストは '%s')"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "テキストが空です (あるいは空白のみ)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "子プロセスからデータを読み出せません"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr "子プロセスとの通信用のパイプを作成できません (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "子パイプから読み出せません (%s) "
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "'%s' というディレクトリへ移動できません (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "子プロセスを起動できません (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "プログラム名が無効です: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "%d の引数ベクタに不正な文字列があります: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "環境変数に不正な文字列があります: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "作業ディレクトリが不正です: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "ヘルパー・プログラム (%s) の起動が失敗しました"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
 msgstr ""
 "g_io_channel_win32_poll() が子プロセスからデータを読み出す際に想定外のエラー"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "子プロセスからデータを読めません (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr "子プロセスからデータを読み出す際に select() で想定外のエラー (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "waitpid() で想定外のエラー (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "fork 失敗 (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "子プロセスを起動できません \"%s\" (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "子プロセスの出力、または入力をリダイレクトできません (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "子プロセスを fork できません (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "子プロセスの実行時に不明なエラー \"%s\""
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "子 pid パイプから十分なデータを読めません (%s)"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "UTF-8 の範囲外の文字です"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123 ../glib/gutf8.c:1132 ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273 ../glib/gutf8.c:1414 ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "変換する入力で無効なシーケンスがあります"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425 ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "UTF-16 の範囲外の文字です"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "用法:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[オプション...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "ヘルプのオプション:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "ヘルプのオプションを表示する"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "ヘルプのオプションを全て表示する"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "アプリケーションのオプション:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "%2$s の整数値 '%1$s' を解析できません"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "%2$s の整数値 '%1$s' は範囲外の値です"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "%2$s の実数値 '%1$s' を解析できません"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "%2$s の実数値 '%1$s' は範囲外の値です"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "オプション %s の解析中にエラー"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "%s の引数がありません"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "%s は不明なオプションです"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "検索ディレクトリには妥当なキー・ファイルがありませんでした"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "通常のファイルではありません"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "ファイルが空です"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
 msgid ""
 "Key file contains line '%s' which is not a key-value pair, group, or comment"
@@ -1039,48 +1045,48 @@ msgstr ""
 "キー・ファイルの行 '%s' がキー/値のペア、グループ、またはコメントではありませ"
 "ん"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "グループ名が無効です: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "キー・ファイルがグループで始まっていません"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "キーの名前が無効です: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "キー・ファイルにサポートしてないエンコーディング '%s' があります"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "キー・ファイルにグループ '%s' がありません"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "キー・ファイルにキー '%s' がありません"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "キー・ファイルのキー '%s' の値 '%s' が UTF-8 ではありません"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr "キー・ファイルのキー '%s' の値を解釈できませんでした"
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1088,144 +1094,148 @@ msgid ""
 msgstr ""
 "キー・ファイルのグループ '%2$s' にあるキー '%1$s' の値を解釈できませんでした"
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "キー・ファイルにはグループ '%2$s' のキー '%1$s' がありません"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "キー・ファイルの行末にエスケープ文字が含まれています"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "キー・ファイルに無効なエスケープ・シーケンス '%s' が含まれています"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "値 '%s' を数値として解釈できません"
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "整数値 '%s' は範囲外の値です"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "値 '%s' を実数値として解釈できません"
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "値 '%s' を論理値として解釈できません"
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "%s に引き渡した値が大きすぎます"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "既にストリームは閉じています"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623 ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "操作がキャンセルされました"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "不明な種類"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "%s (ファイルの種類)"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "%s (種類)"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "想定していたよりも早くストリームの最後に到達しました"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "名前なし"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "デスクトップ・ファイルで Exec 項目を指定してませんでした"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "アプリケーションで必要な端末が見つかりませんでした"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "ユーザのアプリケーション設定フォルダ %s を生成できません: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "ユーザの MIME 型設定フォルダ %s を生成できません: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "ユーザのデスクトップ・ファイル %s を生成できません"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "%s に対する独自の設定"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "ドライブ側で取り出しの操作を実装していません"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "ドライブ側でポーリングによるメディアの検出を実装していません"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "バージョン %d の GEmblem のエンコーディングはサポートしていません"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "GEmblem のエンコーディングにあるトークンの数 (%d) が間違っています"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
 msgstr ""
+"バージョン %d の GEmblemedIcon のエンコーディングはサポートしていません"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
 msgstr ""
+"GEmblemedIcon のエンコーディングにあるトークンの数 (%d) が間違っています"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
-
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+msgstr "GEmblemedIcon に対する GEmblem を想定していました"
+
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "サポートしていない操作です"
 
@@ -1237,130 +1247,131 @@ msgstr "サポートしていない操作です"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "マウントを含んでいるものはありません"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "ディレクトリ全体をコピーできません"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "ディレクトリからディレクトリへコピーできません"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "対象となるファイルが存在しています"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "ディレクトリを再帰的にコピーできません"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "指定したシンボリックリンクは間違っています"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "ゴミ箱はサポートしていません"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "ファイル名に '%c' を含めることはできません"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "ボリュームはマウントを実装していません"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "このファイルを扱うアプリケーションが登録されていません"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Enumerator は閉じています"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "File enumerator has outstanding operation"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "ファイルの Enumerator は既に閉じています"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "ファイル"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "アイコンの情報を格納したファイルです"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "バージョン %d の GFileIcon のエンコーディングはサポートしていません"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "GFileIcon の入力データが間違っています"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "ストリームは query_info をサポートしていません"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
-msgstr "ストリームにおけるシークはサポートしていません"
+msgstr "ストリーム上のシークはサポートしていません"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
-msgstr "入力ストリームで切りつめることはできません"
+msgstr "入力ストリームを切りつめることはできません"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
-msgstr "ストリームにおける切りつめはサポートしていません"
+msgstr "ストリーム上での切りつめはサポートしていません"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "トークンの数 (%d) が間違っています"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "%s というクラス名の型がありません"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "%s という型は GIcon のインタフェースを実装していません"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "%s という型がクラスになっていません"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "バージョン番号が間違っています: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
 msgstr ""
+"%s という型は GIcon のインタフェースで tokens() を使って実装していません"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "提供したバージョンの Icon のエンコーディングはサポートしていません"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "入力ストリームで読み込みを実装していません"
 
@@ -1370,358 +1381,358 @@ msgstr "入力ストリームで読み込みを実装していません"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Stream has outstanding operation"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr ""
 "ローカル・ディレクトリを監視するデフォルト・モニタの種類が見つかりません"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "ファイル名が無効です: %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "ファイルシステムの情報を取得する際にエラー: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "ルート・ディレクトリの名前は変更できません"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "ファイル名を変更する際にエラー: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "ファイル名を変更できません (既に存在しているため)"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "無効なファイル名です"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "ファイルをオープンする際にエラー: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "ディレクトリをオープンできません"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "ファイルを削除する際にエラー: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "ファイルをゴミ箱へ移動する際にエラー: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "ゴミ箱のディレクトリ (%s) の生成に失敗しました: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "ゴミ箱のトップレベルなディレクトリが見つかりません"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "ゴミ箱ディレクトリが存在しないか生成できません"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "ゴミ箱の情報ファイルを生成できません: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "ファイルをゴミ箱へ移動できません: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "ディレクトリを生成する際にエラー: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "シンボリック・リンクを生成する際にエラー: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "ファイルを移動する際にエラー: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "ディレクトリからディレクトリへ移動できません"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833 ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864 ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "バックアップ・ファイルの生成に失敗しました"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "対象となるファイルを削除する際にエラー: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "マウント間の移動はサポートしていません"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "属性値を NULL にしないで下さい"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "属性の種類が無効です (文字列を想定していた)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "拡張属性の名前が無効です"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "'%s' という拡張属性をセットする際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464 ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "'%s' というファイルの状態を取得する際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (無効なエンコーディング)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "ファイル・ディスクリプタの状態を取得する際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "属性の種類が無効です (uint32 型を想定していた)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "属性の種類が無効です (uint64 型を想定していた)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784 ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "属性の種類が無効です (バイト型の文字列を想定していた)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "アクセス権をセットする際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880 ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "所有者をセットする際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "シンボリックリンクを NULL にしないで下さい"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913 ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "シンボリックリンクをセットする際にエラー: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
 msgstr "シンボリックリンクの指定でエラー: ファイルがリンクではない"
 
-#: gio/glocalfileinfo.c:2071
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
 msgstr "SELinux のコンテキストを NULL にしないで下さい"
 
-#: gio/glocalfileinfo.c:2086
+#: ../gio/glocalfileinfo.c:2086
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "SELinux のコンテキストを指定する際にエラー: %s"
 
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
 msgstr "このシステムでは SELinux が有効になっていません"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "%s という属性値はセットできません"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "ファイルから読み込む際にエラー: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "ファイルでシークする際にエラー: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "ファイルを閉じる際にエラー: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "ローカル・ファイルを監視するデフォルト・モニタの種類が見つかりません"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "ファイルに書き込む際ににエラー: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "古いバックアップのリンクを削除する際にエラー: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "バックアップのコピーを生成する際にエラー: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "作業用のファイル名を変更する際にエラー: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "ファイルを切りつめる際にエラー: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688 ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "'%s' というファイルをオープンする際にエラー: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "対象となるファイルはディレクトリです"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "対象となるファイルは通常のファイルではありません"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "ファイルが外部で変更されました"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "不正な GSeekType が指定されました"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "無効なシークの要求です"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "GMemoryInputStream を切りつめることはできません"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "データ配列の上限に到達しました"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "メモリ出力ストリームの大きさは変更できません"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "メモリ出力ストリームの大きさを変更できませんでした"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "mount はアンマウントを実装していません"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "mount は取り出しを実装していません"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "mount は再マウントを実装していません"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "mount にはメディアの種類を推測するような実装はありません"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "mount には同期させてメディアの種類を推測するような実装はありません"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "出力ストリームは書き込みを実装していません"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "ソース・ストリームは既に閉じています"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "名前"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "アイコンの名前です"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "名前の集合"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "アイコンの名前を格納した配列です"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "デフォルトのフォールバックを使用する"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1729,86 +1740,85 @@ msgstr ""
 "'-' という代替え文字で名前を省略するデフォルトのフォールバックを使用するかど"
 "うかです (複数の名前を指定すると一番最初の名前より後ろの名前を全て無視します)"
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "バージョン %d の GThemedIcon のエンコーディングはサポートしていません"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "ファイル・ディスクリプタ"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "読み込むファイルのファイル・ディスクリプタです"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
-msgstr "ファイル・ディスクリプタの状態を取得する際にエラー: %s"
+msgstr "ファイル・ディスクリプタを閉じるかどうか"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
-msgstr ""
+msgstr "ストリームが閉じたらファイル・ディスクリプタを閉じるかどうかです"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "unix から読み込む際にエラー: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "unix を閉じる際にエラー: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "ファイルシステムのルート"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "書き込むファイルのファイル・ディスクリプタです"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "unix に書き込む際にエラー: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "ボリュームは取り出しを実装していません"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "アプリケーションが見つかりません"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "アプリケーションを起動する際にエラー: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URI はサポートしていません"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "win32 で組み合わせの変更はサポートしていません"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "win32 で組み合わせの生成はサポートしていません"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "エントリを隠さない"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "長い形式で一覧表示する"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[ファイル...]"
diff --git a/po/nb.po b/po/nb.po
index 6d30bd2..c7742c2 100644
--- a/po/nb.po
+++ b/po/nb.po
@@ -1,310 +1,311 @@
 # translation of nb.po to Norwegian Bokmal
 # Norwegian (bokmål) translation of glib.
 # Copyright (C) 2001-2003, 2005 Free Software Foundation, Inc.
-# Kjartan Maraas <kmaraas@gnome.org>, 2001-2008.
+# Kjartan Maraas <kmaraas@gnome.org>, 2001-2009.
 # Terance Edward Sola <terance@lyse.net>, 2005.
 #
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: glib 2.13.x\n"
+"Project-Id-Version: glib 2.15.x\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2009-01-05 15:33+0100\n"
+"POT-Creation-Date: 2009-02-06 12:46+0100\n"
+"PO-Revision-Date: 2009-02-06 12:57+0100\n"
 "Last-Translator: Kjartan Maraas <kmaraas@gnome.org>\n"
 "Language-Team: Norwegian bokmal <i18n-nb@lister.ping.uio.no>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Uventet attributt «%s» for element «%s»"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "Attributt «%s» i element «%s» ble ikke funnet"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Uventet tagg «%s», tagg «%s» forventet"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Uventet tagg «%s» i «%s»"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "Ingen gyldig bokmerkefil ble funnet i datakatalogene"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Et bokmerke eksisterer allerede for URI «%s»"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "Ingen bokmerker funnet for URI «%s»"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "Ingen MIME-type definert i bokmerke for URI «%s»"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "Ingen private flagg er definert i bokmerke for URI «%s»"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "Ingen grupper satt i bokmerke for URI «%s»"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr "Ingen program med navn «%s» har registrert et bokmerke for «%s»"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Feil under utvidelse av exec-linje «%s» med URI «%s»"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "Konvertering fra tegnsett «%s» til «%s» er ikke støttet"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "Kunne ikke åpne program for å konvertere fra «%s» til «%s»"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "Ugyldig bytesekvens i inndata for konvertering"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Feil under konvertering: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:951 ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296 ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "Ufullstendig tegnsekvens ved slutten på inndata"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Kan ikke konvertere \"fallback\" «%s» til tegnsett «%s»"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "URI «%s» er ikke en absolutt URI som bruker skjema for filer"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "Lokal fil-URI «%s» kan ikke inneholde en «#»"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "URI «%s» er ugyldig"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "Vertsnavnet for URI «%s» er ugyldig"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "Vertsnavnet for URI «%s» inneholder ugyldige escape-tegn"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "Stinavnet «%s» er ikke en absolutt sti"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Ugyldig vertsnavn"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Feil under åpning av katalog «%s»: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Kunne ikke allokere %lu bytes til lest fil «%s»"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Feil under lesing av fil «%s»: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "Fil «%s» er for stor"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Feil under lesing fra fil «%s»: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Feil under åpning av fil «%s»: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr "Feil ved uthenting av attributter for fil «%s»: fstat() feilet: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "Feil under åpning av fil «%s»: fdopen() feilet: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr "Feil under endring av navn på filen «%s» til «%s»: g_rename() feilet: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Feil under oppretting av fil «%s»: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr "Feil under åpning av filen «%s» for skriving: fdopen() feilet: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Kunne ikke skrive fil «%s»: fwrite() feilet: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Kunne ikke lukke fil «%s»: fclose() feilet: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr "Eksisterende fil «%s» kunne ikke bli fjernet: g_unlink() feilet: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "Mal «%s» er ugyldig, må ikke inneholde «%s»"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "Mal «%s» inneholder ikke XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Feil under lesing av symbolsk lenke «%s»: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "Symbolske lenker er ikke støttet"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "Kunne ikke åpne konverterer fra «%s» til «%s»: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "Kan ikke utføre rå avlesing i g_io_channel_read_line_string"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Overflødig ikke-konvertert data i innlesingsbuffer"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "Kanalen terminerer i et oppdelt tegn"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "Kan ikke utføre rå avlesing i g_io_channel_read_to_end"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Kunne ikke åpne fil «%s»: open() feilet: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Kunne ikke lese fil «%s» inn i minnet: mmap() feilet: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Feil på linje %d tegn %d: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Feil på linje %d: %s"
 
-#: glib/gmarkup.c:493
+#: ../glib/gmarkup.c:493
 msgid ""
 "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "Tom entitet «&;» funnet; gyldige entiteter er: &amp; &quot; &lt; &gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -315,17 +316,17 @@ msgstr ""
 "starter en entitet; hvis dette og-tegnet ikke er ment å være en entitet, "
 "unngå dette ved å bruke &amp; i stedet"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "Tegn «%s» er ikke gyldig inne i et entitetsnavn"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "Entitetsnavn «%s» er ikke kjent"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -334,7 +335,7 @@ msgstr ""
 "tegn uten at det var ment å starte en entitet - ungå ved å bruke &amp; i "
 "stedet"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -343,16 +344,16 @@ msgstr ""
 "Feil under lesing av «%-.*s», som skulle vært et tall inne i en tegnreferanse "
 "(&#234; for eksempel) - tallet er muligens for stort"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "Tegnreferanse «%-.*s» koder ikke et tillatt tegn"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "Tom tegnreferanse; skulle inkludert et tall slik som &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -362,32 +363,32 @@ msgstr ""
 "og-tegn uten at det var ment å starte en entitet - unngå ved å bruke &amp; i "
 "stedet"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Uferdig referanse til entitet"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Uferdig referanse til tegn"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "Ugyldig UTF-8 kodet tekst - for lang sekvens"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "Ugyldig UTF-8 kodet tekst - ikke et starttegn"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "Ugyldig UTF-8 kodet tekst - ikke gyldig «%s»"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Dokumentet må starte med et element (f.eks <book>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -396,7 +397,7 @@ msgstr ""
 "«%s» er ikke et gyldig tegn etter en «<» tegn; det kan ikke være begynnelsen "
 "på et elementnavn"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -405,13 +406,13 @@ msgstr ""
 "Rart tegn «%s», forventet et «>» tegn for å avslutte start-taggen til det "
 "tomme elementet «%s»"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
 msgid ""
 "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
 msgstr "Rart tegn «%s», forventet et «=» etter attributtnavn «%s» for element «%s»"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -422,7 +423,7 @@ msgstr ""
 "element «%s», eller alternativt en attributt; kanskje du brukte et ugyldig "
 "tegn i attributtnavnet"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -431,7 +432,7 @@ msgstr ""
 "Rart tegn «%s», ventet et åpent sitattegn etter likhetstegnet når verdi for "
 "attributt «%s» for element «%s» oppgis"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -440,7 +441,7 @@ msgstr ""
 "«%s» er ikke et gyldig tegn etter tegnene «</»; «%s» er kanskje ikke "
 "begynnelsen på et elementnavn"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -449,25 +450,25 @@ msgstr ""
 "«%s» er ikke et gyldig tegn etter element for lukking med navn «%s»; tillatt "
 "tegn er «>»"
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "Element «%s» ble lukket, ingen åpne elementer nå"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "Element «%s» ble lukket, men aktivt åpent element er «%s»"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "Dokumentet var tomt eller inneholdt kun blanke tegn"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "Dokumentet sluttet uventet rett etter en åpen vinkelparantes «<»"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -475,7 +476,7 @@ msgid ""
 msgstr ""
 "Dokumentet sluttet uventet med åpne elementer - «%s» var siste åpne element"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -484,19 +485,19 @@ msgstr ""
 "Dokumentet sluttet uventet, forventet å se en vinkelparantes for å slutte av "
 "den siste taggen <%s/>"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Dokumentet sluttet uventet inni et elementnavn"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Dokumentet sluttet uventet inni et attributtnavn"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "Dokumentet sluttet uventet inni en tagg for åpning av element."
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -504,391 +505,393 @@ msgstr ""
 "Dokumentet sluttet uventet etter likhetstegnet som følger et attributtnavn; "
 "ingen attributtverdi"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "Dokumentet sluttet uventet inni en attributtverdi"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "Dokumentet sluttet uventet inni tagg for lukking av element «%s»"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "Dokumentet sluttet uventet inni en kommentar eller prosesseringsinstruksjon"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "korrupt objekt"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "intern feil eller korrupt objekt"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "ikke mer minne"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "grense for liste av funksjonskall nådd"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr "mønsteret inneholder oppføringer som ikke støttes for delvise treff"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "intern feil"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "bakoverreferanser som betingelser er ikke støttet for delvise treff"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "rekursjonsgrense nådd"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "grense for tomme understrenger nådd"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "ugyldig kombinasjon av flagg for nye linjer"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "ukjent feil"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ på slutten av mønsteret"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c på slutten av mønsteret"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "ugjenkjennelig tegn følger \\"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
-msgstr ""
+msgstr "escape-verdier som bytter mellom små/store bokstaver (\\l, \\L, \\u, \\U) er ikke tillatt her"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "tall ute av rekkefølge i {}-kvantifikator"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "for stort tall i {}-kvantifikator"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "mangler terminerende ] for tegnklassen"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "ugyldig escape-sekvens i tegnklassen"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "område utenfor rekkefølge i tegnklassen"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "ingenting å gjenta"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "ikke gjenkjent tegn etter (?"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "ikke gjenkjent tegn etter (?<"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "ikke gjenkjent tegn etter (?P"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "klasser med POSIX-navngivning støttes kun innen en klasse"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "mangler terminerende )"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") uten åpnende ("
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R eller (?[+-]tall må følges av )"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "referanse til ikke-eksisterende undermønster"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "mangler ) etter kommentar"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "vanlig uttrykk for stort"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "ikke nok minne"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
-msgstr ""
+msgstr "lookbehind-regel er ikke av fast lengde"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "ugyldig tall eller navn etter (?("
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "betinget gruppe inneholder mer enn to grener"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
-msgstr ""
+msgstr "assert forventet etter (?("
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "ukjent navn på POSIX-klasse"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "POSIX elementer for sammenslåing er ikke støttet"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "tegnverdi i \\x{...} sekvens er for stor"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "ugyldig betingelse (?(0)"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C er ikke tillatt i «lookbehind assertion»"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "rekursivt kall kunne gå i uendelig løkke"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "mangler terminering av navn på undermønster"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "to navngitte undermønster har samme navn"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "ugyldig \\P- eller \\p-sekvens"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "ukjent navn på egenskap etter \\P eller \\p"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "navn på undermønster er for langt (maks 32 tegn)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "for mange navngitte undermønster (maks 10.000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "oktal verdi er større enn \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE-gruppe inneholder mer enn en gren"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "repetering av en DEFINE-gruppe er ikke tillatt"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "inkonsistente NEWLINE-alternativer"
 
-#: glib/gregex.c:333
+#: ../glib/gregex.c:333
 msgid ""
 "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "\\g etterfølges ikke av et navn, eller tall større enn null, i "
 "klammeparanteser"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "uventet gjentagelse"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "kodeoverflyt"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
-msgstr ""
+msgstr "gikk ut over arbeidsområde for kompilering"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
-msgstr ""
+msgstr "tidligere sjekket og referert undermønster ikke funnet"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Feil under treff på regulært uttrykk %s: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "PCRE-biblioteket er kompilert uten støtte for UTF8"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "PCRE-biblioteket er kompilert uten støtte for UTF8-egenskaper"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "Feil under sammensetting av regulært utrykk %s ved tegn %d: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Feil under optimering av reguært utrykk %s: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "heksadesimalt tall eller «}» forventet"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "heksadesimalt tall forventet"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "mangler «<» i symbolsk referanse"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "uferdig symbolsk referanse"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "symbolsk referanse med null lengde"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "tall forventet"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "ugyldig symbolsk referanse"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "feilplassert siste «\\\\»"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "ukjent escapesekvens"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "Feil under tolking av erstatningstekst «%s» ved tegn %lu: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Sitert tekst begynner ikke med sitattegn"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr "Ubalansert sitattegn i kommandolinje eller annen skall-sitert tekst"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "Tekst sluttet rett etter et «\\» tegn. (Teksten var «%s»)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr ""
 "Teksten sluttet før likt sitattegn ble funnet for %c. (Teksten var «%s»)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "Teksten var tom (eller inneholdt kun blanke tegn)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Feil under lesing av data fra underprosess"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr "Feil under oppretting av rør for kommunikasjon med underprosess (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Feil under lesing fra \"child pipe\" (%s)"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Feil ved skifte til katalog «%s» (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Feil under kjøring av underprosess (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Ugyldig programnavn: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Ugyldig streng i argumentvektor på %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Ugyldig streng i miljø: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Ugyldig arbeidsmappe: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Feil under kjøring av hjelpeprogram (%s)"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -896,136 +899,136 @@ msgstr ""
 "Uventet feil i g_io_channel_win32_poll() under lesing av data fra en "
 "underprosess"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Feil under lesing av data fra underprosess (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr "Uventet feil i select() ved lesing av data fra underprosess (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Uventet feil i waitpid() (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "Feil under kjøring av fork (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Feil under kjøring av underprosess «%s» (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "Feil under omdirigering av utdata eller inndata for underprosess (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Feil under kjøring av fork() for underprosess (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Ukjent feil under kjøring av underprosess «%s»"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Klarte ikke å lese nok data fra underprosessens pid-rør (%s)"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "Tegn utenfor gyldig område for UTF-8"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123 ../glib/gutf8.c:1132 ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273 ../glib/gutf8.c:1414 ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "Ugyldig sekvens i inndata for konvertering"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425 ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "Tegn utenfor gyldig område for UTF-16"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Bruk:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[FLAGG...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Flagg for hjelp:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Vis flagg for hjelp"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Vis alle flagg for hjelp"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Flagg for applikasjonen"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Kan ikke lese heltallsverdi «%s» for %s"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "Heltallsverdi «%s» for %s er utenfor gyldig område"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Kan ikke lese verdi for double «%s» for %s"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "Double-verdi «%s» for %s er utenfor gyldig område"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Feil under tolking av flagg %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Mangler argument for %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Ukjent flagg %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "Gyldig nøkkelfil ble ikke funnet i søkemapper"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Ikke en vanlig fil"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "Filen er tom"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
 msgid ""
 "Key file contains line '%s' which is not a key-value pair, group, or comment"
@@ -1033,49 +1036,49 @@ msgstr ""
 "Nøkkelfil inneholder linjen «%s» som ikke er et par med nøkkelverdier, gruppe "
 "eller kommentar"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Ugyldig navn på gruppe: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "Nøkkelfil starter ikke med en gruppe"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Ugyldig navn på nøkkel: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Nøkkelfil inneholder ustøttet tegnkoding «%s»"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Nøkkelfil har ikke gruppe «%s»"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "Nøkkelfil har ikke nøkkelen «%s»"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "Nøkkelfilen inneholder nøkkelen «%s» med verdi «%s» som ikke er UTF-8"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr ""
 "Nøkkelfilen inneholder nøkkelen «%s» som har en verdi som ikke kan bli tolket"
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1084,144 +1087,146 @@ msgstr ""
 "Nøkkelfilen inneholder nøkkelen «%s» i gruppen «%s» som har en verdi som ikke "
 "kan bli tolket."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Nøkkelfilen har ikke nøkkelen i «%s» i gruppen «%s»"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "Nøkkelfilen inneholder skiftetegn ved linjeslutt"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Nøkkelfil inneholder ugyldig skiftesekvens «%s»"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "Vedien «%s» kan ikke bli tolket som et tall."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Heltallsverdi «%s» er utenfor gyldig område"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "Verdi «%s» kan ikke tolkes som et flyttall."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Verdi «%s» kan ikke tolkes som en bolsk verdi."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Tellerverdi gitt til %s er for stor"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Strømmen er allerede lukket"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623 ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "Operasjonen ble avbrutt"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Ukjent type"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "filtype %s"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "type %s"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Uventet tidlig slutt på strøm"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Uten navn"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "Desktop-filen hadde ingen verdi i Exec-feltet"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Kan ikke finne terminalen som kreves for programmet"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "Kan ikke opprette konfigurasjonsmappe %s for brukers program: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Kan ikke opprette brukers konfigurasjonsmappe %s for MIME: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Kan ikke opprette brukers desktop-fil %s"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "Egendefinert definisjon for %s"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "stasjonen implementerer ikke utløsing"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "stasjonen implementerer ikke sjekk om medie er satt inn"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
 msgstr "Kan ikke håndtere versjon %d av GEmblem-koding"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
 msgstr "Feil antall tegn (%d) i GEmblem-koding"
 
-#: gio/gemblemedicon.c:295
-#, fuzzy, c-format
+#: ../gio/gemblemedicon.c:295
+#, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr "Kan ikke håndtere versjon %d av GThemedIcon-koding"
+msgstr "Kan ikke håndtere versjon %d av GEmblemedIcon-koding"
 
-#: gio/gemblemedicon.c:305
-#, fuzzy, c-format
+#: ../gio/gemblemedicon.c:305
+#, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr "Feil antall tegn (%d) i GEmblem-koding"
+msgstr "Feil antall tegn (%d) i GEmblemedIcon-koding"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
-
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+msgstr "Ventet et GEmblem for GEmblemedIcon"
+
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "Operasjonen er ikke støttet"
 
@@ -1233,130 +1238,130 @@ msgstr "Operasjonen er ikke støttet"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "Omsluttende monteringspunkt finnes ikke"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Kan ikke kopiere over katalog"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "Kan ikke kopiere katalog over katalog"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Målfilen eksisterer"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "Kan ikke kopiere katalog rekursivt"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Ugyldig verdi oppgitt for symbolsk lenke"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "Papirkurv er ikke støttet"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Filnavn kan ikke inneholde «%c»"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "volumet implementerer ikke montering"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Ingen program registrert for å håndtere denne filen"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Enumerator er lukket"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "Filenumerator har utestående operasjon"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Filenumerator er allerede lukket"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "fil"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Filen med navnet på ikonet"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
 msgstr "Kan ikke håndtere versjon %d av GFileIcon-koding"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
 msgstr "Feil inndata for GFileIcon"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Strømmen støtter ikke query_info"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Søking ikke støttet på strøm"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "Avkorting er ikke tillatt på en inndatastrøm"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Avkorting er ikke støttet på strømmen"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
 msgstr "Feil antall tegn (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
 msgstr "Ingen type for klassenavn %s"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
 msgstr "Type %s implementerer ikke GIcon-grensesnittet"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
 msgstr "Type %s er er ikke en klasse"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
 msgstr "Feil versjonsnummer: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
 msgstr "Type %s implementerer ikke from_tokens() på GIcon-grensesnittet"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
 msgstr "Kan ikke håndtere oppgitt versjon i ikon-koding"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "Inndatastrøm implementerer ikke lesing"
 
@@ -1366,357 +1371,357 @@ msgstr "Inndatastrøm implementerer ikke lesing"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Strømmen har utestående operasjoner"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Klarte ikke å finne forvalgt type overvåker for lokal katalog"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Ugyldig filnavn %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Feil under lesing av informasjon om filsystem: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Kan ikke endre navn på rotkatalogen"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Feil under endring av navn på fil: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "Kan ikke endre navn på filen. Filnavnet eksisterer allerede"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "Ugyldig filnavn"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Feil under åpning av fil: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "Kan ikke åpne mappe"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Feil ved fjerning av fil: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Feil ved plassering av fil i papirkurv: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Kan ikke legge katalog %s i papirkurven: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Kan ikke finne toppnivå for papirkurv"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Kan ikke finne eller opprette mappe for papirkurv"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Kan ikke opprette informasjonsfil for papirkurv: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Kan ikke legge fil i papirkurven: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Feil under oppretting av katalog: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Feil ved oppretting av symbolsk lenke: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Feil under flytting av fil: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "Kan ikke flytte katalog over katalog"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833 ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864 ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "Oppretting av sikkerhetskopi feilet"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Feil under fjerning av målfil: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "Flytting mellom monteringspunkter er ikke støttet"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Attributtverdi må ikke være NULL"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Ugyldig type attributt (streng forventet)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Ugyldig navn på utvidet attributt"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Feil under setting av utvidet attributt «%s»: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464 ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Feil ved henting av informasjon om fil «%s»: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (ugyldig koding)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "Feil ved henting av informasjon om fildeskriptor: %s"
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Ugyldig type attributt (uint32 forventet)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Ugyldig type attributt (uint64 forventet)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784 ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Ugyldig type attributt (byte-streng forventet)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Feil ved setting av rettigheter: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880 ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Feil ved setting av eier: %s"
 
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "symbolsk lenke kan ikke være NULL"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913 ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Feil ved setting av symbolsk lenke: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
 msgstr "Feil ved setting av symbolsk lenke: filen er ikke en symbolsk lenke"
 
-#: gio/glocalfileinfo.c:2071
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
 msgstr "SELinux-kontekst kan ikke være NULL"
 
-#: gio/glocalfileinfo.c:2086
+#: ../gio/glocalfileinfo.c:2086
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Feil ved setting av SELinux-kontekst: %s"
 
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
 msgstr "SELinux er ikke slått på på dette systemet"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "Støtter ikke å sette attributt %s"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Feil under lesing fra fil: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Feil under søking i fil: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Feil under lukking av fil: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Kan ikke finne forvalgt lokal filovervåkingstype"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Feil under skriving til fil: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Feil ved fjerning av gammel sikkerhetskopi av lenke: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Feil under oppretting av sikkerhetskopi: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Feil ved endring av navn på midlertidig fil: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Feil under avkorting av fil: «%s»"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688 ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Feil under åpning av fil «%s»: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "Målfilen er en katalog"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "Målfilen er ikke en vanlig fil"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "Filen ble endret eksternt"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "Ugyldig GSeekType oppgitt"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Ugyldig søkeforespørsel"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "Kan ikke avkorte GMemoryInputStream"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "Maksimumsgrense for data er nådd"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "Kan ikke endre størrelse på utdatastrøm for minne"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Klarte ikke å endre størrelse på utdatastrøm for minne"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "monteringspunktet implementerer ikke avmontering"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "montering implementerer ikke utløsing"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "montering implementerer ikke remontering"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "montering implementerer ikke gjetting av innholdstype"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "montering implementerer ikke synkron gjetting av innholdstype"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "Ut-strømmen implementerer ikke skriving"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "Kildestrømmen er allerede lukket"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "navn"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Navn på ikonet"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "navn"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "En tabell som inneholder navn på ikoner"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "bruk forvalgte reserveverdier"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1724,85 +1729,85 @@ msgstr ""
 "Om forvalgte verdier som finnes ved å avkorte navnet ved «-»-tegn skal "
 "brukes. Overser navn etter første deletegn hvis flere navn oppgis."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
 msgstr "Kan ikke håndtere versjon %d av GThemedIcon-koding"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
 msgstr "Fildeskriptor"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
 msgstr "Fildeskriptor det skal leses fra"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
 msgstr "Lukk fildeskriptor"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
 msgstr "Om fildeskriptoren skal lukkes når strømmen lukkes"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Feil under lesing fra unix: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Feil ved lukking av unix: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Filsystemrot"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
 msgstr "Fildeskriptor det skal skrives til"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Feil ved skriving til unix: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "volumet implementerer ikke utløsing"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Kan ikke finne program"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Feil ved oppstart av program: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URIer er ikke støttet"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "endringer i assosiasjon er ikke støttet på win32"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "Oppretting av assosiasjon er ikke støttet på win32"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "ikke skjul oppføringer"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "bruk langt listeformat"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[FIL...]"
diff --git a/po/nl.po b/po/nl.po
index 8a40f9e..de87abc 100644
--- a/po/nl.po
+++ b/po/nl.po
@@ -10,7 +10,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
+"POT-Creation-Date: 2009-02-04 15:54+0100\n"
 "PO-Revision-Date: 2008-09-02 02:13+0200\n"
 "Last-Translator: Tino Meinen <a.t.meinen@chello.nl>\n"
 "Language-Team: Dutch <vertaling@vrijschrift.org>\n"
@@ -19,81 +19,81 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Onverwacht attribuut ‘%s’ voor element ‘%s’"
 
 # aangetroffen hier mooier dan gevonden
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "Attribuut ‘%s’ van element ‘%s’ is niet aangetroffen"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Onverwachte tag ‘%s’, tag ‘%s’ werd verwacht"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Onverwachte tag ‘%s’ binnen ‘%s’"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "Er is geen geldig bladwijzerbestand gevonden in de datamappen"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Er bestaat al een bladwijzer voor de URI ‘%s’"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "Geen bladwijzer gevonden voor URI ‘%s’"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "Er is geen MIME-type gedefinieerd in de bladwijzer voor URI ‘%s’"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "Er is geen privé-vlag gedefinieerd in de bladwijzer voor URI ‘%s’"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "Er zijn geen groepen ingesteld in de bladwijzer voor URI ‘%s’"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr ""
 "Er is geen programma genaamd ‘%s’ die een bladwijzer geregistreerd heeft "
 "voor ‘%s’"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Exec-regel ‘%s’ kon niet worden verwerkt met URI ‘%s’"
 
 # is niet mogelijk/wordt niet ondersteund
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "Het omzetten van tekenset ‘%s’ naar ‘%s’ is niet mogelijk"
@@ -103,234 +103,235 @@ msgstr "Het omzetten van tekenset ‘%s’ naar ‘%s’ is niet mogelijk"
 # Openen van converteerder van '%s' naar '%s' mislukt
 # Openen van het programma voor het omzetten van s naar s is mislukt
 # (tekenreeks komt verderop nog een keer voor)
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr ""
 "Kon het conversieprogramma voor het omzetten van ‘%s’ naar ‘%s’ niet openen"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "Ongeldige bytereeks in conversie-invoer"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Fout tijdens omzetten: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:951 ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296 ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "Onvolledige tekenreeks aan het eind van de invoer"
 
 # wordt hier niet character set ipv codeset bedoeld?
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Kan vanaf codeverzameling ‘%s’ niet terugvallen op ‘%s’"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr ""
 "De URI ‘%s’ is geen absolute URI die gebruik maakt van het schema ‘bestand’"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "De lokale bestands-URI ‘%s’ mag het teken ‘#’ niet bevatten"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "De URI ‘%s’ is ongeldig"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "De hostnaam van de URI ‘%s’ is ongeldig"
 
 # controle-tekens/ontsnappingstekens/sturingstekens
 # betere vertaling?
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "De URI ‘%s’ bevat tekens met een foutief controleteken"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "Het pad ‘%s’ is geen absoluut pad"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Ongeldige hostnaam"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Fout bij het openen van map ‘%s’: %s"
 
 # Allocatie van %lu bytes om bestand "%s" te lezen is mislukt<
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Kon geen %lu byte geheugenruimte reserveren om bestand ‘%s’ te lezen"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Fout bij het lezen van bestand ‘%s’: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "Bestand ‘%s’ is te groot"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Lezen uit bestand ‘%s’ is mislukt: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Openen van bestand ‘%s’ is mislukt: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr "Opvragen gegevens van bestand ‘%s’ is mislukt: fstat() is mislukt: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "Openen van bestand ‘%s’ is mislukt: fdopen() is mislukt: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
 "Hernoemen van bestand ‘%s’ naar ‘%s’ is mislukt: g_rename() is mislukt: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Aanmaken van bestand ‘%s’ is mislukt: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr ""
 "Openen van bestand ‘%s’ voor schrijven is mislukt: fdopen() is mislukt: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Schrijven van bestand ‘%s’ is mislukt: fwrite() is mislukt: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Sluiten van bestand ‘%s’ is mislukt: fclose() is mislukt: %s"
 
 # bestaand bestand is een beetje dubbelop
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr "Bestand ‘%s’ kon niet worden verwijderd: g_unlink() is mislukt: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "Sjabloon ‘%s’ is ongeldig, het zou geen ‘%s’ moeten bevatten"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "Sjabloon ‘%s’ bevat geen XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Lezen van symbolische verwijzing ‘%s’ is mislukt: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "Symbolische verwijzingen zijn niet mogelijk"
 
 # Openen van converteerder van '%s' naar '%s' mislukt: %s
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr ""
 "Kon het conversieprogramma voor omzetten van ‘%s’ naar ‘%s’ niet openen: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr ""
 "Een kale ('raw') leesoperatie is niet mogelijk in "
 "g_io_channel_read_line_string"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Restant aan ongeconverteerde data in de leesbuffer"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "Kanaal eindigt in een gedeeltelijk teken"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr ""
 "Een kale ('raw') leesoperatie is niet mogelijk in g_io_channel_read_to_end"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Openen van bestand ‘%s’ is mislukt: open() is mislukt: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Openen van bestand ‘%s’ is mislukt: mmap() is mislukt: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Fout in regel %d teken %d: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Fout in regel %d: %s"
 
-#: glib/gmarkup.c:493
+#: ../glib/gmarkup.c:493
 msgid ""
 "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "Lege entiteit ‘&;’ gevonden;  geldige entiteiten zijn: &amp; &quot; &lt; "
 "&gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -340,17 +341,17 @@ msgstr ""
 "Teken ‘%s’ is niet geldig aan het begin van een entiteitnaam; het &-teken "
 "begint een entiteit; indien dat niet de bedoeling is, gebruik dan &amp;"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "Het teken ‘%s’ is niet geldig in een entiteitnaam"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "Entiteitnaam ‘%s’ is niet bekend"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -359,7 +360,7 @@ msgstr ""
 "ampersand-teken gebruikt zonder daarmee een entiteit te willen beginnen - "
 "gebruik in plaats daarvan &amp;"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -369,16 +370,16 @@ msgstr ""
 "zou moeten zijn (bijvoorbeeld &#234;) - misschien is het getal te groot"
 
 # niet geoorloofd/toegestaan/ongeoorloofd
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "Tekenreferentie ‘%-.*s’ staat niet voor een geoorloofd teken"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "Lege tekenreferentie; ze zou een getal moeten bevatten, zoals &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -388,33 +389,33 @@ msgstr ""
 "ampersand-teken gebruikt zonder daarmee een entiteit te willen beginnen - "
 "gebruik in plaats daarvan &amp;"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Onbeëindigde entiteitreferentie"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Onbeëindigde tekenreferentie"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "Ongeldige UTF-8-gecodeerde tekst - de reeks is te lang"
 
 # het is geen startteken/er is geen startteken
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "Ongeldige UTF-8-gecodeerde tekst - geen startteken"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "Ongeldige UTF-8-gecodeerde tekst - niet geldig ‘%s’"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Het document moet beginnen met een element (bijv. <book>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -422,7 +423,7 @@ msgid ""
 msgstr ""
 "‘%s’ is geen geldig teken na ‘<’; een elementnaam mag er niet mee beginnen"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -431,7 +432,7 @@ msgstr ""
 "Onverwacht teken ‘%s’, er werd een ‘>’-teken verwacht om de ledig-element-"
 "tag ‘%s’ af te sluiten"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
 msgid ""
 "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
@@ -439,7 +440,7 @@ msgstr ""
 "Onverwacht teken ‘%s’, er werd een ‘=’ verwacht na de attribuutnaam ‘%s’ van "
 "element ‘%s’"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -450,7 +451,7 @@ msgstr ""
 "start-tag van element ‘%s’ af te sluiten, of eventueel een attribuut; "
 "misschien heeft u ongeldige tekens gebruikt in een attribuutnaam"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -459,7 +460,7 @@ msgstr ""
 "Onverwacht teken ‘%s’, er werd een ‘\"’-teken verwacht na het ‘=’-teken bij "
 "de attribuutwaarde van ‘%s’ in element ‘%s’"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -467,7 +468,7 @@ msgid ""
 msgstr ""
 "‘%s’ is geen geldig teken na ‘</’; een elementnaam mag niet met ‘%s’ beginnen"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -476,25 +477,25 @@ msgstr ""
 "‘%s’ is geen geldig teken na de elementnaam ‘%s’ in de afluitingstag; het "
 "teken dat toegestaan is is ‘>’ "
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "Element ‘%s’ is afgesloten, er is nu geen enkel element open"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "Element ‘%s’ is afgesloten, maar op dit moment is element ‘%s’ open"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "Het document was leeg of bevatte slechts lege ruimte"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "Het document eindigde onverwacht na een openingshaakje: ‘<’"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -503,7 +504,7 @@ msgstr ""
 "Het document eindigde onverwacht met niet-afgesloten elementen - ‘%s’ is het "
 "laatstgeopende element"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -512,19 +513,19 @@ msgstr ""
 "Het document eindigde onverwacht, er werd een sluithaakje (‘>’) verwacht "
 "voor de tag <%s/>"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Het document eindigde onverwacht in een elementnaam"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Het document eindigde onverwacht in een attribuutnaam"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "Het document eindigde onverwacht in een element-openingstag."
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -532,177 +533,177 @@ msgstr ""
 "Het document eindigde onverwacht na een ‘=’-teken dat op een attribuutnaam "
 "volgde; geen attribuutwaarde"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "Het document eindigde onverwacht in een attribuutwaarde"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr ""
 "Het document eindigde onverwacht in een een afsluitingstag voor element ‘%s’"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "Het document eindigde onverwacht in commentaar of een bewerkingsinstructie"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "beschadigd object"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "interne fout of beschadigd object"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "onvoldoende geheugen"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "limiet voor backtracking bereikt"
 
 # voor deelzoeken
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr "het patroon bevat niet-ondersteunde tekens"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "interne fout"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "achterwaartse referenties als condities zijn niet mogelijk"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "recursielimiet bereikt"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "limiet voor lege substrings bereikt"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "ongeldige combinatie van nieuwe-regelvlaggen"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "onbekende fout"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ aan het einde van het patroon"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c aan het einde van het patroon"
 
 # onbekend/niet herkend
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "onbekend teken volgt na \\"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr ""
 "tekens die hoofd,- en kleine letters wijzigen zijn hier niet toegestaan"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "getallen in verkeerde volgorde in {} waardegever"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "getal te groot in {} waardegever"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "sluithaakje ] ontbreekt bij lettertekenklasse"
 
 # controleteken/sturingsteken/stuurcode/escape-teken
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "ongelde stuurcode in lettertekenklasse"
 
 # [Z-a]
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "bereik in verkeerde volgorde in lettertekenklasse"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "niets te herhalen"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "onbekend teken na (?"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "onbekend teken na (?<"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "onbekend teken na (?P"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "POSIX benoemde klassen zijn alleen ondersteund binnen een klasse"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "ontbrekend sluithaakje: )"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") zonder openingshaakje: ("
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R of (?[+-]cijfers moeten gevolgd worden door )"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "verwijzing naar een niet-bestaand subpatroon"
 
 # opmerking/commentaar
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "ontbrekend sluithaakje ) na commentaar"
 
 # te groot/te lang
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "reguliere expressie te groot"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "kon onvoldoende geheugen krijgen"
 
 # terugkijkbewering
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "‘lookbehind assertion’ heeft geen vaste lengte"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "foutief getal of naam na (?("
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "voorwaardelijke groep bevat meer dan twee vertakkingen"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "bewering verwacht na (?("
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "onbekende POSIX-klassenaam"
 
@@ -711,239 +712,241 @@ msgstr "onbekende POSIX-klassenaam"
 # het betreft het beschouwen van meerdere tekens als 1 teken
 # samengesteld teken
 # geordende elementen/samengestelde elementen
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "POSIX-samengestelde elementen worden niet ondersteund"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "lettertekenwaarde in de reeks \\x{...} is te groot"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "ongeldige voorwaarde (?(0)"
 
 # terugkijkbewering
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C niet toegestaan in ‘lookbehind assertion’"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "recursieve aanroep zou oneindig kunnen doorlopen"
 
 # afsluiter/afsluitteken
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "afsluitteken ontbreekt in naam subpatroon"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "twee genoemde subpatronen hebben dezelfde naam"
 
 # onjuist samengesteld/gevormd
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "onjuist gevormde \\P of \\p reeks"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "onbekende eigenschapnaam na \\P of \\p"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "naam van subpatroon is te lang (maximaal 32 tekens)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "teveel genoemde subpatronen (maximaal 10.000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "octale waarde is groter dan \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE-groep bevat meer dan één vertakking"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "herhalen van een DEFINE-groep is niet toegestaan"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "inconsistente NEWLINE-opties"
 
-#: glib/gregex.c:333
+#: ../glib/gregex.c:333
 msgid ""
 "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "\\g wordt niet gevolgd door een naam tussen haakjes, of getal niet gelijk "
 "aan nul, optioneel tussen haakjes"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "onverwachte herhaling"
 
 # te weinig geheugen voor code/code overstroomt/
 # programmacode loopt over
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "overstroming programmacode"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "compile-werkruimte is overlopen"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "eerder nagekeken gerefereerd subpatroon niet gevonden"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Fout bij reguliere expressie %s: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "PCRE-bibliotheek is gecompileerd zonder ondersteuning voor UTF8"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr ""
 "PCRE-bibliotheek is gecompileerd zonder ondersteuning voor UTF8-eigenschappen"
 
 # opbouwen/compileren
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "Fout bij compileren van reguliere expressie %s op teken %d:%s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Fout bij optimaliseren van reguliere expressie %s: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "hexadecimaal getal of ‘}’ verwacht"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "hexadecimaal getal verwacht"
 
 # tekort/ontbreekt/te weinig
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "‘<’ ontbreekt in verwijzing"
 
 # symbolische verwijzing
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "onafgemaakte verwijzing"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "verwijzing heeft nullengte"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "cijfer verwacht"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "ongeldige verwijzing"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "extra afsluiting ‘\\’"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "onbekende escape-reeks"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "Fout bij inlezen vervangende tekst ‘%s’ op teken %lu:%s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Aangehaalde tekst begint niet met een ‘\"’-teken"
 
 # solitair "-teken/ongebalanceerd
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr "Solitair ‘\"’-teken in opdrachtregel of andere shell-aangehaalde tekst"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "Tekst eindigde na een ‘\\’-teken (de tekst was ‘%s’)."
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr ""
 "De tekst eindigde voordat een afsluitend aanhalingsteken was gevonden voor %"
 "c (de tekst was ‘%s’)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "De tekst was leeg (of bevatte slechts lege ruimte)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Lezen van data van dochterproces is mislukt"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr ""
 "Aanmaken van pijplijn voor het communiceren met dochterproces is mislukt (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Lezen van pijplijn naar dochter (%s) is mislukt"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Wijzigen naar map ‘%s’ is mislukt (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Uitvoeren van dochterproces is mislukt (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Ongeldige programmanaam: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Ongeldige tekenreeks in argumentvector bij %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Ongeldige tekenreeks in omgeving: %s"
 
 # werkmap/huidige map
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Ongeldige werkmap: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Uitvoeren van het hulpprogramma (%s) is mislukt"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -951,141 +954,141 @@ msgstr ""
 "Onverwachte fout in g_io_channel_win32_poll() bij het lezen van data van een "
 "dochterproces"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Lezen van data van dochterproces is mislukt (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr ""
 "Onverwachte fout in select() bij het lezen van data van een dochterproces (%"
 "s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Onverwachte fout in waitpid() (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "De fork is mislukt (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Uitvoeren van dochterproces ‘%s’ is mislukt (%s)"
 
 # was eerst: herleiden
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr ""
 "Doorsluizen van invoer of uitvoer van een dochterproces is mislukt (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Het forken van een dochterproces is mislukt (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Onbekende fout bij het uitvoeren van dochterproces ‘%s’"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Lezen van voldoende data van pijplijn van dochter-pid is mislukt (%s)"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "Teken valt buiten het bereik van UTF-8"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123 ../glib/gutf8.c:1132 ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273 ../glib/gutf8.c:1414 ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "Ongeldige reeks in conversieinvoer"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425 ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "Teken valt buiten het bereik van UTF-16"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Gebruik:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[OPTIE...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Hulpopties:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Deze hulptekst tonen"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Alle hulpteksten tonen"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Programmaopties:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Kan het geheel getal ‘%s’ voor %s niet verwerken"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "Het geheel getal ‘%s’ voor %s valt buiten het bereik"
 
 # integer-double
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Kan het lange geheel getal ‘%s’ voor %s niet verwerken"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "Het lange geheel getal ‘%s’ voor %s valt buiten het bereik"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Fout bij verwerken van optie %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Ontbrekend argument voor %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Onbekende optie %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "Er kon geen geldig sleutelbestand gevonden worden in de zoekmappen"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Geen gewoon bestand"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "Bestand is leeg"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
 msgid ""
 "Key file contains line '%s' which is not a key-value pair, group, or comment"
@@ -1093,51 +1096,51 @@ msgstr ""
 "Sleutelbestand bevat regel ‘%s’ wat geen sleutelwaarde-paar, groep of "
 "opmerking is."
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Ongeldige groepsnaam: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "Het sleutelbestand start niet met een groep"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Ongeldige sleutelnaam: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Het sleutelbestand bevat de niet-ondersteunde tekenset ‘%s’"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Het sleutelbestand bevat geen groep ‘%s’"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "Het sleutelbestand bevat geen sleutel ‘%s’"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr ""
 "Het sleutelbestand bevat sleutel ‘%s’ met waarde ‘%s’ wat geen UTF-8 is"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr ""
 "Het sleutelbestand bevat sleutel ‘%s’ die een waarde heeft die niet "
 "geïnterpreteerd kan worden."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1146,151 +1149,153 @@ msgstr ""
 "Het sleutelbestand bevat sleutel ‘%s’ in groep ‘%s’ die een waarde heeft die "
 "niet geïnterpreteerd kan worden."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Het sleutelbestand bevat geen sleutel ‘%s’ in groep ‘%s’"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr ""
 "Het sleutelbestand bevat een ontsnappingsteken aan het einde van een regel"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Het sleutelbestand bevat ongeldige ontsnappingstekens ‘%s’"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "De waarde ‘%s’ kan niet geïnterpreteerd worden als een getal."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Het geheel getal ‘%s’ valt buiten het bereik"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr ""
 "De waarde ‘%s’ kan niet geïnterpreteerd worden als een getal van het type "
 "float."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "De waarde ‘%s’ kan niet geïnterpreteerd worden als een boolese."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "De telwaarde die aan %s werd gegeven is te groot"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "De stroom is al gesloten"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623 ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "De bewerking werd afgebroken"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Onbekend type"
 
 # bestandssoort/bestandstype
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "bestandstype %s"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "type %s"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Voortijdig einde aan gegevensstroom"
 
 # naamloos/zonder naam/onbenoemd
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Zonder naam"
 
 # bureaubladbestand/desktopbestand
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "Desktopbestand bevat geen Exec-veld"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Kan geen terminalvenster vinden voor het uitvoeren van het programma"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "Kan persoonlijke programmaconfiguratiemap %s niet aanmaken: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Kan persoonlijke MIME-configuratiemap %s niet aanmaken: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Kan desktopbestand %s niet aanmaken"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "Zelfgemaakte definitie voor %s"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "dit station begrijpt de opdracht ‘uitwerpen’ niet"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "dit station kan niet onderzocht worden op de aanwezigheid van media"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "Kan versie %d van GEmblem-codering niet verwerken"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "Onjuist aantal tokens (%d) in GEmblem-codering"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr ""
+msgstr "Kan versie %d van GEmblemedIcon-codering niet verwerken"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr ""
+msgstr "Onjuist aantal tokens (%d) in GEmblemedIcon-codering"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
+msgstr "GEmblem voor GEmblemedIcon verwacht"
 
 # niet ondersteund/niet mogelijk
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "De bewerking is niet mogelijk"
 
@@ -1303,141 +1308,142 @@ msgstr "De bewerking is niet mogelijk"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "Het koppelpunt hiervan bestaat niet"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Kan niet over map kopiëren"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "Kan map niet over map kopiëren"
 
 # er is al een bestand met die naam?
 # Het doelbestand bestaat (al)
 # er was ook een msgid: Target file already exists
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Doelbestand bestaat al"
 
 # map/de map
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "Kan map niet recursief kopiëren"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Ongeldige symbolische verwijzing gegeven"
 
 # wordt hier niet ondersteund
 # (dus bijv. op een aangekoppelde externe opslag?)
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "Prullenbak wordt ondersteund"
 
 # Een bestandsnaam mag het teken / niet bevatten
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Het teken ‘%c’ mag niet in een bestandsnaam voorkomen"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "volumen begrijpt de opdracht ‘aankoppelen’ niet"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Er is geen programma toegewezen om dit bestand te openen"
 
 # opsomming/teller
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Teller is gesloten"
 
 # hmm
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "Bestandsteller bevat een lopende bewerking"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Bestandsteller is al gesloten"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "bestand"
 
 # dat het pictogram bevat/met het pictogram
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Een bestand met het pictogram"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "Kan versie %d van GFileIcon-codering niet verwerken"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "Ongeldige invoergegevens voor GFileIcon"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Datastroom ondersteunt query_info niet"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Zoeken binnen datastroom niet mogelijk"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "Afkappen is niet toegestaan op een invoerdatastroom"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Afkappen wordt niet ondersteund op een datastroom"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "Verkeerd aantal tokens (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "Geen type voor klassenaam %s"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "Type %s implementeert de GIcon-interface niet"
 
-#: gio/gicon.c:365
+# Uhhh? (Wouter Bolsterlee)
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "Type %s is niet ‘classed’"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "Onjuist versienummer: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
+msgstr "Type %s implementeert from_tokens() op de GIcon-interface niet"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "Kan de opgegeven versie in de pictogram-codering niet verwerken"
 
 # huh?
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "Invoerdatastroom begrijpt de opdracht ‘lezen’ niet"
 
@@ -1448,304 +1454,304 @@ msgstr "Invoerdatastroom begrijpt de opdracht ‘lezen’ niet"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Datastroom is nog bezig"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Kon de standaard ‘directory monitor type’ niet vinden"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Ongeldige bestandsnaam: %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Fout bij het ophalen van informatie over bestandssysteem: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Kan de root-map niet hernoemen"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Fout bij het hernoemen van bestand: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "Kan het bestand niet hernoemen, de bestandsnaam bestaat al"
 
 # ongeldige naam voor bestand/ongeldige bestandsnaam
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "Ongeldige bestandsnaam"
 
 # openen/lezen
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Fout bij het openen van bestand: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "Kan map niet openen"
 
 # volledig verwijderen/definitief verwijderen/verwijderen
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Fout bij het verwijderen van bestand: %s"
 
 # naar prullenbak verplaatsen/verwijderen
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Fout bij het verplaatsen naar de prullenbak van bestand: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Kan de prullenbakmap %s niet aanmaken: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Kan de bovenliggende map voor de prullenbak niet vinden"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Kan prullenbakmap niet vinden of aanmaken"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Kan prullenbak-informatiebestand ‘%s’ niet aanmaken"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Kan het bestand ‘%s’ niet naar de prullenbak verplaatsen"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Fout bij het aanmaken van map: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Fout bij het maken van symbolische verwijzing: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Fout bij het verplaatsen van bestand: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "Kan map niet over map verplaatsen"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833 ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864 ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "Aanmaken van backupbestand is mislukt"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Fout bij het verwijderen doelbestand: %s"
 
 # (nog) niet mogelijk/niet ondersteund
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "Verplaatsen tussen aankoppelpunten is niet mogelijk"
 
 # technotalk
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Attribuutwaarde moet niet-NULL zijn"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Ongeldig attribuuttype (hoort een tekenreeks te zijn)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Ongeldige uitgebreide attribuutnaam"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Fout bij het instellen van uitgebreid attribuut ‘%s’: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464 ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Fout bij het benaderen van bestand ‘%s’: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (ongeldige codering)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
-msgstr "Fout bij het benaderen van ‘file descriptor’: %s"
+msgstr "Fout bij het benaderen van bestandsdescriptor: %s"
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Ongeldig attribuuttype (hoort een uint32 te zijn)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Ongeldig attribuuttype (hoort een uint64 te zijn)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784 ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Ongeldig attribuuttype (hoort een byte-tekenreeks te zijn)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Fout bij instellen toegangsrechten: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880 ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Fout bij instellen eigenaar: %s"
 
 # technotalk
 # symlink/symbolische verwijzing
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "symbolische verwijzing moet niet-NULL zijn"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913 ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Fout bij instellen symbolische verwijzing: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
 msgstr ""
 "Fout bij instellen symbolische verwijzing: bestand is geen symbolische "
 "verwijzing"
 
 # technotalk
-#: gio/glocalfileinfo.c:2071
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
 msgstr "SELinux-context moet niet-NULL zijn"
 
-#: gio/glocalfileinfo.c:2086
+#: ../gio/glocalfileinfo.c:2086
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Fout bij instellen SELinux-context: %s"
 
 # geactiveerd/aangezet
 # systeem/computer
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
 msgstr "SELinux is niet geactiveerd op dit systeem"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "Instellen van attribuut %s is niet mogelijk"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Fout bij het lezen van bestand: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Fout bij het doorzoeken van bestand: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Fout bij het sluiten van bestand: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Kon de standaard ‘file monitor type’ niet vinden"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Fout bij het schrijven naar bestand: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Fout bij verwijderen van oude verwijzing naar reservekopie: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Fout bij het aanmaken van reservekopie: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Fout bij het hernoemen van tijdelijk bestand: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Fout bij het afkappen bestand: %s"
 
 # lezen/openen
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688 ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Fout bij het openen van bestand ‘%s’: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "Doelbestand is geen map"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "Doelbestand is geen gewoon bestand"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "Het bestand is door een ander programma gewijzigd"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "Ongeldig GSeekType geleverd"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Ongeldige zoekopdracht"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "Kan GMemoryInputStream niet afkappen"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "Maximum data-arraylimiet bereikt"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "Wijzigen van geheugenruimte uitvoerdatastroom is niet mogelijk"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Wijzigen van geheugenruimte uitvoerdatastroom is mislukt"
 
@@ -1755,71 +1761,71 @@ msgstr "Wijzigen van geheugenruimte uitvoerdatastroom is mislukt"
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "ontkoppelen niet ondersteund door koppeling"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "uitwerpen niet ondersteund door koppeling"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "opnieuw koppelen niet ondersteund door koppeling"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "inhoudstype raden niet ondersteund door koppeling"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "op synchrone wijze inhoudstype raden niet ondersteund door koppeling"
 
 # uitvoerdatastroom begrijpt de opdracht 'scrijven' niet
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "schrijven wordt niet ondersteund door de uitvoerdatastroom"
 
 # bronstroom/datastroom van de bron
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "Datastroom is al gesloten"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "naam"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Naam van het pictogram"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "namen"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Een lijst met de pictogramnamen"
 
 # Vrij vertaald (Wouter Bolsterlee)
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "standaard terugvalmechanisme gebruiken"
 
 # Vrij vertaald (Wouter Bolsterlee)
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1828,92 +1834,93 @@ msgstr ""
 "het ‘-’-teken af te knippen. Als meerdere namen worden gegeven wordt de "
 "eerste gebruikt."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "Kan versie %d van GThemedIcon-codering niet verwerken"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+# Expres onvertaald (Wouter Bolsterlee)
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "Bestandsdescriptor"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "De bestandsdescriptor om van te lezen"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
-msgstr "Fout bij het benaderen van ‘file descriptor’: %s"
+msgstr "Bestandsdescriptor sluiten"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
 msgstr ""
+"Of de bestandsdescriptor gesloten moet worden als de stream wordt gesloten"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Fout bij lezen van unix: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Fout bij sluiten van unix: %s"
 
 # hoofdmap van bestandssysteem
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Hoofdmap bestandssysteem"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "De bestandsdescriptor om naar te schrijven"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Fout bij schrijven naar unix: %s"
 
 # volumen kan niet uitgeworpen worden/implemeteert 'uitwerpen' niet/
 # begrijpt de opdracht 'uitwerpen' niet
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "volumen begrijpt de opdracht ‘uitwerpen’ niet"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Kan het programma niet vinden"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Fout bij het opstarten van het programma: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URI's worden niet ondersteund"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "associatiewijzigingen niet mogelijk op win32"
 
 # Associeren/associaties aanmaken
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "Associaties aanmaken niet mogelijk op win32"
 
 # vrij vertaald
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "ook de verborgen items tonen"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "gebruik een uitgebreide opsomming"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[BESTAND...]"
 
diff --git a/po/th.po b/po/th.po
index a415e35..3b8db45 100644
--- a/po/th.po
+++ b/po/th.po
@@ -1,7 +1,7 @@
 # Thai translation of glib.
-# Copyright (C) 2005-2008 Free Software Foundation, Inc.
+# Copyright (C) 2005-2009 Free Software Foundation, Inc.
 # This file is distributed under the same license as the glib package.
-# Theppitak Karoonboonyanan <thep@linux.thai.net>, 2005-2008.
+# Theppitak Karoonboonyanan <thep@linux.thai.net>, 2005-2009.
 #
 #
 msgid ""
@@ -9,7 +9,7 @@ msgstr ""
 "Project-Id-Version: glib 2.14.1\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2008-08-23 17:58+0700\n"
+"PO-Revision-Date: 2009-02-06 18:11+0700\n"
 "Last-Translator: Theppitak Karoonboonyanan <thep@linux.thai.net>\n"
 "Language-Team: Thai <thai-l10n@googlegroups.com>\n"
 "MIME-Version: 1.0\n"
@@ -1169,26 +1169,26 @@ msgstr "ไดรว์ไม่สามารถใช้คำสั่งต
 #: gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "ไม่สามารถจัดการกับรหัสของ GEmblem รุ่น %d ได้"
 
 #: gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "จำนวนโทเคนในรหัสของ GEmblem (%d) ไม่ถูกต้อง"
 
 #: gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr ""
+msgstr "ไม่สามารถจัดการกับรหัสของ GEmblemedIcon รุ่น %d ได้"
 
 #: gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr ""
+msgstr "จำนวนโทเคนในรหัสของ GEmblemedIcon (%d) ไม่ถูกต้อง"
 
 #: gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
+msgstr "ต้องการข้อมูล GEmblem สำหรับ GEmblemedIcon"
 
 #: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
 #: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
@@ -1272,11 +1272,11 @@ msgstr "แฟ้มที่เก็บไอคอน"
 #: gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "ไม่สามารถจัดการกับรหัสของ GFileIcon รุ่น %d ได้"
 
 #: gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "ข้อมูลเข้าของ GFileIcon ไม่ถูกต้อง"
 
 #: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
 #: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
@@ -1298,36 +1298,36 @@ msgstr "สตรีมไม่รองรับการตัดท้าย
 #: gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "จำนวนโทเคน (%d) ไม่ถูกต้อง"
 
 #: gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "ไม่มีชนิดสำหรับคลาสชื่อ %s"
 
 #: gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "ชนิด %s ไม่ได้ทำอินเทอร์เฟซ GIcon"
 
 #: gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "ชนิด %s ไม่ได้เป็นคลาส"
 
 #: gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "เลขรุ่นมีรูปแบบไม่ถูกต้อง: %s"
 
 #: gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
+msgstr "ชนิด %s ไม่ได้ทำ from_tokens() ของอินเทอร์เฟซ GIcon"
 
 #: gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "ไม่สามารถจัดการกับรหัสของไอคอนรุ่นที่ระบุได้"
 
 #: gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
@@ -1700,24 +1700,23 @@ msgstr ""
 #: gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "ไม่สามารถจัดการกับรหัสของ GThemedIcon รุ่น %d ได้"
 
 #: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "File descriptor"
 
 #: gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "File descriptor ที่จะอ่าน"
 
 #: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
 msgid "Close file descriptor"
-msgstr "เกิดข้อผิดพลาดขณะ stat file descriptor: %s"
+msgstr "ปิด file descriptor"
 
 #: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
-msgstr ""
+msgstr "กำหนดว่าจะปิด file descriptor ด้วยหรือไม่ เมื่อปิดสตรีม"
 
 #: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
 #: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
@@ -1737,7 +1736,7 @@ msgstr "รากระบบแฟ้ม"
 
 #: gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "File descriptor ที่จะเขียน"
 
 #: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
 #, c-format
diff --git a/po/vi.po b/po/vi.po
index d0355bd..03cfa92 100644
--- a/po/vi.po
+++ b/po/vi.po
@@ -1,1240 +1,1242 @@
 # Vietnamese translation for GLib.
-# Copyright © 2008 Gnome i18n Project for Vietnamese.
+# Copyright © 2009 GNOME i18n Project for Vietnamese.
 # T.M.Thanh <tmthanh@yahoo.com>, 2002.
-# Clytie Siddall <clytie@riverland.net.au>, 2005-2008.
+# Clytie Siddall <clytie@riverland.net.au>, 2005-2009.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: glib GNOME TRUNK\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-02 14:45-0500\n"
-"PO-Revision-Date: 2008-08-22 11:52+0700\n"
+"Project-Id-Version: glib 2.19.6\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=glib&component=general\n"
+"POT-Creation-Date: 2009-02-02 20:09+0000\n"
+"PO-Revision-Date: 2009-02-07 19:26+0930\n"
 "Last-Translator: Clytie Siddall <clytie@riverland.net.au>\n"
-"Language-Team: Vietnamese <gnomevi-list@lists.sourceforge.net>\n"
+"Language-Team: Vietnamese <vi-VN@googlegroups.com>\n"
 "MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=utf-8\n"
+"Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: LocFactoryEditor 1.7b1\n"
+"X-Generator: LocFactoryEditor 1.8\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Thuộc tính bất thường « %s » cho yếu tố « %s »"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748
+#: ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829
+#: ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "Không tìm thấy thuộc tính « %s » của yếu tố « %s »"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106
+#: ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235
+#: ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Thẻ bất thường « %s », mong đợi thẻ « %s »"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131
+#: ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213
+#: ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Thẻ bất thường « %s » bên trong « %s »"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "Không tìm thấy tập tin liên kết lưu hợp lệ trong các thư mục dữ liệu"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Một liên kết lưu URI « %s » đã có"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040
+#: ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283
+#: ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448
+#: ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609
+#: ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730
+#: ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953
+#: ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219
+#: ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473
+#: ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "Không tìm thấy liên kết lưu URI « %s »"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "Chưa xác định kiểu MIME trong liên kết lưu URI « %s »"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "Chưa xác định cờ riêng trong liên kết lưu URI « %s »"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "Chưa đặt nhóm trong liên kết lưu URI « %s »"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237
+#: ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr "Không có ứng dụng tên « %s » đã đăng ký một liên kết lưu « %s »"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Lỗi mở rộng dòng thực hiện « %s » bằng URI « %s »"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431
+#: ../glib/gconvert.c:509
+#: ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "Không hỗ trợ khả năng chuyển đổi từ bộ ký tự « %s » sang « %s »"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435
+#: ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "Không thể mở bộ chuyển đổi từ « %s » sang « %s »"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:955
-#: glib/gutf8.c:1404
+#: ../glib/gconvert.c:632
+#: ../glib/gconvert.c:1017
+#: ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444
+#: ../glib/giochannel.c:2288
+#: ../glib/gutf8.c:955
+#: ../glib/gutf8.c:1404
 msgid "Invalid byte sequence in conversion input"
 msgstr "Gặp dây byte không hợp lệ trong dữ liệu nhập chuyển đổi"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638
+#: ../glib/gconvert.c:944
+#: ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Gặp lỗi khi chuyển đổi: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:951 glib/gutf8.c:1155 glib/gutf8.c:1296
-#: glib/gutf8.c:1400
+#: ../glib/gconvert.c:669
+#: ../glib/gutf8.c:951
+#: ../glib/gutf8.c:1155
+#: ../glib/gutf8.c:1296
+#: ../glib/gutf8.c:1400
 msgid "Partial character sequence at end of input"
 msgstr "Dây ký tự riêng phần ở cuối dữ liệu nhập"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Không thể chuyển đổi đồ dữ trữ « %s » thành bộ mã « %s »"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
-msgstr ""
-"URI « %s » không phải là một URI tuyệt đối sử dụng lược đồ « file » (tập tin)"
+msgstr "URI « %s » không phải là một URI tuyệt đối sử dụng lược đồ « file » (tập tin)"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "Không cho phép URI tập tin cục bộ « %s » chứa dấu thăng « # »"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "URI « %s » không hợp lệ"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "Tên máy của URI « %s » không hợp lệ"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "URI « %s » chứa một số ký tự đã thoát không hợp lệ"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "Tên đường dẫn « %s » không phải là một đường dẫn tuyệt đối"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Tên máy không hợp lệ"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110
+#: ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Gặp lỗi khi mở thư mục « %s »: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532
+#: ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Không thẻ cấp phát %lu byte để đọc tập tin « %s »"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Gặp lỗi khi đọc tập tin « %s »: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "Tập tin \"%s\" quá lớn"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Lỗi đọc từ tập tin « %s »: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695
+#: ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Lỗi mở tập tin « %s »: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712
+#: ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr "Lỗi lấy các thuộc tính của tập tin « %s »: lỗi « fstat() »: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "Lỗi mở tập tin « %s »: lỗi « fdopen() »: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr "Lỗi thay đổi tên tập tin « %s » thành « %s »: lỗi « g_rename() »: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895
+#: ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Lỗi tạo tập tin « %s »: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr "Lỗi mở tập tin « %s »: lỗi « fdopen() »: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Lỗi ghi tập tin « %s »: lỗi « fdopen() »: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Lỗi đóng tập tin « %s »: lỗi « fclose() »: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr "Không thể gỡ bỏ tập tin tồn tại « %s »: lỗi « g_unlink() »: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "Biểu mẫu « %s » không hợp lệ, không nên chứa « %s »"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "Biểu mẫu « %s » không chứa XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Lỗi đọc liên kết tượng trưng « %s »: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "Không hỗ trợ khả năng sử dụng liên kết tượng trưng"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "Không thể mở bộ chuyển đổi từ « %s » sang « %s »: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
-msgstr ""
-"Không thể thực hiện tiến trình đọc thô trong « g_io_channel_read_line_string »"
+msgstr "Không thể thực hiện tiến trình đọc thô trong « g_io_channel_read_line_string »"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626
+#: ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Có dữ liệu chưa được chuyển đổi còn lại nằm trong bộ đệm đọc"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707
+#: ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "Kênh tận hết trong ký tự riêng phần"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
-msgstr ""
-"Không thể thực hiện tiến trình đọc thô trong « g_io_channel_read_to_end »"
+msgstr "Không thể thực hiện tiến trình đọc thô trong « g_io_channel_read_to_end »"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Lỗi mở tập tin « %s »: lỗi « fdopen() »: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Lỗi ánh xạ tập tin « %s »: lỗi « mmap() »: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255
+#: ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Lỗi trên dòng %d ký tự %d: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Lỗi trên dòng %d: %s"
 
-#: glib/gmarkup.c:493
-msgid ""
-"Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
-msgstr ""
-"Thấy thực thể rỗng « &; »; những thực thể hợp lệ là: &amp; &quot; &lt; &gt; "
-"&apos;"
+#: ../glib/gmarkup.c:493
+msgid "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+msgstr "Thấy thực thể rỗng « &; »; những thực thể hợp lệ là: &amp; &quot; &lt; &gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
-msgid ""
-"Character '%s' is not valid at the start of an entity name; the & character "
-"begins an entity; if this ampersand isn't supposed to be an entity, escape "
-"it as &amp;"
-msgstr ""
-"Ký tự « %s » không phải là hợp lệ ở đầu của tên thực thể; ký tự « & » khởi đầu "
-"một thực thể; nếu dấu và này không nên là một thực thể, hãy thoát nó như là « "
-"&amp; »"
+msgid "Character '%s' is not valid at the start of an entity name; the & character begins an entity; if this ampersand isn't supposed to be an entity, escape it as &amp;"
+msgstr "Ký tự « %s » không phải là hợp lệ ở đầu của tên thực thể; ký tự « & » khởi đầu một thực thể; nếu dấu và này không nên là một thực thể, hãy thoát nó như là « &amp; »"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "Ký tự « %s » không phải là hợp lệ bên trong tên thực thể"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "Không biết tên thực thể « %s »"
 
-#: glib/gmarkup.c:585
-msgid ""
-"Entity did not end with a semicolon; most likely you used an ampersand "
-"character without intending to start an entity - escape ampersand as &amp;"
-msgstr ""
-"Thực thể không có dấu chấm phẩy cuối cùng; dường như bạn đã dùng dấu và mà "
-"không định bắt đầu một thực thể — hãy thoát dấu và như là « &amp; »"
+#: ../glib/gmarkup.c:585
+msgid "Entity did not end with a semicolon; most likely you used an ampersand character without intending to start an entity - escape ampersand as &amp;"
+msgstr "Thực thể không có dấu chấm phẩy cuối cùng; dường như bạn đã dùng dấu và mà không định bắt đầu một thực thể — hãy thoát dấu và như là « &amp; »"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
-msgid ""
-"Failed to parse '%-.*s', which should have been a digit inside a character "
-"reference (&#234; for example) - perhaps the digit is too large"
-msgstr ""
-"Lỗi phân tách « %-.*s », nó nên là một chữ số bên trong một tham chiếu ký tự "
-"(v.d. « &#234 ») — có lẽ chư số quá lớn."
+msgid "Failed to parse '%-.*s', which should have been a digit inside a character reference (&#234; for example) - perhaps the digit is too large"
+msgstr "Lỗi phân tách « %-.*s », nó nên là một chữ số bên trong một tham chiếu ký tự (v.d. « &#234 ») — có lẽ chư số quá lớn."
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "Tham chiếu ký tự « %-.*s » không mã hóa một ký tự được phép."
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "Tham chiếu ký tự trống; nên chứa chữ số như là « &#454; »."
 
-#: glib/gmarkup.c:685
-msgid ""
-"Character reference did not end with a semicolon; most likely you used an "
-"ampersand character without intending to start an entity - escape ampersand "
-"as &amp;"
-msgstr ""
-"Tham chiếu ký tự không có dấu chấm phẩy cuối cùng; dường như bạn đã dùng một "
-"dấu và mà không định bắt đầu một thực thể — hãy thoát dấu và như là « &amp; »"
+#: ../glib/gmarkup.c:685
+msgid "Character reference did not end with a semicolon; most likely you used an ampersand character without intending to start an entity - escape ampersand as &amp;"
+msgstr "Tham chiếu ký tự không có dấu chấm phẩy cuối cùng; dường như bạn đã dùng một dấu và mà không định bắt đầu một thực thể — hãy thoát dấu và như là « &amp; »"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Tham chiếu thực thể chưa hoàn thành"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Tham chiếu ký tự chưa hoàn thành"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "Văn bản được mã hoá UTF-8 không hợp lệ: dáy quá dài"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "Văn bản được mã hoá UTF-8 không hợp lệ: không phải ký tự bắt đầu"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "Văn bản được mã hoá UTF-8 không hợp lệ: không phải « %s » hợp lệ"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Tài liệu phải bắt đầu bằng một yếu tố (v.d. <book> [quyển sách])"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
-msgid ""
-"'%s' is not a valid character following a '<' character; it may not begin an "
-"element name"
-msgstr ""
-"« %s » không phải là một ký tự hợp lệ đi theo một dấu ngoặc nhọn mở « < » ; "
-"không cho phép nó bắt đầu một tên yếu tố"
+msgid "'%s' is not a valid character following a '<' character; it may not begin an element name"
+msgstr "« %s » không phải là một ký tự hợp lệ đi theo một dấu ngoặc nhọn mở « < » ; không cho phép nó bắt đầu một tên yếu tố"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
-msgid ""
-"Odd character '%s', expected a '>' character to end the empty-element tag '%"
-"s'"
-msgstr ""
-"Ký tự lạ « %s », mong đợi một dấu ngoặc nhọn đóng « > » để kết thúc thẻ rỗng « %"
-"s »"
+msgid "Odd character '%s', expected a '>' character to end the empty-element tag '%s'"
+msgstr "Ký tự lạ « %s », mong đợi một dấu ngoặc nhọn đóng « > » để kết thúc thẻ rỗng « %s »"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
-msgid ""
-"Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
-msgstr ""
-"Ký tự lạ « %s », mong đợi một dấu bằng « = » nằm sau tên thuộc tính « %s » của "
-"yếu tố « %s »"
+msgid "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
+msgstr "Ký tự lạ « %s », mong đợi một dấu bằng « = » nằm sau tên thuộc tính « %s » của yếu tố « %s »"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
-msgid ""
-"Odd character '%s', expected a '>' or '/' character to end the start tag of "
-"element '%s', or optionally an attribute; perhaps you used an invalid "
-"character in an attribute name"
-msgstr ""
-"Ký tự lạ « %s », mong đợi một dấu ngoặc nhọn đóng « > » hay dấu xuyệc « / » để "
-"kết thúc thẻ khởi đầu của yếu tố « %s », hay tùy ý một thuộc tính; có lẽ bạn "
-"đã dùng một ký tự không hợp lệ trong một tên thuộc tính."
+msgid "Odd character '%s', expected a '>' or '/' character to end the start tag of element '%s', or optionally an attribute; perhaps you used an invalid character in an attribute name"
+msgstr "Ký tự lạ « %s », mong đợi một dấu ngoặc nhọn đóng « > » hay dấu xuyệc « / » để kết thúc thẻ khởi đầu của yếu tố « %s », hay tùy ý một thuộc tính; có lẽ bạn đã dùng một ký tự không hợp lệ trong một tên thuộc tính."
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
-msgid ""
-"Odd character '%s', expected an open quote mark after the equals sign when "
-"giving value for attribute '%s' of element '%s'"
-msgstr ""
-"Ký tự lạ « %s », mong đợi một dấu nháy kép mở nằm sau dấu bằng khi đưa giá "
-"trị cho thuộc tính « %s » của yếu tố « %s »"
+msgid "Odd character '%s', expected an open quote mark after the equals sign when giving value for attribute '%s' of element '%s'"
+msgstr "Ký tự lạ « %s », mong đợi một dấu nháy kép mở nằm sau dấu bằng khi đưa giá trị cho thuộc tính « %s » của yếu tố « %s »"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
-msgid ""
-"'%s' is not a valid character following the characters '</'; '%s' may not "
-"begin an element name"
-msgstr ""
-"« %s » không phải là một ký tự hợp lệ nằm theo các ký tự « </ » ; không cho "
-"phép « %s » bắt đầu một tên yếu tố"
+msgid "'%s' is not a valid character following the characters '</'; '%s' may not begin an element name"
+msgstr "« %s » không phải là một ký tự hợp lệ nằm theo các ký tự « </ » ; không cho phép « %s » bắt đầu một tên yếu tố"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
-msgid ""
-"'%s' is not a valid character following the close element name '%s'; the "
-"allowed character is '>'"
-msgstr ""
-"« %s »  không phải là một ký tự hợp lệ nằm theo tên yếu tố đóng « %s »; ký tự "
-"được phép là « > »."
+msgid "'%s' is not a valid character following the close element name '%s'; the allowed character is '>'"
+msgstr "« %s »  không phải là một ký tự hợp lệ nằm theo tên yếu tố đóng « %s »; ký tự được phép là « > »."
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "Yếu tố « %s » đã được đóng, không có yếu tố mở hiện thời"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "Yếu tố « %s » đã được đóng, nhưng yếu tố mở hiện thời là « %s »"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "Tài liệu rỗng hay chứa chỉ khoảng trắng"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "Tài liệu đã kết thúc bất thường ngay sau một dấu ngoặc nhọn mở « < »"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880
+#: ../glib/gmarkup.c:1925
 #, c-format
-msgid ""
-"Document ended unexpectedly with elements still open - '%s' was the last "
-"element opened"
-msgstr ""
-"Tài liệu đã kết thúc bất thường với các yếu tố vẫn còn mở — « %s » là yếu tố "
-"đã mở cuối cùng"
+msgid "Document ended unexpectedly with elements still open - '%s' was the last element opened"
+msgstr "Tài liệu đã kết thúc bất thường với các yếu tố vẫn còn mở — « %s » là yếu tố đã mở cuối cùng"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
-msgid ""
-"Document ended unexpectedly, expected to see a close angle bracket ending "
-"the tag <%s/>"
-msgstr ""
-"Tài liệu kết thúc bất thường, mong đợi thấy dấu ngoặc nhọn đóng kết thúc thẻ "
-"« <%s/> »"
+msgid "Document ended unexpectedly, expected to see a close angle bracket ending the tag <%s/>"
+msgstr "Tài liệu kết thúc bất thường, mong đợi thấy dấu ngoặc nhọn đóng kết thúc thẻ « <%s/> »"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Tài liệu đã kết thúc bất thường bên trong một tên yếu tố"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Tài liệu đã kết thúc bất thường bên trong một tên thuộc tính"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "Tài liệu đã kết thúc bất thường bên trong một thẻ mở yếu tố"
 
-#: glib/gmarkup.c:1911
-msgid ""
-"Document ended unexpectedly after the equals sign following an attribute "
-"name; no attribute value"
-msgstr ""
-"Tài liệu đã kết thúc bất thường sau dấu bằng nằm sau một tên thuộc tính; "
-"không có giá trị thuộc tính"
+#: ../glib/gmarkup.c:1911
+msgid "Document ended unexpectedly after the equals sign following an attribute name; no attribute value"
+msgstr "Tài liệu đã kết thúc bất thường sau dấu bằng nằm sau một tên thuộc tính; không có giá trị thuộc tính"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
-msgstr ""
-"Tài liệu đã kết thúc bất thường trong khi nằm trong một giá trị thuộc tính"
+msgstr "Tài liệu đã kết thúc bất thường trong khi nằm trong một giá trị thuộc tính"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "Tài liệu đã kết thúc bất thường bên trong thẻ đóng cho yếu tố « %s »"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
-msgstr ""
-"Tài liệu đã kết thúc bất thường bên trong một chú thích hay hướng dẫn xử lý"
+msgstr "Tài liệu đã kết thúc bất thường bên trong một chú thích hay hướng dẫn xử lý"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "đối tượng bị hỏng"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "lỗi nội bộ hay đối tượng bị hỏng"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "hết bộ nhớ"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "không thể rút lùi nữa"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152
+#: ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr "mẫu chứa mục không được hỗ trợ khi khớp bộ phận"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154
+#: ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "lỗi nội bộ"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "khi khớp bộ phận, không hỗ trợ rút lui làm điều kiện"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "không thể đề qui nữa"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "vùng làm việc không thể chứa chuỗi con rỗng nữa"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "kết hợp cờ dòng mới một cách không hợp lệ"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "lỗi lạ"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ ở kết thúc của mẫu"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c ở kết thúc của mẫu"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "có ký tự lạ phía sau \\"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
-msgstr ""
-"ở đây thì không cho phép ký tự thoát thay đổi chữ hoa/thường (\\l, \\L, \\u, "
-"\\U)"
+msgstr "ở đây thì không cho phép ký tự thoát thay đổi chữ hoa/thường (\\l, \\L, \\u, \\U)"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "các con số không theo thứ tự đúng trong chuỗi xác định số lượng {}"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "con số quá lớn trong chuỗi xác định số lượng {}"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "thiếu ] chấm dứt cho hạng ký tự"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "gặp dây thoát không hợp lệ trong hạng ký tự"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "phạm vi không theo thứ tự đúng trong hạng ký tự"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "không có gì cần lặp lại"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "không nhận dạng ký tự nằm sau (?"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "không nhận dạng ký tự nằm sau (?<"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "không nhận dạng ký tự nằm sau (?P"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "Hạng POSIX có tên chỉ được hỗ trợ bên trong hạng"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "thiếu ) chấm dứt"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr "có ) không có ( đầu tiên"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R hay (?[+-]chữ số phải có ) theo sau"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "tham chiếu đến mẫu phụ không tồn tại"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "thiếu ) nằm sau chú thích"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "biểu thức chính quy quá lớn"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "không lấy được bộ nhớ"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "khẳng định lookbehind (thấy ở sau) không có độ dài cố định"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "có con số hay tên dạng sai nằm sau (?("
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "nhóm điều kiện chứa nhiều hơn hai nhánh"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "mong đợi khẳng định nằm sau (?("
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "không rõ tên hạng POSIX"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "Không hỗ trợ yếu tố đối chiếu POSIX"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "dãy \\x{...} chứa giá trị ký tự quá lớn"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "điều kiện không hợp lệ (?(0)"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C không được phép trong khẳng định lookbehind (thấy ở sau)"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "lời gọi đệ quy có thể bị lặp vô hạn"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "thiếu dấu chấm dứt trong tên mẫu phụ"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "hai mẫu phụ có tên cũng có cùng một tên"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "dãy \\P hay \\p dạng sai"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "có tên thuộc tính không rõ nằm sau \\P hay \\p"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "tên mẫu phụ quá dài (tối đa 32 ký tự)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "quá nhiều mẫu phụ có tên (tối đa 10 000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "giá trị bát phân lớn hơn \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "nhóm DEFINE (định nghĩa) chứa nhiều hơn một nhánh"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "không cho phép lặp lại một nhóm DEFINE (định nghĩa)"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "các tùy chọn NEWLINE (dòng mới) không thống nhất với nhau"
 
-#: glib/gregex.c:333
-msgid ""
-"\\g is not followed by a braced name or an optionally braced non-zero number"
-msgstr ""
-"\\g không đi trước một tên có dấu ngoặc móc hoặc một con số không phải số "
-"không có dấu ngoặc móc tùy chọn"
+#: ../glib/gregex.c:333
+msgid "\\g is not followed by a braced name or an optionally braced non-zero number"
+msgstr "\\g không đi trước một tên có dấu ngoặc móc hoặc một con số không phải số không có dấu ngoặc móc tùy chọn"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "lặp lại bất thường"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "tràn mã"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "tràn vùng làm việc biên dịch"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "không tìm thấy mẫu phụ đã tham chiếu mà đã kiểm tra trước"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526
+#: ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Gặp lỗi trong khi khớp biểu thức chính quy %s: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "Thư viện PCRE đã biên dịch không có khả năng hỗ trợ UTF-8"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "Thư viện PCRE đã biên dịch không có khả năng hỗ trợ tài sản UTF-8"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "Gặp lỗi trong khi biên dịch biểu thức chính quy %s ở ký tự %d: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Gặp lỗi trong khi tối hưu hoá biểu thức chính quy %s: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "đợi chữ số thập lục hay dấu ngoặc móc đóng « } »"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "đợi chữ số thập lục"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "thiếu dấu ngoặc nhọn mở « < » trong tham chiếu tượng trưng"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "tham chiếu tượng trưng chưa hoàn thành"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "tham chiếu tượng trưng có độ dài số không"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "đợi chữ số"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "tham chiếu tượng trưng không cho phép"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "dấu xuyệc ngược kết thúc rải rác « \\ »"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "dãy thoạt lạ"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "Gặp lỗi trong khi phân tách văn bản thay thế « %s » ở ký tự %lu: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Văn bản trích dẫn không bắt đầu bằng một dấu trích dẫn"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
-msgstr ""
-"Dấu ngoặc kép không ăn khớp nằm trên dòng lệnh hay trong văn bản khác đã "
-"trích dẫn trong trình bao"
+msgstr "Dấu ngoặc kép không ăn khớp nằm trên dòng lệnh hay trong văn bản khác đã trích dẫn trong trình bao"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "Văn bản đã kết thúc ngay sau dấu xuyệc ngược « \\ » (văn bản là « %s »)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
-msgstr ""
-"Văn bản đã kết thúc trước khi tìm dấu ngoặc kép tương ứng với « %c » (văn bản "
-"là « %s »)"
+msgstr "Văn bản đã kết thúc trước khi tìm dấu ngoặc kép tương ứng với « %c » (văn bản là « %s »)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "Văn bản rỗng (hay chưa chỉ khoảng trắng)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Lỗi đọc dữ liệu từ tiến trình con"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298
+#: ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr "Lỗi tạo ống dẫn để liên lạc với tiến trình con (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336
+#: ../glib/gspawn-win32.c:344
+#: ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Lỗi đọc từ ống dẫn con (%s)"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367
+#: ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Lỗi chuyển đổi sang thư mục « %s » (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373
+#: ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Lỗi thực hiện tiến trình con (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Tên chương trình không hợp lệ: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452
+#: ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Gặp chuỗi không hợp lệ nằm trong véc-tơ đối số tại %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463
+#: ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Gặp chuỗi không hợp lệ nằm trong môi trường: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716
+#: ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Thư mục làm việc không hợp lệ: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Lỗi thực hiện chương trình bổ trợ (%s)"
 
-#: glib/gspawn-win32.c:995
-msgid ""
-"Unexpected error in g_io_channel_win32_poll() reading data from a child "
-"process"
-msgstr ""
-"Gặp lỗi bất thường nằm trong « g_io_channel_win32_poll() » khi đọc dữ liệu từ "
-"tiến trình con"
+#: ../glib/gspawn-win32.c:995
+msgid "Unexpected error in g_io_channel_win32_poll() reading data from a child process"
+msgstr "Gặp lỗi bất thường nằm trong « g_io_channel_win32_poll() » khi đọc dữ liệu từ tiến trình con"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Lỗi đọc dữ liệu từ tiến trình con (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
-msgstr ""
-"Gặp lỗi bất thường nằm trong « select() » khi đọc dữ liệu từ tiến trình con (%"
-"s)"
+msgstr "Gặp lỗi bất thường nằm trong « select() » khi đọc dữ liệu từ tiến trình con (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Gặp lỗi bất thường nằm trong « waitpid() » (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "Lỗi tạo tiến trình con (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Lỗi thực hiện tiến trình con « %s » (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "Lỗi chuyển hướng kết nhập hay kết xuất của tiến trình con (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Lỗi tạo tiến trình con (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Gặp lỗi không rõ khi thực hiện tiến trình con « %s »"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Lỗi đọc đủ dữ liệu từ ống dẫn PID con (%s)"
 
-#: glib/gutf8.c:1029
+#: ../glib/gutf8.c:1029
 msgid "Character out of range for UTF-8"
 msgstr "Ký tự ở ngoại phạm vi UTF-8"
 
-#: glib/gutf8.c:1123 glib/gutf8.c:1132 glib/gutf8.c:1264 glib/gutf8.c:1273
-#: glib/gutf8.c:1414 glib/gutf8.c:1510
+#: ../glib/gutf8.c:1123
+#: ../glib/gutf8.c:1132
+#: ../glib/gutf8.c:1264
+#: ../glib/gutf8.c:1273
+#: ../glib/gutf8.c:1414
+#: ../glib/gutf8.c:1510
 msgid "Invalid sequence in conversion input"
 msgstr "Dãy không hợp lệ nằm trong dữ liệu nhập việc chuyển đổi"
 
-#: glib/gutf8.c:1425 glib/gutf8.c:1521
+#: ../glib/gutf8.c:1425
+#: ../glib/gutf8.c:1521
 msgid "Character out of range for UTF-16"
 msgstr "Ký tự ở ngoại phạm vi UTF-16"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Sử dụng:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[TÙY_CHỌN...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Tùy chọn trợ giúp:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Hiển thị các tùy chọn trợ giúp"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Hiển thị mọi tùy chọn trợ giúp"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Tùy chọn ứng dụng:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850
+#: ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Không thể phân tách giá trị số nguyên « %s » cho %s"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860
+#: ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "Giá trị số nguyên « %s » cho %s ở ngoại phạm vi"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Không thể phân tách giá trị đôi « %s » cho %s"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "Giá trị đôi « %s » cho %s ở ngoại phạm vi"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156
+#: ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Gặp lỗi khi phân tách tùy chọn %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266
+#: ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Thiếu đối số cho %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Không biết tùy chọn %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "Không tìm thấy tập tin khoá hợp lệ nằm trong thư mục tìm kiếm"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Không phải là một tập tin chuẩn"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "Tập tin rỗng"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
-msgid ""
-"Key file contains line '%s' which is not a key-value pair, group, or comment"
-msgstr ""
-"Tập tin khóa chứa dòng « %s » mà không phải là một cặp giá trị khóa, nhóm, "
-"hay chú thích"
+msgid "Key file contains line '%s' which is not a key-value pair, group, or comment"
+msgstr "Tập tin khóa chứa dòng « %s » mà không phải là một cặp giá trị khóa, nhóm, hay chú thích"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Tên nhóm không hợp lệ: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "Tập tin khóa không bắt đầu với nhóm"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Tên khoá không hợp lệ: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Tập tin khóa chứa bảng mã không được hỗ trợ « %s »"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112
+#: ../glib/gkeyfile.c:1274
+#: ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569
+#: ../glib/gkeyfile.c:2704
+#: ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990
+#: ../glib/gkeyfile.c:3177
+#: ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Tập tin khóa không có nhóm « %s »"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "Tập tin khóa không có khóa « %s »"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393
+#: ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "Tập tin khóa chứa khóa « %s » với giá trị « %s » mà không phải là UTF-8"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413
+#: ../glib/gkeyfile.c:1528
+#: ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
-msgstr ""
-"Tập tin khóa chứa khóa « %s » mà có giá trị không có khả năng giải dịch."
+msgstr "Tập tin khóa chứa khóa « %s » mà có giá trị không có khả năng giải dịch."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122
+#: ../glib/gkeyfile.c:2334
 #, c-format
-msgid ""
-"Key file contains key '%s' in group '%s' which has value that cannot be "
-"interpreted."
-msgstr ""
-"Tập tin khóa chứa khóa « %s » trong nhóm « %s » mà có giá trị không có khả "
-"năng giải dịch."
+msgid "Key file contains key '%s' in group '%s' which has value that cannot be interpreted."
+msgstr "Tập tin khóa chứa khóa « %s » trong nhóm « %s » mà có giá trị không có khả năng giải dịch."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518
+#: ../glib/gkeyfile.c:2719
+#: ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Tập tin khóa không có khóa « %s » trong nhóm « %s »"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "Tập tin khóa chứa ký tự thoát tại kết thúc của dòng"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Tập tin khóa chứa dãy thoát không hợp lệ « %s »"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "Không thể giải dịch giá trị « %s » dạng con số."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Giá trị số nguyên « %s » ở ngoại phạm vi"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "Không thể giải dịch giá trị « %s » dạng con số nổi."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Không thể giải dịch giá trị « %s » dạng bun (đúng/sai)."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417
+#: ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193
+#: ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566
+#: ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202
+#: ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Giá trị đếm quá lớn được gửi cho %s"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885
+#: ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Luồng đã bị đóng"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:623
-#: gio/gsimpleasyncresult.c:650
+#: ../gio/gcancellable.c:366
+#: ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:623
+#: ../gio/gsimpleasyncresult.c:650
 msgid "Operation was cancelled"
 msgstr "Thao tác bị thôi"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Không rõ kiểu"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "kiểu tập tin %s"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "kiểu %s"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Kết thúc luồng sớm bất thường"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460
+#: ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Không có tên"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "Tập tin Desktop không ghi rõ trường Exec (thực hiện)"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Không tìm thấy thiết bị cuối cần thiết cho ứng dụng"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "Không thể tạo thư mục cấu hình ứng dụng người dùng %s: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Không thể tạo thư mục cấu hình MIME người dùng %s: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Không thể tạo tập tin desktop %s"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "Lời định nghĩa riêng cho %s"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "ổ đĩa không thực hiện chức năng đẩy ra"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "ổ đĩa không thực hiện chức năng thăm dò có phương tiện không"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
-msgstr ""
+msgstr "Không thể quản lý phiên bản %d của bảng mã GEmblem"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
-msgstr ""
+msgstr "Bảng mã GEmblem chứa số các hiệu bài dạng sai (%d)"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
-msgstr ""
+msgstr "Không thể quản lý phiên bản %d của bảng mã GEmblemedIcon"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
-msgstr ""
+msgstr "Bảng mã GEmblemedIcon chứa số các hiệu bài dạng sai (%d)"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
-msgstr ""
-
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+msgstr "Mong đợi một GEmblem cho GEmblemedIcon"
+
+#: ../gio/gfile.c:825
+#: ../gio/gfile.c:1055
+#: ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426
+#: ../gio/gfile.c:1480
+#: ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620
+#: ../gio/gfile.c:2694
+#: ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879
+#: ../gio/gfile.c:2919
+#: ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648
+#: ../gio/gfile.c:3732
+#: ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895
+#: ../gio/gfile.c:4225
+#: ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "Thao tác không được hỗ trợ"
 
@@ -1246,130 +1248,141 @@ msgstr "Thao tác không được hỗ trợ"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311
+#: ../gio/glocalfile.c:1071
+#: ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "Bộ lắp chứa không tồn tại"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963
+#: ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Không thể sao chép đè lên thư mục"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "Không thể sao chép thư mục đè lên thư mục"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031
+#: ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Tập tin đích đã có"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "Không thể sao chép đệ quy thư mục"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Đưa ra giá trị liên kết tượng trưng không hợp lệ"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "Thùng rác không được hỗ trợ"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Tên tập tin không thể chứa « %c »"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993
+#: ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "hàm volume (khối tin) không thực hiện chức năng mount (lắp)"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Không có ứng dụng đăng ký xử lý tập tin này"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Bộ đếm bị đóng"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213
+#: ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372
+#: ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "Bộ đếm tập tin có thao tác còn chạy"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362
+#: ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Bộ đếm tập tin đã bị đóng"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "tập tin"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Tập tin chứa biểu tượng"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
-msgstr ""
+msgstr "Không thể quản lý phiên bản %d của bảng mã GFileIcon"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
-msgstr ""
+msgstr "Dữ liệu nhập dạng sai cho GFileIcon"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157
+#: ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171
+#: ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Luồng không hỗ trợ hàm « query_info »"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339
+#: ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Chức năng seek (tìm nơi) không được hỗ trợ trên luồng"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "Không cho phép cắt ngắn luồng nhập vào"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Không cho phép cắt ngắn luồng"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
-msgstr ""
+msgstr "Số các hiệu bài không đúng (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
-msgstr ""
+msgstr "Không có kiểu cho tên hạng %s"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
-msgstr ""
+msgstr "Kiểu %s không thực hiện giao diện GIcon"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
-msgstr ""
+msgstr "Kiểu %s không được đặt hạng"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
-msgstr ""
+msgstr "Số thứ tự phiên bản dạng sai: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
+msgstr "Kiểu %s không thực hiện « from_tokens() » trên giao diện GIcon"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
-msgstr ""
+msgstr "Không thể quản lý phiên bản đã cung cấp của bảng mã biểu tượng"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "Luồng nhập vào không thực hiện chức năng đọc"
 
@@ -1379,474 +1392,480 @@ msgstr "Luồng nhập vào không thực hiện chức năng đọc"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911
+#: ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Luồng có thao tác còn chạy"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Không tìm thấy kiểu theo dõi thư mục cục bộ mặc định"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608
+#: ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Tên tập tin không hợp lệ: %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Gặp lỗi khi lấy tập tin về hệ thống tập tin: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Không thể thay đổi tên của thư mục gốc"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135
+#: ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Gặp lỗi khi thay đổi tên của tập tin: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "Không thể thay đổi tên của tập tin, vì tên tập tin đã có"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157
+#: ../gio/glocalfile.c:2021
+#: ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204
+#: ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550
+#: ../gio/glocalfileoutputstream.c:967
 msgid "Invalid filename"
 msgstr "Tên tập tin không hợp lệ"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Gặp lỗi khi mở tập tin: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "Không thể mở thư mục"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Gặp lỗi khi gỡ bỏ tập tin: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Gặp lỗi khi chuyển tập tin vào sọt rác: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Không thể tạo thư mục sọt rác %s: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Không tìm thấy thư mục cấp đầu cho sọt rác"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837
+#: ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Không tìm thấy hay không thể tạo thư mục sọt rác"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Không thể tạo tập tin thông tin sọt rác: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916
+#: ../gio/glocalfile.c:1991
+#: ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Không thể chuyển tập tin vào sọt rác: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Lỗi tạo thư mục: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Gặp lỗi khi tạo liên kết tượng trưng: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114
+#: ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Gặp lỗi khi di chuyển tập tin: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "Không thể di chuyển thư mục đè lên thư mục"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164
+#: ../gio/glocalfileoutputstream.c:819
+#: ../gio/glocalfileoutputstream.c:833
+#: ../gio/glocalfileoutputstream.c:848
+#: ../gio/glocalfileoutputstream.c:864
+#: ../gio/glocalfileoutputstream.c:878
 msgid "Backup file creation failed"
 msgstr "Lỗi tạo tập tin sao lưu"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Gặp lỗi khi gỡ bỏ tập tin đích: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "Không hỗ trợ chức năng di chuyển giữa các bộ lắp"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Giá trị thuộc tính phải có giá trị"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Kiểu thuộc tính không hợp lệ (mong đợi chuỗi)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Tên thuộc tính đã mở rộng không hợp lệ"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Gặp lỗi khi đặt thuộc tính đã mở rộng « %s »: %s"
 
-#: gio/glocalfileinfo.c:1464 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1464
+#: ../gio/glocalfileoutputstream.c:706
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Gặp lỗi khi lấy trạng thái về tập tin « %s »: %s"
 
-#: gio/glocalfileinfo.c:1534
+#: ../gio/glocalfileinfo.c:1534
 msgid " (invalid encoding)"
 msgstr " (bảng mã không hợp lệ)"
 
-#: gio/glocalfileinfo.c:1702
+#: ../gio/glocalfileinfo.c:1702
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "Gặp lỗi khi lấy trạng thái về mô tả tập tin: %s"
 
-#: gio/glocalfileinfo.c:1747
+#: ../gio/glocalfileinfo.c:1747
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Kiểu thuộc tính không hợp lệ (mong đợi uint32)"
 
-#: gio/glocalfileinfo.c:1765
+#: ../gio/glocalfileinfo.c:1765
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Kiểu thuộc tính không hợp lệ (mong đợi uint64)"
 
-#: gio/glocalfileinfo.c:1784 gio/glocalfileinfo.c:1803
+#: ../gio/glocalfileinfo.c:1784
+#: ../gio/glocalfileinfo.c:1803
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Kiểu thuộc tính không hợp lệ (mong đợi chuỗi byte)"
 
-#: gio/glocalfileinfo.c:1829
+#: ../gio/glocalfileinfo.c:1829
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Gặp lỗi khi đặt quyền hạn: %s"
 
-#: gio/glocalfileinfo.c:1880 gio/glocalfileinfo.c:2048
+#: ../gio/glocalfileinfo.c:1880
+#: ../gio/glocalfileinfo.c:2048
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Gặp lỗi khi đặt người sở hữu : %s"
 
-#: gio/glocalfileinfo.c:1903
+#: ../gio/glocalfileinfo.c:1903
 msgid "symlink must be non-NULL"
 msgstr "liên kết tượng trưng phải có giá trị"
 
-#: gio/glocalfileinfo.c:1913 gio/glocalfileinfo.c:1932
-#: gio/glocalfileinfo.c:1943
+#: ../gio/glocalfileinfo.c:1913
+#: ../gio/glocalfileinfo.c:1932
+#: ../gio/glocalfileinfo.c:1943
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Gặp lỗi khi đặt liên kết tượng trưng: %s"
 
-#: gio/glocalfileinfo.c:1922
+#: ../gio/glocalfileinfo.c:1922
 msgid "Error setting symlink: file is not a symlink"
-msgstr ""
-"Gặp lỗi khi đặt liên kết tượng trưng: tập tin không phải là liên kết tượng "
-"trưng"
+msgstr "Gặp lỗi khi đặt liên kết tượng trưng: tập tin không phải là liên kết tượng trưng"
 
-#: gio/glocalfileinfo.c:2071
+#: ../gio/glocalfileinfo.c:2071
 msgid "SELinux context must be non-NULL"
 msgstr "Ngữ cảnh SELinux phải khác NULL"
 
-#: gio/glocalfileinfo.c:2086
+#: ../gio/glocalfileinfo.c:2086
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Lỗi đặt ngữ cảnh SELinux: %s"
 
-#: gio/glocalfileinfo.c:2093
+#: ../gio/glocalfileinfo.c:2093
 msgid "SELinux is not enabled on this system"
 msgstr "SELinux chưa được bật trên hệ thống này"
 
-#: gio/glocalfileinfo.c:2154
+#: ../gio/glocalfileinfo.c:2154
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "Không hỗ trợ chức năng đặt thuộc tính %s"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160
+#: ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Gặp lỗi khi đọc từ tập tin: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191
+#: ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312
+#: ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:896
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Gặp lỗi khi tìm nơi trong tập tin: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233
+#: ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Gặp lỗi khi đóng tập tin: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Không tìm thấy kiểu theo dõi tập tin cục bộ mặc định"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172
+#: ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Gặp lỗi khi ghi vào tập tin: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Gặp lỗi khi gỡ bỏ liên kết sao lưu cũ : %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249
+#: ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Gặp lỗi khi tạo bản sao lưu : %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Gặp lỗi khi thay đổi tên của tập tin tạm thời: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451
+#: ../gio/glocalfileoutputstream.c:913
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Gặp lỗi khi cắt ngắn tập tin: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511
+#: ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:688
+#: ../gio/glocalfileoutputstream.c:973
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Gặp lỗi khi mở tập tin « %s »: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:719
 msgid "Target file is a directory"
 msgstr "Tập tin đích là một thư mục"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:724
 msgid "Target file is not a regular file"
 msgstr "Tập tin đích không phải là một tập tin bình thường"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:736
 msgid "The file was externally modified"
 msgstr "Tập tin đã bị sửa đổi bên ngoài"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/gmemoryinputstream.c:487
+#: ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "GSeekType được cung cấp không hợp lệ"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497
+#: ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Yêu cầu tìm không hợp lệ"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "Không thể cắt GMemoryInputStream"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "Đã đạt ngưỡng mảng dữ liệu tối đa"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "Luồng ra bộ nhớ không thể thay đổi kích thước"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Lỗi thay đổi kích thước luồng ra bộ nhớ"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "hàm mount (lắp) không thực hiện hàm unmount (bỏ lắp)"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "hàm mount (lắp) không thực hiện hàm eject (đầy ra)"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "hàm mount (lắp) không thực hiện hàm remount (lắp lại)"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "hàm mount (lắp) không thực hiện đoán nội dung"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "hàm mount (lắp) không thực hiện đoán nội dung đồng bộ"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211
+#: ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "Luồng xuất không thực hiện hàm write (ghi)"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372
+#: ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "Luồng nguồn đã bị đóng"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "tên"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Tên của biểu tượng"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "tên"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Mảng chứa tên biểu tượng"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "dùng dự phòng mặc định"
 
-#: gio/gthemedicon.c:250
-msgid ""
-"Whether to use default fallbacks found by shortening the name at '-' "
-"characters. Ignores names after the first if multiple names are given."
-msgstr ""
-"Có dùng dự phòng mặc định được tìm thấy bằng cách rút ngắn tên tại ký tự '-' "
-"hay không. Chỉ xét tên đầu tiên nếu trùng tên."
+#: ../gio/gthemedicon.c:250
+msgid "Whether to use default fallbacks found by shortening the name at '-' characters. Ignores names after the first if multiple names are given."
+msgstr "Có dùng dự phòng mặc định được tìm thấy bằng cách rút ngắn tên tại ký tự '-' hay không. Chỉ xét tên đầu tiên nếu trùng tên."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
-msgstr ""
+msgstr "Không thể quản lý phiên bản %d của bảng mã GThemedIcon"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161
+#: ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
-msgstr ""
+msgstr "Bộ mô tả tập tin"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
-msgstr ""
+msgstr "Bộ mô tả tập tin từ đó cần đọc"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
-#, fuzzy
+#: ../gio/gunixinputstream.c:176
+#: ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
-msgstr "Gặp lỗi khi lấy trạng thái về mô tả tập tin: %s"
+msgstr "Đóng bộ mô tả tập tin"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177
+#: ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
-msgstr ""
+msgstr "Có nên đóng bộ mô tả tập tin khi luồng được đóng, hay không"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358
+#: ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456
+#: ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Gặp lỗi khi đọc từ UNIX: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411
+#: ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398
+#: ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Gặp lỗi khi đóng UNIX: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781
+#: ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Gốc hệ thống tập tin"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
-msgstr ""
+msgstr "Bộ mô tả tập tin vào đó cần ghi"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344
+#: ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Gặp lỗi khi ghi vào UNIX: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "hàm volume (khối tin) không thực hiện hàm eject (đầy ra)"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Không tìm thấy ứng dụng"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Gặp lỗi khi khởi chạy ứng dụng: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "Không hỗ trợ địa chỉ URI"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "các thay đổi liên quan không được hỗ trợ trên win32"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "chức năng tạo sự liên quan không được hỗ trợ trên win32"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "đừng ẩn mục nhập"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "dùng định dạng liệt kê dài"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[TẬP_TIN...]"
 
-#~ msgid "%u byte"
-#~ msgid_plural "%u bytes"
-#~ msgstr[0] "%u byte"
-
-#~ msgid "Can't load just created desktop file"
-#~ msgstr "Không thể nạp tập tin desktop mới tạo"
-
-#~ msgid "Error creating backup link: %s"
-#~ msgstr "Gặp lỗi khi tạo liên kết sao lưu : %s"
-
-#~ msgid "Too large count value passed to g_input_stream_read_async"
-#~ msgstr "Giá trị đếm quá lớn được gửi cho hàm « g_input_stream_read_async »"
-
-#~ msgid "Too large count value passed to g_input_stream_skip"
-#~ msgstr "Giá trị đếm quá lớn được gửi cho hàm « g_input_stream_skip »"
-
-#~ msgid "Too large count value passed to g_input_stream_skip_async"
-#~ msgstr "Giá trị đếm quá lớn được gửi cho hàm « g_input_stream_skip_async »"
-
-#~ msgid "Target file already exists"
-#~ msgstr "Tập tin đích đã có"
-
-#~ msgid "Too large count value passed to g_output_stream_write"
-#~ msgstr "Giá trị đếm quá lớn được gửi cho hàm « g_output_stream_write »"
-
-#~ msgid "Too large count value passed to g_output_stream_write_async"
-#~ msgstr "Giá trị đếm quá lớn được gửi cho hàm « g_output_stream_write_async »"
diff --git a/tests/Makefile.am b/tests/Makefile.am
index bba5f02..57f1555 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -212,11 +212,7 @@ uri_test_LDADD = $(progs_ldadd)
 regex_test_LDADD = $(progs_ldadd)
 markup_collect_LDADD = $(progs_ldadd)
 
-lib_LTLIBRARIES = libmoduletestplugin_a.la libmoduletestplugin_b.la
-
-# Prevent those libs from being installed
-install-libLTLIBRARIES:
-	:
+noinst_LTLIBRARIES = libmoduletestplugin_a.la libmoduletestplugin_b.la
 
 libmoduletestplugin_a_la_SOURCES = libmoduletestplugin_a.c
 libmoduletestplugin_a_la_LDFLAGS = $(G_MODULE_LDFLAGS) -avoid-version -module $(no_undefined) -rpath $(libdir)
