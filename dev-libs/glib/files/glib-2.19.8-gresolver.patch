diff --git a/ChangeLog b/ChangeLog
index b89e52c..705f77a 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,9 @@
 2009-02-17  Matthias Clasen  <mclasen@redhat.com>
 
+	* configure.in: Bump version
+
+2009-02-17  Matthias Clasen  <mclasen@redhat.com>
+
 	* === Released 2.19.8 ===
 
 2009-02-17  Matthias Clasen  <mclasen@redhat.com>
diff --git a/configure.in b/configure.in
index 45af6b1..942f1f3 100644
--- a/configure.in
+++ b/configure.in
@@ -23,7 +23,7 @@ m4_define(glib_configure_in)
 #
 m4_define([glib_major_version], [2])
 m4_define([glib_minor_version], [19])
-m4_define([glib_micro_version], [8])
+m4_define([glib_micro_version], [9])
 m4_define([glib_interface_age], [0])
 m4_define([glib_binary_age],
           [m4_eval(100 * glib_minor_version + glib_micro_version)])
@@ -953,6 +953,50 @@ AC_CHECK_FUNCS(_NSGetEnviron)
 AC_FUNC_VSNPRINTF_C99
 AC_FUNC_PRINTF_UNIX98
 
+# Internet address families
+if test $glib_native_win32 = yes; then
+  glib_inet_includes=["
+#include <winsock2.h>
+  "]
+else
+  glib_inet_includes=["
+#include <sys/socket.h>
+  "]
+fi
+
+glib_failed=false
+GLIB_CHECK_VALUE(AF_INET, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(AF_INET6, $glib_inet_includes, glib_failed=true)
+# winsock defines this even though it doesn't support it
+GLIB_CHECK_VALUE(AF_UNIX, $glib_inet_includes, glib_failed=true)
+if $glib_failed ; then
+  AC_MSG_ERROR([Could not determine values for AF_INET* constants])
+fi
+
+# For gio/libasyncns
+if test $glib_native_win32 = no; then
+  AC_CHECK_FUNCS(strndup setresuid setreuid)
+  AC_CHECK_HEADERS(sys/prctl.h arpa/nameser_compat.h)
+  AC_CHECK_FUNC(res_query, ,
+    [AC_CHECK_LIB(resolv, res_query, [ LIBASYNCNS_LIBADD="-lresolv" ],
+      [ save_libs="$LIBS"
+        LIBS="-lresolv $LIBS"
+        AC_MSG_CHECKING([for res_query in -lresolv (alternate version)])
+        AC_LINK_IFELSE(
+          [AC_LANG_PROGRAM([[#include <resolv.h>]], [[res_query(0,0,0,0,0)]])],
+          [ AC_MSG_RESULT(yes)
+  	  LIBASYNCNS_LIBADD="-lresolv" ],
+          [ AC_MSG_RESULT(no)
+            AC_CHECK_LIB(bind, res_query,
+              [ LIBASYNCNS_LIBADD="-lbind" ],
+  	    [ AC_MSG_ERROR(res_query not found) ] ) ] )
+        LIBS="$save_libs"
+      ] )
+    ]
+  )
+  AC_SUBST(LIBASYNCNS_LIBADD)
+fi
+
 dnl
 dnl if statfs() takes 2 arguments (Posix) or 4 (Solaris)
 dnl
@@ -2985,6 +3029,10 @@ _______EOF
  */
 typedef $g_pid_type GPid;
 
+#define GLIB_SYSDEF_AF_UNIX $g_af_unix
+#define GLIB_SYSDEF_AF_INET $g_af_inet
+#define GLIB_SYSDEF_AF_INET6 $g_af_inet6
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
@@ -3271,6 +3319,10 @@ g_pollhup=$glib_cv_value_POLLHUP
 g_pollerr=$glib_cv_value_POLLERR
 g_pollnval=$glib_cv_value_POLLNVAL
 
+g_af_unix=$glib_cv_value_AF_UNIX
+g_af_inet=$glib_cv_value_AF_INET
+g_af_inet6=$glib_cv_value_AF_INET6
+
 g_stack_grows=$glib_cv_stack_grows
 
 g_have_eilseq=$have_eilseq
@@ -3355,6 +3407,7 @@ gthread/Makefile
 gio/Makefile
 gio/xdgmime/Makefile
 gio/inotify/Makefile
+gio/libasyncns/Makefile
 gio/fen/Makefile
 gio/fam/Makefile
 gio/win32/Makefile
diff --git a/docs/reference/gio/Makefile.am b/docs/reference/gio/Makefile.am
index 43e003f..1cd0cdc 100644
--- a/docs/reference/gio/Makefile.am
+++ b/docs/reference/gio/Makefile.am
@@ -43,11 +43,14 @@ IGNORE_HFILES=				\
 	glocalvfs.h			\
 	gnativevolumemonitor.h		\
 	gpollfilemonitor.h		\
+	gthreadedresolver.h		\
 	gunionvolumemonitor.h		\
 	gunixdrive.h			\
+	gunixresolver.h			\
 	gunixvolume.h			\
 	gvolumeprivate.h		\
 	gwin32appinfo.h			\
+	gwin32resolver.h		\
 	inotify-diag.h			\
 	inotify-helper.h		\
 	inotify-kernel.h		\
@@ -85,7 +88,8 @@ GTKDOC_LIBS = \
 	$(NULL)
 
 # Extra options to supply to gtkdoc-mkdb
-MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g
+MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g \
+	--ignore-files=libasyncns
 
 # Images to copy into HTML directory
 HTML_IMAGES =			\
diff --git a/docs/reference/gio/gio-docs.xml b/docs/reference/gio/gio-docs.xml
index 46af7fe..0b0208a 100644
--- a/docs/reference/gio/gio-docs.xml
+++ b/docs/reference/gio/gio-docs.xml
@@ -90,6 +90,18 @@
     	<xi:include href="xml/gemblemedicon.xml"/>
     	<xi:include href="xml/gemblem.xml"/>
     </chapter>
+    <chapter id="networking">
+    	<title>Networking</title>
+        <xi:include href="xml/gresolver.xml"/>
+        <xi:include href="xml/ginetaddress.xml"/>
+        <xi:include href="xml/gsocketaddress.xml"/>
+        <xi:include href="xml/ginetsocketaddress.xml"/>
+        <xi:include href="xml/gunixsocketaddress.xml"/>
+        <xi:include href="xml/gsrvtarget.xml"/>
+        <xi:include href="xml/gsocketconnectable.xml"/>
+        <xi:include href="xml/gnetworkaddress.xml"/>
+        <xi:include href="xml/gnetworkservice.xml"/>
+    </chapter>
     <chapter id="utils">   
     	<title>Utilities</title>
         <xi:include href="xml/gfilenamecompleter.xml"/>
diff --git a/docs/reference/gio/gio-sections.txt b/docs/reference/gio/gio-sections.txt
index 391dfaf..8f81a27 100644
--- a/docs/reference/gio/gio-sections.txt
+++ b/docs/reference/gio/gio-sections.txt
@@ -1310,4 +1310,208 @@ g_io_extension_point_set_required_type
 g_io_extension_ref_class
 </SECTION>
 
+<SECTION>
+<FILE>ginetaddress</FILE>
+<TITLE>GInetAddress</TITLE>
+GInetAddress
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_to_bytes
+g_inet_address_to_string
+g_inet_address_get_family
+g_inet_address_get_is_any
+g_inet_address_get_is_link_local
+g_inet_address_get_is_loopback
+g_inet_address_get_is_mc_global
+g_inet_address_get_is_mc_link_local
+g_inet_address_get_is_mc_node_local
+g_inet_address_get_is_mc_org_local
+g_inet_address_get_is_mc_site_local
+g_inet_address_get_is_multicast
+g_inet_address_get_is_site_local
+<SUBSECTION Standard>
+GInetAddressClass
+GInetAddressPrivate
+G_INET_ADDRESS
+G_INET_ADDRESS_CLASS
+G_INET_ADDRESS_GET_CLASS
+G_IS_INET_ADDRESS
+G_IS_INET_ADDRESS_CLASS
+G_TYPE_INET_ADDRESS
+<SUBSECTION Private>
+g_inet_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketaddress</FILE>
+<TITLE>GSocketAddress</TITLE>
+GSocketAddress
+GSocketFamily
+g_socket_address_new_from_native
+g_socket_address_get_family
+g_socket_address_to_native
+g_socket_address_get_native_size
+<SUBSECTION Standard>
+GSocketAddressClass
+G_IS_SOCKET_ADDRESS
+G_IS_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS
+G_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS_GET_CLASS
+G_TYPE_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>ginetsocketaddress</FILE>
+<TITLE>GInetSocketAddress</TITLE>
+GInetSocketAddress
+g_inet_socket_address_new
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+<SUBSECTION Standard>
+GInetSocketAddressClass
+GInetSocketAddressPrivate
+G_INET_SOCKET_ADDRESS
+G_INET_SOCKET_ADDRESS_CLASS
+G_INET_SOCKET_ADDRESS_GET_CLASS
+G_IS_INET_SOCKET_ADDRESS
+G_IS_INET_SOCKET_ADDRESS_CLASS
+G_TYPE_INET_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_inet_socket_address_get_type
+</SECTION>
 
+<SECTION>
+<FILE>gunixsocketaddress</FILE>
+<TITLE>GUnixSocketAddress</TITLE>
+GUnixSocketAddress
+g_unix_socket_address_new
+<SUBSECTION Standard>
+GUnixSocketAddressClass
+GUnixSocketAddressPrivate
+G_IS_UNIX_SOCKET_ADDRESS
+G_IS_UNIX_SOCKET_ADDRESS_CLASS
+G_TYPE_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS_CLASS
+G_UNIX_SOCKET_ADDRESS_GET_CLASS
+<SUBSECTION Private>
+g_unix_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gresolver</FILE>
+<TITLE>GResolver</TITLE>
+GResolver
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_free_addresses
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+g_resolver_free_targets
+<SUBSECTION>
+G_RESOLVER_ERROR
+GResolverError
+<SUBSECTION Standard>
+GResolverClass
+G_IS_RESOLVER
+G_IS_RESOLVER_CLASS
+G_RESOLVER
+G_RESOLVER_CLASS
+G_RESOLVER_GET_CLASS
+G_TYPE_RESOLVER
+<SUBSECTION Private>
+g_resolver_get_type
+g_resolver_error_quark
+</SECTION>
+
+<SECTION>
+<FILE>gsrvtarget</FILE>
+<TITLE>GSrvTarget</TITLE>
+GSrvTarget
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_array_sort
+<SUBSECTION Standard>
+G_TYPE_SRV_TARGET
+<SUBSECTION Private>
+g_srv_target_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketconnectable</FILE>
+<TITLE>GSocketConnectable</TITLE>
+GSocketConnectable
+GSocketConnectableIface
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_reset
+<SUBSECTION Standard>
+G_IS_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE_GET_IFACE
+G_TYPE_SOCKET_CONNECTABLE
+<SUBSECTION Private>
+g_socket_connectable_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkaddress</FILE>
+<TITLE>GNetworkAddress</TITLE>
+GNetworkAddress
+g_network_address_new
+g_network_address_get_hostname
+g_network_address_get_ascii_name
+g_network_address_get_port
+<SUBSECTION Standard>
+GNetworkAddressClass
+GNetworkAddressPrivate
+G_IS_NETWORK_ADDRESS
+G_IS_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS
+G_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS_GET_CLASS
+G_TYPE_NETWORK_ADDRESS
+<SUBSECTION Private>
+g_network_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkservice</FILE>
+<TITLE>GNetworkService</TITLE>
+GNetworkService
+g_network_service_new
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_get_expires
+<SUBSECTION Standard>
+GNetworkServiceClass
+GNetworkServicePrivate
+G_IS_NETWORK_SERVICE
+G_IS_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE
+G_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE_GET_CLASS
+G_TYPE_NETWORK_SERVICE
+<SUBSECTION Private>
+g_network_service_get_type
+</SECTION>
diff --git a/docs/reference/gio/gio.types b/docs/reference/gio/gio.types
index c73282a..8fb70f5 100644
--- a/docs/reference/gio/gio.types
+++ b/docs/reference/gio/gio.types
@@ -36,6 +36,8 @@ g_file_type_get_type
 g_filter_input_stream_get_type
 g_filter_output_stream_get_type
 g_icon_get_type
+g_inet_address_get_type
+g_inet_socket_address_get_type
 g_input_stream_get_type
 g_io_error_enum_get_type
 g_io_module_get_type
@@ -50,15 +52,21 @@ g_mount_operation_get_type
 g_mount_operation_result_get_type
 g_mount_unmount_flags_get_type
 g_native_volume_monitor_get_type
+g_network_address_get_type
+g_network_service_get_type
 g_output_stream_get_type
 g_output_stream_splice_flags_get_type
 g_password_save_get_type
+g_resolver_get_type
 g_seekable_get_type
 g_simple_async_result_get_type
+g_socket_address_get_type
+g_socket_connectable_get_type
 g_themed_icon_get_type
 g_unix_input_stream_get_type
 g_unix_mount_monitor_get_type
 g_unix_output_stream_get_type
+g_unix_socket_address_get_type
 g_vfs_get_type
 g_volume_get_type
 g_volume_monitor_get_type
diff --git a/docs/reference/glib/glib-docs.sgml b/docs/reference/glib/glib-docs.sgml
index cef6e8c..4d7c36d 100644
--- a/docs/reference/glib/glib-docs.sgml
+++ b/docs/reference/glib/glib-docs.sgml
@@ -66,6 +66,7 @@
 <!ENTITY glib-Version SYSTEM "xml/version.xml">
 <!ENTITY glib-Uri SYSTEM "xml/gurifuncs.xml">
 <!ENTITY glib-Testing SYSTEM "xml/testing.xml">
+<!ENTITY glib-Hostutils SYSTEM "xml/ghostutils.xml">
 
 <!ENTITY glib-Compiling SYSTEM "compiling.sgml">
 <!ENTITY glib-Building SYSTEM "building.sgml">
@@ -162,6 +163,7 @@ synchronize their operation.
     &glib-Spawn;
     &glib-Fileutils;
     &glib-Uri;
+    &glib-Hostutils;
     &glib-Shell;
     &glib-Option;
     &glib-Pattern-Matching;
diff --git a/docs/reference/glib/glib-sections.txt b/docs/reference/glib/glib-sections.txt
index 6df70cb..4feea78 100644
--- a/docs/reference/glib/glib-sections.txt
+++ b/docs/reference/glib/glib-sections.txt
@@ -2653,3 +2653,16 @@ g_test_log_buffer_push
 g_test_log_buffer_pop
 g_test_log_msg_free
 </SECTION>
+
+
+<SECTION>
+<FILE>ghostutils</FILE>
+<TITLE>Hostname Utilities</TITLE>
+g_hostname_to_ascii
+g_hostname_to_unicode
+<SUBSECTION>
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+<SUBSECTION>
+g_hostname_is_ip_address
+</SECTION>
diff --git a/docs/reference/glib/tmpl/ghostutils.sgml b/docs/reference/glib/tmpl/ghostutils.sgml
new file mode 100644
index 0000000..b619912
--- /dev/null
+++ b/docs/reference/glib/tmpl/ghostutils.sgml
@@ -0,0 +1,66 @@
+<!-- ##### SECTION Title ##### -->
+Hostname Utilities
+
+<!-- ##### SECTION Short_Description ##### -->
+
+
+<!-- ##### SECTION Long_Description ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION See_Also ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION Stability_Level ##### -->
+
+
+<!-- ##### FUNCTION g_hostname_to_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_to_unicode ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_non_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ascii_encoded ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ip_address ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
diff --git a/gio/ChangeLog b/gio/ChangeLog
index 554cce0..cca732e 100644
--- a/gio/ChangeLog
+++ b/gio/ChangeLog
@@ -1,3 +1,33 @@
+2009-02-19  Alexander Larsson  <alexl@redhat.com>
+
+	Bug 549298 – impossible to copy files with p (pipe) flag
+
+	* gfile.c:
+	(file_copy_fallback):
+	Error out if the source file is a special file
+
+2009-02-18  Alexander Larsson  <alexl@redhat.com>
+
+	Bug 560564 – Replacing a symlink with its linked file truncates the original file
+
+	* gioenums.h:
+	Add G_FILE_CREATE_REPLACE_DESTINATION
+
+	* glocalfileoutputstream.c:
+	(handle_overwrite_open):
+	(_g_local_file_output_stream_replace):
+	Handle G_FILE_CREATE_REPLACE_DESTINATION when overwriting files.
+
+	* gfile.c:
+	(file_copy_fallback):
+	Pass G_FILE_CREATE_REPLACE_DESTINATION to g_file_replace when copying
+	with overwrite.
+
+2009-02-17  Ryan Lortie  <desrt@desrt.ca>
+
+	* gfileinfo.c: unref the destination's attribute matcher before
+	overwriting it.
+
 2009-02-17  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.8 ===
@@ -219,7 +249,7 @@
 	Bug 562452 - Ensure we return G_IO_ERROR_CANCELLED if cancelling
 	g_simple_async_result_run_in_thread
 	
-        * gsimpleasyncresult.c:
+	* gsimpleasyncresult.c:
 	Make g_simple_async_result_run_in_thread check cancellation before
 	calling out to the user in the callback. This means we guarantee
 	reporting cancels of async operations from the main threads, which
@@ -234,11 +264,11 @@
 
 	Bug 515777 - incorrect date&time on copy
 	
-        * glocalfile.c:
-        (g_local_file_class_init):
+	* glocalfile.c:
+	(g_local_file_class_init):
 	Copy mtime by default
 	
-        * gfile.c:
+	* gfile.c:
 	Change docs about G_FILE_COPY_ALL_METADATA to not mention
 	mtime as an example.
 
@@ -291,10 +321,10 @@
 
 2008-12-01  Alexander Larsson  <alexl@redhat.com>
 
-        * gio.symbols:
-        * gmount.[ch]:
-        * gunionvolumemonitor.c:
-        * gvolume.c:
+	* gio.symbols:
+	* gmount.[ch]:
+	* gunionvolumemonitor.c:
+	* gvolume.c:
 	Add and document g_mount_is_shadowed plus calls
 	to set/unset a mount as shadowed
 	
@@ -448,8 +478,8 @@
 
 	Bug 528320 - Incorrect icons displayed for files with custom mimetype icons
 	
-        * glocalfileinfo.c:
-        (_g_local_file_info_get):
+	* glocalfileinfo.c:
+	(_g_local_file_info_get):
 	Don't return the fallback icon (text-x-generic) for all files.
 	This is causing problems with theme icon lookup and custom mime
 	icons, as the generic fallback overrides custom mime icons in
@@ -463,7 +493,7 @@
 
 2008-10-21  Alexander Larsson  <alexl@redhat.com>
 
-        * gfileinfo.h:
+	* gfileinfo.h:
 	Add G_FILE_ATTRIBUTE_PREVIEW_ICON (#557182)
 
 2008-10-21  Alexander Larsson  <alexl@redhat.com>
@@ -471,18 +501,18 @@
 	Bug 555740 - gicon serialization
 	Based on patch from David Zeuthen
 	
-        * gicon.[ch]:
-        * gio.symbols:
+	* gicon.[ch]:
+	* gio.symbols:
 	Add g_icon_to_string() and g_icon_new_for_string().
 	
-        * gemblem.c:
-        * gemblemedicon.c:
-        * gfileicon.c:
-        * gthemedicon.c:
+	* gemblem.c:
+	* gemblemedicon.c:
+	* gfileicon.c:
+	* gthemedicon.c:
 	Implement icon serialization for built-in icon types
 	
-        * tests/Makefile.am:
-        * tests/g-icon.c:
+	* tests/Makefile.am:
+	* tests/g-icon.c:
 	Added GIcon serialization test
 
 2008-10-16  Matthias Clasen <mclasen@redhat.com>
@@ -513,7 +543,7 @@
 
 2008-10-13  Alexander Larsson  <alexl@redhat.com>
 
-        * gdesktopappinfo.c:
+	* gdesktopappinfo.c:
 	When adding an application as handling a mime type (but
 	not as the default), copy the full list of desktop ids handling
 	that type in before adding the new one on the end of the list.
diff --git a/gio/Makefile.am b/gio/Makefile.am
index be6568f..7e7c2d5 100644
--- a/gio/Makefile.am
+++ b/gio/Makefile.am
@@ -5,7 +5,7 @@ NULL =
 SUBDIRS=
 
 if OS_UNIX
-SUBDIRS += xdgmime
+SUBDIRS += libasyncns xdgmime
 endif
 
 if OS_WIN32_AND_DLL_COMPILATION
@@ -125,13 +125,16 @@ endif
 
 if OS_UNIX
 appinfo_sources += gdesktopappinfo.c gdesktopappinfo.h
-platform_libadd += xdgmime/libxdgmime.la
-platform_deps += xdgmime/libxdgmime.la
+platform_libadd += libasyncns/libasyncns.la xdgmime/libxdgmime.la
+platform_deps += libasyncns/libasyncns.la xdgmime/libxdgmime.la
 unix_sources = \
 	gunixmount.c		\
 	gunixmount.h		\
 	gunixmounts.c 		\
 	gunixmounts.h 		\
+	gunixresolver.c		\
+	gunixresolver.h		\
+	gunixsocketaddress.c	\
 	gunixvolume.c 		\
 	gunixvolume.h 		\
 	gunixvolumemonitor.c 	\
@@ -147,15 +150,18 @@ giounixinclude_HEADERS = \
 	gunixmounts.h 		\
 	gunixinputstream.h 	\
 	gunixoutputstream.h 	\
+	gunixsocketaddress.h	\
 	$(NULL)
 endif
 
 if OS_WIN32
 appinfo_sources += gwin32appinfo.c gwin32appinfo.h
-platform_libadd += -lshlwapi
+platform_libadd += -lshlwapi -lws2_32 -ldnsapi
 win32_sources = \
 	gwin32mount.c \
 	gwin32mount.h \
+	gwin32resolver.c \
+	gwin32resolver.h \
 	gwin32volumemonitor.c \
 	gwin32volumemonitor.h \
 	$(NULL)
@@ -196,6 +202,8 @@ libgio_2_0_la_SOURCES =		\
 	gfilterinputstream.c 	\
 	gfilteroutputstream.c 	\
 	gicon.c 		\
+	ginetaddress.c		\
+	ginetsocketaddress.c	\
 	ginputstream.c 		\
 	gioenums.h		\
 	gioerror.c 		\
@@ -209,12 +217,21 @@ libgio_2_0_la_SOURCES =		\
 	gmountoperation.c 	\
 	gnativevolumemonitor.c 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.c	\
+	gnetworkingprivate.h	\
+	gnetworkservice.c	\
 	goutputstream.c 	\
 	gpollfilemonitor.c 	\
 	gpollfilemonitor.h 	\
+	gresolver.c		\
 	gseekable.c 		\
 	gsimpleasyncresult.c 	\
+	gsocketaddress.c	\
+	gsocketconnectable.c	\
+	gsrvtarget.c		\
 	gthemedicon.c 		\
+	gthreadedresolver.c	\
+	gthreadedresolver.h	\
 	gunionvolumemonitor.c 	\
 	gunionvolumemonitor.h 	\
 	gvfs.c 			\
@@ -299,6 +316,8 @@ gio_headers =			\
 	gfilterinputstream.h 	\
 	gfilteroutputstream.h 	\
 	gicon.h 		\
+	ginetaddress.h		\
+	ginetsocketaddress.h	\
 	ginputstream.h 		\
 	gio.h			\
 	giotypes.h		\
@@ -312,9 +331,15 @@ gio_headers =			\
 	gmemoryoutputstream.h 	\
 	gmountoperation.h 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.h	\
+	gnetworkservice.h	\
 	goutputstream.h 	\
+	gresolver.h		\
 	gseekable.h 		\
 	gsimpleasyncresult.h 	\
+	gsocketaddress.h	\
+	gsocketconnectable.h	\
+	gsrvtarget.h		\
 	gthemedicon.h 		\
 	gvfs.h 			\
 	gvolume.h 		\
diff --git a/gio/gfile.c b/gio/gfile.c
index 6ae4209..75c75ed 100644
--- a/gio/gfile.c
+++ b/gio/gfile.c
@@ -2306,19 +2306,22 @@ file_copy_fallback (GFile                  *source,
   GFileInfo *info;
   const char *target;
 
+  /* need to know the file type */
+  info = g_file_query_info (source,
+			    G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
+			    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
+			    cancellable,
+			    error);
+
+  if (info == NULL)
+	  return FALSE;
+
   /* Maybe copy the symlink? */
-  if (flags & G_FILE_COPY_NOFOLLOW_SYMLINKS)
+  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&
+      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)
     {
-      info = g_file_query_info (source,
-				G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
-				G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
-				cancellable,
-				error);
-      if (info == NULL)
-	return FALSE;
-
-      if (g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK &&
-	  (target = g_file_info_get_symlink_target (info)) != NULL)
+      target = g_file_info_get_symlink_target (info);
+      if (target)
 	{
 	  if (!copy_symlink (destination, flags, cancellable, target, error))
 	    {
@@ -2329,10 +2332,23 @@ file_copy_fallback (GFile                  *source,
 	  g_object_unref (info);
 	  goto copied_file;
 	}
-      
+        /* ... else fall back on a regular file copy */
+	g_object_unref (info);
+    }
+  /* Handle "special" files (pipes, device nodes, ...)? */
+  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)
+    {
+      /* FIXME: could try to recreate device nodes and others? */
+
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                           _("Can't copy special file"));
       g_object_unref (info);
+      return FALSE;
     }
-  
+  /* Everything else should just fall back on a regular copy. */
+  else
+    g_object_unref (info);
+
   in = open_source_for_copy (source, destination, flags, cancellable, error);
   if (in == NULL)
     return FALSE;
@@ -2342,7 +2358,7 @@ file_copy_fallback (GFile                  *source,
       out = (GOutputStream *)g_file_replace (destination,
 					     NULL,
 					     flags & G_FILE_COPY_BACKUP,
-                                             0,
+                                             G_FILE_CREATE_REPLACE_DESTINATION,
 					     cancellable, error);
     }
   else
diff --git a/gio/gfileinfo.c b/gio/gfileinfo.c
index b772fee..e4968d1 100644
--- a/gio/gfileinfo.c
+++ b/gio/gfileinfo.c
@@ -302,6 +302,9 @@ g_file_info_copy_into (GFileInfo *src_info,
       _g_file_attribute_value_set (&dest[i].value, &source[i].value);
     }
 
+  if (dest_info->mask != NO_ATTRIBUTE_MASK)
+    g_file_attribute_matcher_unref (dest_info->mask);
+
   if (src_info->mask == NO_ATTRIBUTE_MASK)
     dest_info->mask = NO_ATTRIBUTE_MASK;
   else
diff --git a/gio/ginetaddress.c b/gio/ginetaddress.c
new file mode 100644
index 0000000..aa9d574
--- /dev/null
+++ b/gio/ginetaddress.c
@@ -0,0 +1,718 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "ginetaddress.h"
+#include "gioenums.h"
+#include "gioenumtypes.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetaddress
+ * @short_description: An IPv4/IPv6 address
+ *
+ * #GInetAddress represents an IPv4 or IPv6 internet address. Use
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
+ * look up the #GInetAddress for a hostname. Use
+ * g_resolver_lookup_by_address() or
+ * g_resolver_lookup_by_address_async() to look up the hostname for a
+ * #GInetAddress.
+ *
+ * To actually connect to a remote host, you will need a
+ * #GInetSocketAddress (which includes a #GInetAddress as well as a
+ * port number).
+ **/
+
+/**
+ * GInetAddress:
+ *
+ * An IPv4 or IPv6 internet address.
+ **/
+
+/* Networking initialization function, called from inside the g_once of
+ * g_inet_address_get_type()
+ */
+static void
+_g_networking_init (void)
+{
+#ifdef G_OS_WIN32
+  WSADATA wsadata;
+  if (WSAStartup (MAKEWORD (2, 0), &wsadata) != 0)
+    g_error ("Windows Sockets could not be initialized");
+#endif
+}
+
+G_DEFINE_TYPE_WITH_CODE (GInetAddress, g_inet_address, G_TYPE_OBJECT,
+			 _g_networking_init ();)
+
+struct _GInetAddressPrivate
+{
+  GSocketFamily family;
+  union {
+    struct in_addr ipv4;
+    struct in6_addr ipv6;
+  } addr;
+};
+
+enum
+{
+  PROP_0,
+  PROP_FAMILY,
+  PROP_BYTES,
+  PROP_IS_ANY,
+  PROP_IS_LOOPBACK,
+  PROP_IS_LINK_LOCAL,
+  PROP_IS_SITE_LOCAL,
+  PROP_IS_MULTICAST,
+  PROP_IS_MC_GLOBAL,
+  PROP_IS_MC_LINK_LOCAL,
+  PROP_IS_MC_NODE_LOCAL,
+  PROP_IS_MC_ORG_LOCAL,
+  PROP_IS_MC_SITE_LOCAL,
+};
+
+static void
+g_inet_address_set_property (GObject      *object,
+			     guint         prop_id,
+			     const GValue *value,
+			     GParamSpec   *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_FAMILY:
+      address->priv->family = g_value_get_enum (value);
+      break;
+
+    case PROP_BYTES:
+      memcpy (&address->priv->addr, g_value_get_pointer (value),
+	      address->priv->family == AF_INET ?
+	      sizeof (address->priv->addr.ipv4) :
+	      sizeof (address->priv->addr.ipv6));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_inet_address_get_property (GObject    *object,
+                             guint       prop_id,
+                             GValue     *value,
+                             GParamSpec *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+    case PROP_FAMILY:
+      g_value_set_enum (value, address->priv->family);
+      break;
+
+    case PROP_BYTES:
+      g_value_set_pointer (value, &address->priv->addr);
+      break;
+
+    case PROP_IS_ANY:
+      g_value_set_boolean (value, g_inet_address_get_is_any (address));
+      break;
+
+    case PROP_IS_LOOPBACK:
+      g_value_set_boolean (value, g_inet_address_get_is_loopback (address));
+      break;
+
+    case PROP_IS_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_link_local (address));
+      break;
+
+    case PROP_IS_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_site_local (address));
+      break;
+
+    case PROP_IS_MULTICAST:
+      g_value_set_boolean (value, g_inet_address_get_is_multicast (address));
+      break;
+
+    case PROP_IS_MC_GLOBAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_global (address));
+      break;
+
+    case PROP_IS_MC_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_link_local (address));
+      break;
+
+    case PROP_IS_MC_NODE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_node_local (address));
+      break;
+
+    case PROP_IS_MC_ORG_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_org_local (address));
+      break;
+
+    case PROP_IS_MC_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_site_local (address));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_address_class_init (GInetAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetAddressPrivate));
+
+  gobject_class->set_property = g_inet_address_set_property;
+  gobject_class->get_property = g_inet_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The address family (IPv4 or IPv6)"),
+						      G_TYPE_SOCKET_FAMILY,
+						      G_SOCKET_FAMILY_INVALID,
+						      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_BYTES,
+                                   g_param_spec_pointer ("bytes",
+							 _("Bytes"),
+							 _("The raw address data"),
+							 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_ANY,
+                                   g_param_spec_boolean ("is-any",
+                                                         _("Is any"),
+                                                         _("See g_inet_address_get_is_any()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-link-local",
+                                                         _("Is link-local"),
+                                                         _("See g_inet_address_get_is_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LOOPBACK,
+                                   g_param_spec_boolean ("is-loopback",
+                                                         _("Is loopback"),
+                                                         _("See g_inet_address_get_is_loopback()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-site-local",
+                                                         _("Is site-local"),
+                                                         _("See g_inet_address_get_is_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MULTICAST,
+                                   g_param_spec_boolean ("is-multicast",
+                                                         _("Is multicast"),
+                                                         _("See g_inet_address_get_is_multicast()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_GLOBAL,
+                                   g_param_spec_boolean ("is-mc-global",
+                                                         _("Is multicast global"),
+                                                         _("See g_inet_address_get_is_mc_global()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-mc-link-local",
+                                                         _("Is multicast link-local"),
+                                                         _("See g_inet_address_get_is_mc_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_NODE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-node-local",
+                                                         _("Is multicast node-local"),
+                                                         _("See g_inet_address_get_is_mc_node_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_ORG_LOCAL,
+                                   g_param_spec_boolean ("is-mc-org-local",
+                                                         _("Is multicast org-local"),
+                                                         _("See g_inet_address_get_is_mc_org_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-site-local",
+                                                         _("Is multicast site-local"),
+                                                         _("See g_inet_address_get_is_mc_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_inet_address_init (GInetAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_ADDRESS,
+                                               GInetAddressPrivate);
+}
+
+/**
+ * g_inet_address_new_from_string:
+ * @string: a string representation of an IP address
+ *
+ * Parses @string as an IP address and creates a new #GInetAddress.
+ *
+ * Returns: a new #GInetAddress corresponding to @string, or %NULL if
+ * @string could not be parsed.
+ */
+GInetAddress *
+g_inet_address_new_from_string (const gchar *string)
+{
+#ifdef G_OS_WIN32
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+  gint len;
+#else /* !G_OS_WIN32 */
+  struct in_addr in_addr;
+  struct in6_addr in6_addr;
+#endif
+
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+#ifdef G_OS_WIN32
+  memset (&sa, 0, sizeof (sa));
+  len = sizeof (sa);
+  if (WSAStringToAddress ((LPTSTR) string, AF_INET, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin->sin_addr, AF_INET);
+  else if (WSAStringToAddress ((LPTSTR) string, AF_INET6, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin6->sin6_addr, AF_INET6);
+
+#else /* !G_OS_WIN32 */
+
+  if (inet_pton (AF_INET, string, &in_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in_addr, AF_INET);
+  else if (inet_pton (AF_INET6, string, &in6_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in6_addr, AF_INET6);
+#endif
+
+  return NULL;
+}
+
+#define G_INET_ADDRESS_FAMILY_IS_VALID(family) ((family) == AF_INET || (family) == AF_INET6)
+
+/**
+ * g_inet_address_new_from_bytes:
+ * @bytes: raw address data
+ * @family: the address family of @bytes
+ *
+ * Creates a new #GInetAddress from the given @family and @bytes.
+ * @bytes should be 4 bytes for %G_INET_ADDRESS_IPV4 and 16 bytes for
+ * %G_INET_ADDRESS_IPV6.
+ *
+ * Returns: a new #GInetAddress corresponding to @family and @bytes.
+ */
+GInetAddress *
+g_inet_address_new_from_bytes (const guint8         *bytes,
+			       GSocketFamily  family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  return g_object_new (G_TYPE_INET_ADDRESS,
+		       "family", family,
+		       "bytes", bytes,
+		       NULL);
+}
+
+/**
+ * g_inet_address_new_loopback:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the loopback address for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the loopback address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_loopback (GSocketFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {127, 0, 0, 1};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_loopback.s6_addr, family);
+}
+
+/**
+ * g_inet_address_new_any:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the "any" address (unassigned/"don't
+ * care") for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the "any" address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_any (GSocketFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {0, 0, 0, 0};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_any.s6_addr, family);
+}
+
+
+/**
+ * g_inet_address_to_string:
+ * @address: a #GInetAddress
+ *
+ * Converts @address to string form.
+ *
+ * Returns: a representation of @address as a string, which should be
+ * freed after use.
+ */
+gchar *
+g_inet_address_to_string (GInetAddress *address)
+{
+  gchar buffer[INET6_ADDRSTRLEN];
+#ifdef G_OS_WIN32
+  DWORD buflen = sizeof (buffer), addrlen;
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+#endif
+
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+#ifdef G_OS_WIN32
+  sa.ss_family = address->priv->family;
+  if (address->priv->family == AF_INET)
+    {
+      addrlen = sizeof (*sin);
+      memcpy (&sin->sin_addr, &address->priv->addr.ipv4,
+	      sizeof (sin->sin_addr));
+      sin->sin_port = 0;
+    }
+  else
+    {
+      addrlen = sizeof (*sin6);
+      memcpy (&sin6->sin6_addr, &address->priv->addr.ipv6,
+	      sizeof (sin6->sin6_addr));
+      sin6->sin6_port = 0;
+    }
+  if (WSAAddressToString ((LPSOCKADDR) &sa, addrlen, NULL, buffer, &buflen) != 0)
+    return NULL;
+
+#else /* !G_OS_WIN32 */
+
+  if (address->priv->family == AF_INET)
+    inet_ntop (AF_INET, &address->priv->addr.ipv4, buffer, sizeof (buffer));
+  else
+    inet_ntop (AF_INET6, &address->priv->addr.ipv6, buffer, sizeof (buffer));
+#endif
+
+  return g_strdup (buffer);
+}
+
+/**
+ * g_inet_address_to_bytes:
+ * @address: a #GInetAddress
+ *
+ * Gets the raw binary address data from @address.
+ *
+ * Returns: a pointer to an internal array of the bytes in @address,
+ * which should not be modified, stored, or freed.
+ */
+const guint8 *
+g_inet_address_to_bytes (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return (guint8 *)&address->priv->addr;
+}
+
+/**
+ * g_inet_address_get_family:
+ * @address: a #GInetAddress
+ *
+ * Gets @address's family
+ *
+ * Returns: @address's family
+ */
+GSocketFamily
+g_inet_address_get_family (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  return address->priv->family;
+}
+
+/**
+ * g_inet_address_get_is_any:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the "any" address for its family.
+ *
+ * Returns: %TRUE if @address is the "any" address for its family.
+ */
+gboolean
+g_inet_address_get_is_any (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return addr4 == INADDR_ANY;
+    }
+  else
+    return IN6_IS_ADDR_UNSPECIFIED (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_loopback:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the loopback address for its family.
+ *
+ * Returns: %TRUE if @address is the loopback address for its family.
+ */
+gboolean
+g_inet_address_get_is_loopback (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 127.0.0.0/8 */
+      return ((addr4 & 0xff000000) == 0x7f000000);
+    }
+  else
+    return IN6_IS_ADDR_LOOPBACK (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local address (that is, if it
+ * identifies a host on a local network that is not connected to the
+ * Internet).
+ *
+ * Returns: %TRUE if @address is a link-local address.
+ */
+gboolean
+g_inet_address_get_is_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 169.254.0.0/16 */
+      return ((addr4 & 0xffff0000) == 0xa9fe0000);
+    }
+  else
+    return IN6_IS_ADDR_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local address such as 10.0.0.1
+ * (that is, the address identifies a host on a local network that can
+ * not be reached directly from the Internet, but which may have
+ * outgoing Internet connectivity via a NAT or firewall).
+ *
+ * Returns: %TRUE if @address is a site-local address.
+ */
+gboolean
+g_inet_address_get_is_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 */
+      return ((addr4 & 0xff000000) == 0x0a000000 ||
+	      (addr4 & 0xfff00000) == 0xac100000 ||
+	      (addr4 & 0xffff0000) == 0xc0a80000);
+    }
+  else
+    return IN6_IS_ADDR_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_multicast:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a multicast address.
+ *
+ * Returns: %TRUE if @address is a multicast address.
+ */
+gboolean
+g_inet_address_get_is_multicast (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return IN_MULTICAST (addr4);
+    }
+  else
+    return IN6_IS_ADDR_MULTICAST (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_global:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a global multicast address.
+ *
+ * Returns: %TRUE if @address is a global multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_global (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_GLOBAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local multicast address.
+ *
+ * Returns: %TRUE if @address is a link-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_node_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a node-local multicast address.
+ *
+ * Returns: %TRUE if @address is a node-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_node_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_NODELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_org_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is an organization-local multicast address.
+ *
+ * Returns: %TRUE if @address is an organization-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_org_local  (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_ORGLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local multicast address.
+ *
+ * Returns: %TRUE if @address is a site-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+#define __G_INET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetaddress.h b/gio/ginetaddress.h
new file mode 100644
index 0000000..2ef8bc0
--- /dev/null
+++ b/gio/ginetaddress.h
@@ -0,0 +1,101 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_ADDRESS_H__
+#define __G_INET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_ADDRESS         (g_inet_address_get_type ())
+#define G_INET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
+#define G_INET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
+#define G_IS_INET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
+#define G_IS_INET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
+#define G_INET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))
+
+typedef struct _GInetAddressClass   GInetAddressClass;
+typedef struct _GInetAddressPrivate GInetAddressPrivate;
+
+struct _GInetAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GInetAddressPrivate *priv;
+};
+
+struct _GInetAddressClass
+{
+  GObjectClass parent_class;
+
+  gchar *        (*to_string) (GInetAddress *address);
+  const guint8 * (*to_bytes)  (GInetAddress *address);
+};
+
+GType                 g_inet_address_get_type             (void) G_GNUC_CONST;
+
+GInetAddress *        g_inet_address_new_from_string      (const gchar   *string);
+
+GInetAddress *        g_inet_address_new_from_bytes       (const guint8  *bytes,
+						           GSocketFamily  family);
+
+GInetAddress *        g_inet_address_new_loopback         (GSocketFamily  family);
+
+GInetAddress *        g_inet_address_new_any              (GSocketFamily  family);
+
+gchar *               g_inet_address_to_string            (GInetAddress  *address);
+
+const guint8 *        g_inet_address_to_bytes             (GInetAddress  *address);
+
+GSocketFamily         g_inet_address_get_family           (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_any           (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_loopback      (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_link_local    (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_site_local    (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_multicast     (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_global     (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_link_local (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_node_local (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_org_local  (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_site_local (GInetAddress  *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_ADDRESS_H__ */
+
diff --git a/gio/ginetsocketaddress.c b/gio/ginetsocketaddress.c
new file mode 100644
index 0000000..f3bfa1d
--- /dev/null
+++ b/gio/ginetsocketaddress.c
@@ -0,0 +1,300 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "ginetsocketaddress.h"
+#include "ginetaddress.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetsocketaddress
+ * @short_description: Internet socket addresses
+ *
+ * An IPv4 or IPv6 socket address; that is, the combination of a
+ * #GInetAddress and a port number.
+ **/
+
+/**
+ * GInetSocketAddress:
+ *
+ * An IPv4 or IPv6 socket address, corresponding to a <type>struct
+ * sockaddr_in</type> or <type>struct sockaddr_in6</type>.
+ **/
+G_DEFINE_TYPE (GInetSocketAddress, g_inet_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum {
+  PROP_0,
+  PROP_ADDRESS,
+  PROP_PORT
+};
+
+struct _GInetSocketAddressPrivate
+{
+  GInetAddress *address;
+  guint16       port;
+};
+
+static void
+g_inet_socket_address_finalize (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_inet_socket_address_dispose (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  g_object_unref (address->priv->address);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_inet_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        g_value_set_object (value, address->priv->address);
+        break;
+
+      case PROP_PORT:
+        g_value_set_uint (value, address->priv->port);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        address->priv->address = g_object_ref (g_value_get_object (value));
+        break;
+
+      case PROP_PORT:
+        address->priv->port = (guint16) g_value_get_uint (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketFamily
+g_inet_socket_address_get_family (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+
+  return g_inet_address_get_family (addr->priv->address);
+}
+
+static gssize
+g_inet_socket_address_get_native_size (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+  GSocketFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    return sizeof (struct sockaddr_in);
+  else if (family == AF_INET6)
+    return sizeof (struct sockaddr_in6);
+  else
+    return -1;
+}
+
+static gboolean
+g_inet_socket_address_to_native (GSocketAddress *address,
+                                 gpointer        dest,
+				 gsize           destlen)
+{
+  GInetSocketAddress *addr;
+  GSocketFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *sock = (struct sockaddr_in *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      sock->sin_family = AF_INET;
+      sock->sin_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin_addr.s_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin_addr));
+      memset (sock->sin_zero, 0, sizeof (sock->sin_zero));
+      return TRUE;
+    }
+  else if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *sock = (struct sockaddr_in6 *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      memset (sock, 0, sizeof (sock));
+      sock->sin6_family = AF_INET6;
+      sock->sin6_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin6_addr.s6_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin6_addr));
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+static void
+g_inet_socket_address_class_init (GInetSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetSocketAddressPrivate));
+
+  gobject_class->finalize = g_inet_socket_address_finalize;
+  gobject_class->dispose = g_inet_socket_address_dispose;
+  gobject_class->set_property = g_inet_socket_address_set_property;
+  gobject_class->get_property = g_inet_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_inet_socket_address_get_family;
+  gsocketaddress_class->to_native = g_inet_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_inet_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class, PROP_ADDRESS,
+                                   g_param_spec_object ("address",
+                                                        "address",
+                                                        "address",
+                                                        G_TYPE_INET_ADDRESS,
+                                                        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      "port",
+                                                      "port",
+                                                      0,
+                                                      65535,
+                                                      0,
+                                                      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+}
+
+static void
+g_inet_socket_address_init (GInetSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_SOCKET_ADDRESS,
+                                               GInetSocketAddressPrivate);
+
+  address->priv->address = NULL;
+  address->priv->port = 0;
+}
+
+/**
+ * g_inet_socket_address_new:
+ * @address: a #GInetAddress
+ * @port: a port number
+ *
+ * Creates a new #GInetSocketAddress for @address and @port.
+ *
+ * Returns: a new #GInetSocketAddress
+ */
+GSocketAddress *
+g_inet_socket_address_new (GInetAddress *address,
+                           guint16       port)
+{
+  return g_object_new (G_TYPE_INET_SOCKET_ADDRESS,
+		       "address", address,
+		       "port", port,
+		       NULL);
+}
+
+/**
+ * g_inet_socket_address_get_address:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's #GInetAddress.
+ *
+ * Returns: the #GInetAddress for @address, which must be
+ * g_object_ref()'d if it will be stored
+ */
+GInetAddress *
+g_inet_socket_address_get_address (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), NULL);
+
+  return address->priv->address;
+}
+
+/**
+ * g_inet_socket_address_get_port:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's port.
+ *
+ * Returns: the port for @address
+ */
+guint16
+g_inet_socket_address_get_port (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  return address->priv->port;
+}
+
+#define __G_INET_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetsocketaddress.h b/gio/ginetsocketaddress.h
new file mode 100644
index 0000000..b455ac5
--- /dev/null
+++ b/gio/ginetsocketaddress.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_SOCKET_ADDRESS_H__
+#define __G_INET_SOCKET_ADDRESS_H__
+
+#include <gio/gsocketaddress.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_SOCKET_ADDRESS         (g_inet_socket_address_get_type ())
+#define G_INET_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
+#define G_INET_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+#define G_IS_INET_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_INET_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+
+typedef struct _GInetSocketAddressClass   GInetSocketAddressClass;
+typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
+
+struct _GInetSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GInetSocketAddressPrivate *priv;
+};
+
+struct _GInetSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_inet_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_inet_socket_address_new         (GInetAddress       *address,
+						   guint16             port);
+
+GInetAddress *  g_inet_socket_address_get_address (GInetSocketAddress *address);
+
+guint16         g_inet_socket_address_get_port    (GInetSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_SOCKET_ADDRESS_H__ */
diff --git a/gio/gio.h b/gio/gio.h
index e3a0b14..e61b8e4 100644
--- a/gio/gio.h
+++ b/gio/gio.h
@@ -49,6 +49,8 @@
 #include <gio/gfilterinputstream.h>
 #include <gio/gfilteroutputstream.h>
 #include <gio/gicon.h>
+#include <gio/ginetaddress.h>
+#include <gio/ginetsocketaddress.h>
 #include <gio/ginputstream.h>
 #include <gio/gioenums.h>
 #include <gio/gioenumtypes.h>
@@ -61,9 +63,15 @@
 #include <gio/gmount.h>
 #include <gio/gmountoperation.h>
 #include <gio/gnativevolumemonitor.h>
+#include <gio/gnetworkaddress.h>
+#include <gio/gnetworkservice.h>
 #include <gio/goutputstream.h>
+#include <gio/gresolver.h>
 #include <gio/gseekable.h>
 #include <gio/gsimpleasyncresult.h>
+#include <gio/gsocketaddress.h>
+#include <gio/gsocketconnectable.h>
+#include <gio/gsrvtarget.h>
 #include <gio/gthemedicon.h>
 #include <gio/gvfs.h>
 #include <gio/gvolume.h>
diff --git a/gio/gio.symbols b/gio/gio.symbols
index f73e9ff..55e111c 100644
--- a/gio/gio.symbols
+++ b/gio/gio.symbols
@@ -831,6 +831,8 @@ g_output_stream_splice_flags_get_type G_GNUC_CONST
 g_ask_password_flags_get_type G_GNUC_CONST
 g_password_save_get_type G_GNUC_CONST
 g_emblem_origin_get_type G_GNUC_CONST
+g_socket_family_get_type G_GNUC_CONST
+g_resolver_error_get_type G_GNUC_CONST
 #endif
 #endif
 
@@ -855,3 +857,136 @@ g_emblem_get_origin
 #endif
 #endif
 
+#if IN_HEADER(__G_INET_ADDRESS_H__)
+#if IN_FILE(__G_INET_ADDRESS_C__)
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_get_family
+g_inet_address_get_type G_GNUC_CONST
+g_inet_address_get_is_any
+g_inet_address_get_is_link_local
+g_inet_address_get_is_loopback
+g_inet_address_get_is_mc_global
+g_inet_address_get_is_mc_link_local
+g_inet_address_get_is_mc_node_local
+g_inet_address_get_is_mc_org_local
+g_inet_address_get_is_mc_site_local
+g_inet_address_get_is_multicast
+g_inet_address_get_is_site_local
+g_inet_address_to_bytes
+g_inet_address_to_string
+#endif
+#endif
+
+#if IN_HEADER(__G_INET_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_INET_SOCKET_ADDRESS_C__)
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+g_inet_socket_address_get_type G_GNUC_CONST
+g_inet_socket_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_UNIX_SOCKET_ADDRESS_C__)
+#ifdef G_OS_UNIX
+g_unix_socket_address_get_type G_GNUC_CONST
+g_unix_socket_address_new
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_SOCKET_ADDRESS_C__)
+g_socket_address_new_from_native
+g_socket_address_get_type G_GNUC_CONST
+g_socket_address_get_family
+g_socket_address_get_native_size
+g_socket_address_to_native
+#endif
+#endif
+
+#if IN_HEADER(__G_RESOLVER_H__)
+#if IN_FILE(__G_RESOLVER_C__)
+g_resolver_error_quark
+g_resolver_get_type G_GNUC_CONST
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+#endif
+#endif
+
+#if IN_HEADER(__G_THREADED_RESOLVER_H__)
+#if IN_FILE(__G_THREADED_RESOLVER_C__)
+g_threaded_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_RESOLVER_H__)
+#if IN_FILE(__G_UNIX_RESOLVER_C__)
+#ifdef G_OS_UNIX
+g_unix_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_WIN32_RESOLVER_H__)
+#if IN_FILE(__G_WIN32_RESOLVER_C__)
+#ifdef G_OS_WIN32
+g_win32_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SRV_TARGET_H__)
+#if IN_FILE(__G_SRV_TARGET_C__)
+g_srv_target_get_type G_GNUC_CONST
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_list_sort
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_ADDRESS_H__)
+#if IN_FILE(__G_NETWORK_ADDRESS_C__)
+g_network_address_get_type G_GNUC_CONST
+g_network_address_get_hostname
+g_network_address_get_port
+g_network_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_SERVICE_H__)
+#if IN_FILE(__G_NETWORK_SERVICE_C__)
+g_network_service_get_type G_GNUC_CONST
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_new
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_CONNECTABLE_H__)
+#if IN_FILE(__G_SOCKET_CONNECTABLE_C__)
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_get_type G_GNUC_CONST
+#endif
+#endif
diff --git a/gio/gioenums.h b/gio/gioenums.h
index 2b69ccf..4699aec 100644
--- a/gio/gioenums.h
+++ b/gio/gioenums.h
@@ -156,12 +156,21 @@ typedef enum {
  * @G_FILE_CREATE_NONE: No flags set.
  * @G_FILE_CREATE_PRIVATE: Create a file that can only be
  *    accessed by the current user.
+ * @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination
+ *    as if it didn't exist before. Don't try to keep any old
+ *    permissions, replace instead of following links. This
+ *    is generally useful if you're doing a "copy over" 
+ *    rather than a "save new version of" replace operation.
+ *    You can think of it as "unlink destination" before
+ *    writing to it, although the implementation may not
+ *    be exactly like that.
  *
  * Flags used when an operation may create a file.
  */
 typedef enum {
   G_FILE_CREATE_NONE    = 0,
-  G_FILE_CREATE_PRIVATE = (1 << 0)
+  G_FILE_CREATE_PRIVATE = (1 << 0),
+  G_FILE_CREATE_REPLACE_DESTINATION = (1 << 1)
 } GFileCreateFlags;
 
 
@@ -467,6 +476,41 @@ typedef enum  {
   G_EMBLEM_ORIGIN_TAG
 } GEmblemOrigin;
 
+/**
+ * GResolverError:
+ * @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not found
+ * @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not be looked up due to a network error or similar problem
+ * @G_RESOLVER_ERROR_INTERNAL: unknown error
+ *
+ * An error code used with %G_RESOLVER_ERROR in a #GError returned
+ * from a #GResolver routine.
+ */
+typedef enum {
+  G_RESOLVER_ERROR_NOT_FOUND,
+  G_RESOLVER_ERROR_TEMPORARY_FAILURE,
+  G_RESOLVER_ERROR_INTERNAL
+} GResolverError;
+
+/**
+ * GSocketFamily:
+ * @G_SOCKET_FAMILY_INVALID: no address family
+ * @G_SOCKET_FAMILY_IPV4: the IPv4 family
+ * @G_SOCKET_FAMILY_IPV6: the IPv6 family
+ * @G_SOCKET_FAMILY_UNIX: the UNIX domain family
+ *
+ * The protocol family of a #GSocketAddress. (These values are
+ * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
+ * if available.)
+ */
+typedef enum {
+  G_SOCKET_FAMILY_INVALID,
+  G_SOCKET_FAMILY_IPV4	= GLIB_SYSDEF_AF_INET,
+  G_SOCKET_FAMILY_IPV6	= GLIB_SYSDEF_AF_INET6
+#ifdef GLIB_SYSDEF_AF_UNIX
+                                              ,
+  G_SOCKET_FAMILY_UNIX = GLIB_SYSDEF_AF_UNIX
+#endif
+} GSocketFamily;
 
 G_END_DECLS
 
diff --git a/gio/giotypes.h b/gio/giotypes.h
index 981c195..6b08331 100644
--- a/gio/giotypes.h
+++ b/gio/giotypes.h
@@ -75,6 +75,8 @@ typedef struct _GFilenameCompleter            GFilenameCompleter;
 
 
 typedef struct _GIcon                         GIcon; /* Dummy typedef */
+typedef struct _GInetAddress                  GInetAddress;
+typedef struct _GInetSocketAddress            GInetSocketAddress;
 typedef struct _GInputStream                  GInputStream;
 typedef struct _GIOModule                     GIOModule;
 typedef struct _GIOExtensionPoint             GIOExtensionPoint;
@@ -97,9 +99,15 @@ typedef struct _GMemoryOutputStream           GMemoryOutputStream;
  **/
 typedef struct _GMount                        GMount; /* Dummy typedef */
 typedef struct _GMountOperation               GMountOperation;
+typedef struct _GNetworkAddress               GNetworkAddress;
+typedef struct _GNetworkService               GNetworkService;
 typedef struct _GOutputStream                 GOutputStream;
+typedef struct _GResolver                     GResolver;
 typedef struct _GSeekable                     GSeekable;
 typedef struct _GSimpleAsyncResult            GSimpleAsyncResult;
+typedef struct _GSocketAddress                GSocketAddress;
+typedef struct _GSocketConnectable            GSocketConnectable;
+typedef struct _GSrvTarget                    GSrvTarget;
 typedef struct _GThemedIcon                   GThemedIcon;
 typedef struct _GVfs                          GVfs; /* Dummy typedef */
 
diff --git a/gio/glocalfileoutputstream.c b/gio/glocalfileoutputstream.c
index 2d5ff3a..8ca3284 100644
--- a/gio/glocalfileoutputstream.c
+++ b/gio/glocalfileoutputstream.c
@@ -644,6 +644,7 @@ handle_overwrite_open (const char    *filename,
 		       const char    *etag,
 		       gboolean       create_backup,
 		       char         **temp_filename,
+		       GFileCreateFlags flags,
 		       GCancellable  *cancellable,
 		       GError       **error)
 {
@@ -653,6 +654,12 @@ handle_overwrite_open (const char    *filename,
   gboolean is_symlink;
   int open_flags;
   int res;
+  int mode;
+
+  if (flags & G_FILE_CREATE_PRIVATE)
+    mode = 0600;
+  else
+    mode = 0666;
 
   /* We only need read access to the original file if we are creating a backup.
    * We also add O_CREATE to avoid a race if the file was just removed */
@@ -665,16 +672,16 @@ handle_overwrite_open (const char    *filename,
    * when finding out if the file we opened was a symlink */
 #ifdef O_NOFOLLOW
   is_symlink = FALSE;
-  fd = g_open (filename, open_flags | O_NOFOLLOW, 0666);
+  fd = g_open (filename, open_flags | O_NOFOLLOW, mode);
   if (fd == -1 && errno == ELOOP)
     {
       /* Could be a symlink, or it could be a regular ELOOP error,
        * but then the next open will fail too. */
       is_symlink = TRUE;
-      fd = g_open (filename, open_flags, 0666);
+      fd = g_open (filename, open_flags, mode);
     }
 #else
-  fd = g_open (filename, open_flags, 0666);
+  fd = g_open (filename, open_flags, mode);
   /* This is racy, but we do it as soon as possible to minimize the race */
   is_symlink = g_file_test (filename, G_FILE_TEST_IS_SYMLINK);
 #endif
@@ -751,7 +758,8 @@ handle_overwrite_open (const char    *filename,
    * to a backup file and rewrite the contents of the file.
    */
   
-  if (!(original_stat.st_nlink > 1) && !is_symlink)
+  if ((flags & G_FILE_CREATE_REPLACE_DESTINATION) ||
+      (!(original_stat.st_nlink > 1) && !is_symlink))
     {
       char *dirname, *tmp_filename;
       int tmpfd;
@@ -767,16 +775,18 @@ handle_overwrite_open (const char    *filename,
 	  goto fallback_strategy;
 	}
       
-      /* try to keep permissions */
+      /* try to keep permissions (unless replacing) */
 
-      if (
+      if ( ! (flags & G_FILE_CREATE_REPLACE_DESTINATION) &&
+	   (
 #ifdef HAVE_FCHOWN
-	  fchown (tmpfd, original_stat.st_uid, original_stat.st_gid) == -1 ||
+	    fchown (tmpfd, original_stat.st_uid, original_stat.st_gid) == -1 ||
 #endif
 #ifdef HAVE_FCHMOD
-	  fchmod (tmpfd, original_stat.st_mode) == -1 ||
+	    fchmod (tmpfd, original_stat.st_mode) == -1 ||
 #endif
-	  0
+	    0
+	    )
 	  )
 	{
 	  struct stat tmp_statbuf;
@@ -899,26 +909,58 @@ handle_overwrite_open (const char    *filename,
 	}
     }
 
-  /* Truncate the file at the start */
+  if (flags & G_FILE_CREATE_REPLACE_DESTINATION)
+    {
+      close (fd);
+      
+      if (g_unlink (filename) != 0)
+	{
+	  int errsv = errno;
+	  
+	  g_set_error (error, G_IO_ERROR,
+		       g_io_error_from_errno (errsv),
+		       _("Error removing old file: %s"),
+		       g_strerror (errsv));
+	  goto err_out2;
+	}
+      
+      fd = g_open (filename, O_WRONLY | O_CREAT | O_BINARY, mode);
+      if (fd == -1)
+	{
+	  int errsv = errno;
+	  char *display_name = g_filename_display_name (filename);
+	  g_set_error (error, G_IO_ERROR,
+		       g_io_error_from_errno (errsv),
+		       _("Error opening file '%s': %s"),
+		       display_name, g_strerror (errsv));
+	  g_free (display_name);
+	  goto err_out2;
+	}
+    }
+  else
+    {
+      /* Truncate the file at the start */
 #ifdef G_OS_WIN32
-  if (g_win32_ftruncate (fd, 0) == -1)
+      if (g_win32_ftruncate (fd, 0) == -1)
 #else
-  if (ftruncate (fd, 0) == -1)
+	if (ftruncate (fd, 0) == -1)
 #endif
-    {
-      int errsv = errno;
-
-      g_set_error (error, G_IO_ERROR,
-		   g_io_error_from_errno (errsv),
-		   _("Error truncating file: %s"),
-		   g_strerror (errsv));
-      goto err_out;
+	  {
+	    int errsv = errno;
+	    
+	    g_set_error (error, G_IO_ERROR,
+			 g_io_error_from_errno (errsv),
+			 _("Error truncating file: %s"),
+			 g_strerror (errsv));
+	    goto err_out;
+	  }
     }
     
   return fd;
 
  err_out:
   close (fd);
+ err_out2:
   return -1;
 }
 
@@ -952,7 +994,7 @@ _g_local_file_output_stream_replace (const char        *filename,
     {
       /* The file already exists */
       fd = handle_overwrite_open (filename, etag, create_backup, &temp_file,
-				  cancellable, error);
+				  flags, cancellable, error);
       if (fd == -1)
 	return NULL;
     }
diff --git a/gio/gnetworkaddress.c b/gio/gnetworkaddress.c
new file mode 100644
index 0000000..9548df6
--- /dev/null
+++ b/gio/gnetworkaddress.c
@@ -0,0 +1,465 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkaddress.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkaddress
+ * @short_description: a #GSocketConnectable for resolving hostnames
+ * @include: gio/gio.h
+ *
+ * #GNetworkAddress provides an easy way to resolve a hostname and
+ * then attempt to connect to that host, handling the possibility of
+ * multiple IP addresses and multiple address families.
+ *
+ * |[
+ * MyConnectionType *
+ * connect_to_host (const char    *hostname,
+ *                  guint16        port,
+ *                  GCancellable  *cancellable,
+ *                  GError       **error)
+ * {
+ *   MyConnection *conn = NULL;
+ *   GSocketConnectable *addr;
+ *   GSocketAddress *sockaddr;
+ *   GError *conn_error = NULL;
+ *
+ *   addr = g_network_address_new ("www.gnome.org", 80);
+ *
+ *   /<!-- -->* Try each sockaddr until we succeed. Record the first
+ *    * connection error, but not any further ones (since they'll probably
+ *    * be basically the same as the first).
+ *    *<!-- -->/
+ *   while (!conn && (sockaddr = g_socket_connectable_get_next (addr, cancellable, error))
+ *     {
+ *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
+ *       g_object_unref (sockaddr);
+ *     }
+ *   g_object_unref (addr);
+ *
+ *   if (conn)
+ *     {
+ *       if (conn_error)
+ *         {
+ *           /<!-- -->* We couldn't connect to the first address, but we succeeded
+ *            * in connecting to a later address.
+ *            *<!-- -->/
+ *           g_error_free (conn_error);
+ *         }
+ *       return conn;
+ *     }
+ *   else if (error)
+ *     {
+ *       /<!-- -->* Either the initial lookup failed, or else the caller
+ *        * cancelled us.
+ *        *<!-- -->/
+ *       if (conn_error)
+ *         g_error_free (conn_error);
+ *       return NULL;
+ *     }
+ *   else
+ *     {
+ *       g_error_propagate (error, conn_error);
+ *       return NULL;
+ *     }
+ * }
+ * ]|
+ **/
+
+/**
+ * GNetworkAddress:
+ *
+ * A #GSocketConnectable for resolving a hostname and connecting to
+ * that host.
+ **/
+
+struct _GNetworkAddressPrivate {
+  gchar *hostname;
+  guint16 port;
+
+  GList *sockaddrs, *iter;
+};
+
+enum {
+  PROP_0,
+  PROP_HOSTNAME,
+  PROP_PORT,
+};
+
+static void g_network_address_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_address_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_address_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_address_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_address_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_address_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_address_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkAddress, g_network_address, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_address_connectable_iface_init))
+
+static void
+g_network_address_finalize (GObject *object)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  g_free (addr->priv->hostname);
+
+  if (addr->priv->sockaddrs)
+    {
+      GList *a;
+
+      for (a = addr->priv->sockaddrs; a; a = a->next)
+        g_object_unref (a->data);
+      g_list_free (addr->priv->sockaddrs);
+    }
+
+  G_OBJECT_CLASS (g_network_address_parent_class)->finalize (object);
+}
+
+static void
+g_network_address_class_init (GNetworkAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkAddressPrivate));
+
+  gobject_class->set_property = g_network_address_set_property;
+  gobject_class->get_property = g_network_address_get_property;
+  gobject_class->finalize = g_network_address_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_HOSTNAME,
+                                   g_param_spec_string ("hostname",
+                                                        P_("Hostname"),
+                                                        P_("Hostname to resolver"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      P_("Port"),
+                                                      P_("Network port"),
+                                                      0, 65535, 0,
+                                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_address_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_address_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_address_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_address_connectable_reset;
+}
+
+static void
+g_network_address_init (GNetworkAddress *addr)
+{
+  addr->priv = G_TYPE_INSTANCE_GET_PRIVATE (addr, G_TYPE_NETWORK_ADDRESS,
+                                            GNetworkAddressPrivate);
+}
+
+static void
+g_network_address_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_HOSTNAME:
+      if (addr->priv->hostname)
+        g_free (addr->priv->hostname);
+      addr->priv->hostname = g_value_dup_string (value);
+      break;
+
+    case PROP_PORT:
+      addr->priv->port = g_value_get_uint (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id)
+    { 
+    case PROP_HOSTNAME:
+      g_value_set_string (value, addr->priv->hostname);
+      break;
+
+    case PROP_PORT:
+      g_value_set_uint (value, addr->priv->port);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_set_addresses (GNetworkAddress *addr,
+                                 GList           *addresses)
+{
+  GList *a;
+  GSocketAddress *sockaddr;
+
+  g_return_if_fail (addresses != NULL && addr->priv->sockaddrs == NULL);
+
+  for (a = addresses; a; a = a->next)
+    {
+      sockaddr = g_inet_socket_address_new (a->data, addr->priv->port);
+      addr->priv->sockaddrs = g_list_prepend (addr->priv->sockaddrs, sockaddr);
+      g_object_unref (a->data);
+    }
+  g_list_free (addresses);
+  addr->priv->sockaddrs = g_list_reverse (addr->priv->sockaddrs);
+}
+
+/**
+ * g_network_address_new:
+ * @hostname: the hostname
+ * @port: the port
+ *
+ * Creates a new #GSocketConnectable for connecting to the given
+ * @hostname and @port.
+ *
+ * Return value: the new #GNetworkAddress
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_address_new (const gchar *hostname,
+                       guint16      port)
+{
+  return g_object_new (G_TYPE_NETWORK_ADDRESS,
+                       "hostname", hostname,
+                       "port", port,
+                       NULL);
+}
+
+/**
+ * g_network_address_get_hostname:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
+ * depending on what @addr was created with.
+ *
+ * Return value: @addr's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_address_get_hostname (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), NULL);
+
+  return addr->priv->hostname;
+}
+
+/**
+ * g_network_address_get_port:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's port number
+ *
+ * Return value: @addr's port (which may be %0)
+ *
+ * Since: 2.20
+ **/
+guint16
+g_network_address_get_port (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), 0);
+
+  return addr->priv->port;
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSocketAddress *sockaddr;
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver,
+                                             addr->priv->hostname,
+                                             cancellable, error);
+      g_object_unref (resolver);
+
+      if (!addresses)
+        return NULL;
+
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  if (!addr->priv->iter)
+    return NULL;
+  else
+    {
+      sockaddr = addr->priv->iter->data;
+      addr->priv->iter = addr->priv->iter->next;
+      return g_object_ref (sockaddr);
+    }
+}
+
+static void
+got_addresses (GObject      *source_object,
+               GAsyncResult *result,
+               gpointer      user_data)
+{
+  GResolver *resolver = G_RESOLVER (source_object);
+  GSimpleAsyncResult *simple = user_data;
+  GNetworkAddress *addr;
+  GList *addresses;
+  GError *error = NULL;
+  GSocketAddress *sockaddr;
+
+  addr = (GNetworkAddress *)g_async_result_get_source_object (G_ASYNC_RESULT (simple));
+  /* get_source_object adds a ref */
+  g_object_unref (addr);
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  if (error)
+    {
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+    }
+  else
+    {
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  sockaddr = g_network_address_connectable_get_next (G_SOCKET_CONNECTABLE (addr), NULL, NULL);
+  if (sockaddr)
+    g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+  g_simple_async_result_complete (simple);
+  g_object_unref (simple);
+}
+
+static void
+g_network_address_connectable_get_next_async (GSocketConnectable   *connectable,
+                                              GCancellable         *cancellable,
+                                              GAsyncReadyCallback   callback,
+                                              gpointer              user_data)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  simple = g_simple_async_result_new (G_OBJECT (connectable),
+                                      callback, user_data,
+                                      g_network_address_connectable_get_next_async);
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+
+      g_resolver_lookup_by_name_async (resolver,
+                                       addr->priv->hostname,
+                                       cancellable,
+                                       got_addresses, simple);
+      g_object_unref (resolver);
+    }
+  else
+    {
+      sockaddr = g_network_address_connectable_get_next (connectable, NULL, NULL);
+      if (sockaddr)
+        g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+    }
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+
+  addr->priv->iter = addr->priv->sockaddrs;
+}
+
+#define __G_NETWORK_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkaddress.h b/gio/gnetworkaddress.h
new file mode 100644
index 0000000..47dba10
--- /dev/null
+++ b/gio/gnetworkaddress.h
@@ -0,0 +1,65 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_ADDRESS_H__
+#define __G_NETWORK_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
+#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
+#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
+#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
+#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+
+typedef struct _GNetworkAddressClass   GNetworkAddressClass;
+typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
+
+struct _GNetworkAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkAddressPrivate *priv;
+};
+
+struct _GNetworkAddressClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType               g_network_address_get_type       (void) G_GNUC_CONST;
+
+GSocketConnectable *g_network_address_new            (const gchar      *hostname,
+						      guint16           port);
+const gchar        *g_network_address_get_hostname   (GNetworkAddress  *addr);
+guint16             g_network_address_get_port       (GNetworkAddress  *addr);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_ADDRESS_H__ */
diff --git a/gio/gnetworkingprivate.h b/gio/gnetworkingprivate.h
new file mode 100644
index 0000000..c41f598
--- /dev/null
+++ b/gio/gnetworkingprivate.h
@@ -0,0 +1,85 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_NETWORKINGPRIVATE_H__
+#define __G_NETWORKINGPRIVATE_H__
+
+#ifdef G_OS_WIN32
+
+#define WINVER 0x0501 // FIXME?
+#include <winsock2.h>
+#undef interface
+#include <ws2tcpip.h>
+#include <windns.h>
+
+#else /* !G_OS_WIN32 */
+
+#define BIND_4_COMPAT
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+/* We're supposed to define _GNU_SOURCE to get EAI_NODATA, but that
+ * won't actually work since <features.h> has already been included at
+ * this point. So we define __USE_GNU instead.
+ */
+#define __USE_GNU
+#include <netdb.h>
+#undef __USE_GNU
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <resolv.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#endif
+
+G_BEGIN_DECLS
+
+extern struct addrinfo _g_resolver_addrinfo_hints;
+
+GList *_g_resolver_addresses_from_addrinfo (const char       *hostname,
+					    struct addrinfo  *res,
+					    gint              gai_retval,
+					    GError          **error);
+
+void   _g_resolver_address_to_sockaddr     (GInetAddress            *address,
+					    struct sockaddr_storage *sa,
+					    gsize                   *sa_len);
+char  *_g_resolver_name_from_nameinfo      (GInetAddress     *address,
+					    const gchar      *name,
+					    gint              gni_retval,
+					    GError          **error);
+
+#if defined(G_OS_UNIX)
+GList *_g_resolver_targets_from_res_query  (const gchar      *rrname,
+					    guchar           *answer,
+					    gint              len,
+					    gint              herr,
+					    GError          **error);
+#elif defined(G_OS_WIN32)
+GList *_g_resolver_targets_from_DnsQuery   (const gchar      *rrname,
+					    DNS_STATUS        status,
+					    DNS_RECORD       *results,
+					    GError          **error);
+#endif
+
+G_END_DECLS
+
+#endif /* __G_NETWORKINGPRIVATE_H__ */
diff --git a/gio/gnetworkservice.c b/gio/gnetworkservice.c
new file mode 100644
index 0000000..b23619b
--- /dev/null
+++ b/gio/gnetworkservice.c
@@ -0,0 +1,610 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkservice.h"
+#include "gcancellable.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkservice
+ * @short_description: a #GSocketConnectable for resolving SRV records
+ * @include: gio/gio.h
+ *
+ * Like #GNetworkAddress does with hostnames, #GNetworkService
+ * provides an easy way to resolve a SRV record, and then attempt to
+ * connect to one of the hosts that implements that service, handling
+ * service priority/weighting, multiple IP addresses, and multiple
+ * address families.
+ *
+ * See #GSrvTarget for more information about SRV records.
+ **/
+
+/**
+ * GNetworkService:
+ *
+ * A #GSocketConnectable for resolving a SRV record and connecting to
+ * that service.
+ **/
+
+struct _GNetworkServicePrivate
+{
+  gchar *service, *protocol, *domain;
+
+  GResolver *resolver;
+  GList *targets, *target_iter;
+  GList *addrs, *addr_iter;
+
+  GSimpleAsyncResult *next_result;
+  GCancellable *cancellable;
+  GError *iter_error;
+};
+
+enum {
+  PROP_0,
+  PROP_SERVICE,
+  PROP_PROTOCOL,
+  PROP_DOMAIN,
+};
+
+static void g_network_service_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_service_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_service_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_service_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_service_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_service_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_service_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkService, g_network_service, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_service_connectable_iface_init))
+
+static void
+g_network_service_finalize (GObject *object)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  g_free (srv->priv->service);
+  g_free (srv->priv->protocol);
+  g_free (srv->priv->domain);
+
+  if (srv->priv->targets)
+    g_resolver_free_targets (srv->priv->targets);
+
+  g_object_unref (srv->priv->resolver);
+  g_network_service_connectable_reset ((GSocketConnectable *)srv);
+
+  G_OBJECT_CLASS (g_network_service_parent_class)->finalize (object);
+}
+
+static void
+g_network_service_class_init (GNetworkServiceClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkServicePrivate));
+
+  gobject_class->set_property = g_network_service_set_property;
+  gobject_class->get_property = g_network_service_get_property;
+  gobject_class->finalize = g_network_service_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_SERVICE,
+                                   g_param_spec_string ("service",
+                                                        P_("Service"),
+                                                        P_("Service name, eg \"ldap\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PROTOCOL,
+                                   g_param_spec_string ("protocol",
+                                                        P_("Protocol"),
+                                                        P_("Network protocol, eg \"tcp\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_DOMAIN,
+                                   g_param_spec_string ("domain",
+                                                        P_("domain"),
+                                                        P_("Network domain, eg, \"example.com\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_service_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_service_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_service_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_service_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_service_connectable_reset;
+}
+
+static void
+g_network_service_init (GNetworkService *srv)
+{
+  srv->priv = G_TYPE_INSTANCE_GET_PRIVATE (srv, G_TYPE_NETWORK_SERVICE,
+                                           GNetworkServicePrivate);
+  srv->priv->resolver = g_resolver_get_default ();
+}
+
+static void
+g_network_service_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id) 
+    {
+    case PROP_SERVICE:
+      srv->priv->service = g_value_dup_string (value);
+      break;
+
+    case PROP_PROTOCOL:
+      srv->priv->protocol = g_value_dup_string (value);
+      break;
+
+    case PROP_DOMAIN:
+      srv->priv->domain = g_value_dup_string (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_service_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id)
+    { 
+    case PROP_SERVICE:
+      g_value_set_string (value, g_network_service_get_service (srv));
+      break;
+
+    case PROP_PROTOCOL:
+      g_value_set_string (value, g_network_service_get_protocol (srv));
+      break;
+
+    case PROP_DOMAIN:
+      g_value_set_string (value, g_network_service_get_domain (srv));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+/**
+ * g_network_service_new:
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ *
+ * Creates a new #GNetworkService representing the given @service,
+ * @protocol, and @domain. This will initially be unresolved; use the
+ * #GSocketConnectable interface to resolve it.
+ *
+ * Return value: a new #GNetworkService
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_service_new (const gchar *service,
+                       const gchar *protocol,
+                       const gchar *domain)
+{
+  return g_object_new (G_TYPE_NETWORK_SERVICE,
+                       "service", service,
+                       "protocol", protocol,
+                       "domain", domain,
+                       NULL);
+}
+
+/**
+ * g_network_service_get_service:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's service name (eg, "ldap").
+ *
+ * Return value: @srv's service name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_service (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->service;
+}
+
+/**
+ * g_network_service_get_protocol:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's protocol name (eg, "tcp").
+ *
+ * Return value: @srv's protocol name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_protocol (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->protocol;
+}
+
+/**
+ * g_network_service_get_domain:
+ * @srv: a #GNetworkService
+ *
+ * Gets the domain that @srv serves. This might be either UTF-8 or
+ * ASCII-encoded, depending on what @srv was created with.
+ *
+ * Return value: @srv's domain name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_domain (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->domain;
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+  GSrvTarget *target;
+  GSocketAddress *sockaddr;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      GList *targets;
+
+      targets = g_resolver_lookup_service (srv->priv->resolver,
+                                           srv->priv->service,
+                                           srv->priv->protocol,
+                                           srv->priv->domain,
+                                           cancellable, error);
+      if (!targets)
+        return NULL;
+
+      srv->priv->targets = targets;
+      srv->priv->target_iter = srv->priv->targets;
+    }
+
+  /* Make sure we have a set of resolved addresses for the current
+   * target. When resolving the first target, we save the GError, if
+   * any. If any later target succeeds, we'll free the earlier error,
+   * but if we get to the last target without any of them resolving,
+   * we return that initial error.
+   */
+  do
+    {
+      /* Return if we're out of targets. */
+      if (!srv->priv->target_iter)
+        {
+          if (srv->priv->iter_error)
+            {
+              g_propagate_error (error, srv->priv->iter_error);
+              srv->priv->iter_error = NULL;
+            }
+          return NULL;
+        }
+      target = srv->priv->target_iter->data;
+
+      /* If we haven't resolved the addrs for the current target, do that */
+      if (!srv->priv->addrs)
+        {
+          GError **error_p;
+
+          if (srv->priv->target_iter == srv->priv->targets)
+            error_p = &srv->priv->iter_error;
+          else
+            error_p = NULL;
+          srv->priv->addrs = g_resolver_lookup_by_name (srv->priv->resolver,
+                                                        g_srv_target_get_hostname (target),
+                                                        cancellable, error_p);
+          if (g_cancellable_set_error_if_cancelled (cancellable, error))
+            return NULL;
+
+          if (srv->priv->addrs)
+            {
+              srv->priv->addr_iter = srv->priv->addrs;
+              if (srv->priv->iter_error)
+                {
+                  g_error_free (srv->priv->iter_error);
+                  srv->priv->iter_error = NULL;
+                }
+            }
+          else
+            {
+              /* Try the next target */
+              srv->priv->target_iter = srv->priv->target_iter->next;
+            }
+        }
+    }
+  while (!srv->priv->addrs);
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (target));
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  return sockaddr;
+}
+
+static void get_next_async_resolved_targets   (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_targets       (GNetworkService *srv);
+static void get_next_async_resolved_addresses (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_addresses     (GNetworkService *srv);
+
+/* The async version is basically the same as the sync, except we have
+ * to split it into multiple functions.
+ */
+static void
+g_network_service_connectable_get_next_async (GSocketConnectable  *connectable,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_return_if_fail (srv->priv->next_result == NULL);
+
+  srv->priv->next_result = g_simple_async_result_new (G_OBJECT (connectable),
+                                                      callback, user_data,
+                                                      g_network_service_connectable_get_next_async);
+  srv->priv->cancellable = cancellable;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      g_resolver_lookup_service_async (srv->priv->resolver,
+                                       srv->priv->service,
+                                       srv->priv->protocol,
+                                       srv->priv->domain,
+                                       cancellable,
+                                       get_next_async_resolved_targets,
+                                       srv);
+    }
+  else
+    get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_resolved_targets (GObject      *source_object,
+                                 GAsyncResult *result,
+                                 gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->targets = g_resolver_lookup_service_finish (srv->priv->resolver,
+                                                         result, &error);
+  if (error)
+    {
+      GSimpleAsyncResult *simple = srv->priv->next_result;
+
+      srv->priv->next_result = NULL;
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+      g_simple_async_result_complete (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  srv->priv->target_iter = srv->priv->targets;
+  get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_have_targets (GNetworkService *srv)
+{
+  GSrvTarget *target;
+
+  /* Get the current target, check if we're already done. */
+  if (!srv->priv->target_iter)
+    {
+      if (srv->priv->iter_error)
+        {
+          g_simple_async_result_set_from_error (srv->priv->next_result, srv->priv->iter_error);
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      g_simple_async_result_complete_in_idle (srv->priv->next_result);
+      g_object_unref (srv->priv->next_result);
+      srv->priv->next_result = NULL;
+      return;
+    }
+  target = srv->priv->target_iter->data;
+
+  /* If we haven't resolved the addrs for the current target, do that */
+  if (!srv->priv->addrs)
+    {
+      g_resolver_lookup_by_name_async (srv->priv->resolver,
+                                       g_srv_target_get_hostname (target),
+                                       srv->priv->cancellable,
+                                       get_next_async_resolved_addresses,
+                                       srv);
+    }
+  else
+    get_next_async_have_addresses (srv);
+}
+
+static void
+get_next_async_resolved_addresses (GObject      *source_object,
+                                   GAsyncResult *result,
+                                   gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->addrs = g_resolver_lookup_by_name_finish (srv->priv->resolver, result, &error);
+  if (srv->priv->addrs)
+    {
+      srv->priv->addr_iter = srv->priv->addrs;
+      if (srv->priv->iter_error)
+        {
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      get_next_async_have_addresses (srv);
+    }
+  else
+    {
+      if (g_cancellable_is_cancelled (srv->priv->cancellable))
+        {
+          GSimpleAsyncResult *simple = srv->priv->next_result;
+
+          srv->priv->next_result = NULL;
+          g_simple_async_result_set_from_error (srv->priv->next_result, error);
+          g_error_free (error);
+          g_simple_async_result_complete (simple);
+          g_object_unref (simple);
+        }
+      else
+        {
+          if (srv->priv->target_iter == srv->priv->targets)
+            srv->priv->iter_error = error;
+          else
+            g_error_free (error);
+
+          /* Try the next target */
+          srv->priv->target_iter = srv->priv->target_iter->next;
+          get_next_async_have_targets (srv);
+        }
+    }
+}
+
+static void
+get_next_async_have_addresses (GNetworkService *srv)
+{
+  GSocketAddress *sockaddr;
+  GSimpleAsyncResult *simple = srv->priv->next_result;
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (srv->priv->target_iter->data));
+
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  srv->priv->next_result = NULL;
+  g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+  g_simple_async_result_complete_in_idle (simple);
+  g_object_unref (simple);
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_service_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_resolver_free_addresses (srv->priv->addrs);
+  srv->priv->addrs = NULL;
+  srv->priv->target_iter = srv->priv->targets;
+  if (srv->priv->iter_error)
+    {
+      g_error_free (srv->priv->iter_error);
+      srv->priv->iter_error = NULL;
+    }
+}
+
+#define __G_NETWORK_SERVICE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkservice.h b/gio/gnetworkservice.h
new file mode 100644
index 0000000..b1a754b
--- /dev/null
+++ b/gio/gnetworkservice.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_SERVICE_H__
+#define __G_NETWORK_SERVICE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
+#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
+#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
+#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
+#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+
+typedef struct _GNetworkServiceClass   GNetworkServiceClass;
+typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
+
+struct _GNetworkService
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkServicePrivate *priv;
+};
+
+struct _GNetworkServiceClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType                g_network_service_get_type      (void) G_GNUC_CONST;
+
+GSocketConnectable  *g_network_service_new           (const gchar     *service,
+						      const gchar     *protocol,
+						      const gchar     *domain);
+
+const gchar         *g_network_service_get_service   (GNetworkService *srv);
+const gchar         *g_network_service_get_protocol  (GNetworkService *srv);
+const gchar         *g_network_service_get_domain    (GNetworkService *srv);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_SERVICE_H__ */
+
diff --git a/gio/gresolver.c b/gio/gresolver.c
new file mode 100644
index 0000000..ef046bc
--- /dev/null
+++ b/gio/gresolver.c
@@ -0,0 +1,865 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gresolver.h"
+#include "gnetworkingprivate.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gsimpleasyncresult.h"
+#include "gsrvtarget.h"
+
+#ifdef G_OS_UNIX
+#include "gunixresolver.h"
+#endif
+#ifdef G_OS_WIN32
+#include "gwin32resolver.h"
+#endif
+
+#include <stdlib.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gresolver
+ * @short_description: Asynchronous and cancellable DNS resolver
+ * @include: gio/gio.h
+ *
+ * #GResolver provides cancellable synchronous and asynchronous DNS
+ * resolution, for hostnames (g_resolver_lookup_by_address(),
+ * g_resolver_lookup_by_name() and their async variants) and SRV
+ * (service) records (g_resolver_lookup_service()).
+ *
+ * #GNetworkAddress and #GNetworkService provide wrappers around
+ * #GResolver functionality that also implement #GSocketConnectable,
+ * making it easy to connect to a remote host/service.
+ **/
+
+/**
+ * GResolver:
+ *
+ * The object that handles DNS resolution. Use g_resolver_get_default()
+ * to get the default resolver.
+ */
+G_DEFINE_TYPE (GResolver, g_resolver, G_TYPE_OBJECT)
+
+static void
+g_resolver_class_init (GResolverClass *resolver_class)
+{
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+  /* Initialize _g_resolver_addrinfo_hints */
+#ifdef AI_ADDRCONFIG
+  _g_resolver_addrinfo_hints.ai_flags |= AI_ADDRCONFIG;
+#endif
+  /* These two don't actually matter, they just get copied into the
+   * returned addrinfo structures (and then we ignore them). But if
+   * we leave them unset, we'll get back duplicate answers.
+   */
+  _g_resolver_addrinfo_hints.ai_socktype = SOCK_STREAM;
+  _g_resolver_addrinfo_hints.ai_protocol = IPPROTO_TCP;
+}
+
+static void
+g_resolver_init (GResolver *resolver)
+{
+  ;
+}
+
+static GResolver *default_resolver;
+
+/**
+ * g_resolver_get_default:
+ *
+ * Gets the default #GResolver. You should unref it when you are done
+ * with it. #GResolver may use its reference count as a hint about how
+ * many threads/processes, etc it should allocate for concurrent DNS
+ * resolutions.
+ *
+ * Return value: the #GResolver.
+ *
+ * Since: 2.20
+ **/
+GResolver *
+g_resolver_get_default (void)
+{
+  if (!default_resolver)
+    {
+      if (g_thread_supported ())
+        default_resolver = g_object_new (G_TYPE_THREADED_RESOLVER, NULL);
+      else
+        {
+#if defined(G_OS_UNIX)
+          default_resolver = g_object_new (G_TYPE_UNIX_RESOLVER, NULL);
+#elif defined(G_OS_WIN32)
+          default_resolver = g_object_new (G_TYPE_WIN32_RESOLVER, NULL);
+#endif
+        }
+    }
+
+  return g_object_ref (default_resolver);
+}
+
+/**
+ * g_resolver_set_default:
+ * @resolver: the new default #GResolver
+ *
+ * Sets @resolver to be the application's default resolver (reffing
+ * @resolver, and unreffing the previous default resolver, if any).
+ * Future calls to g_resolver_get_default() will return this resolver.
+ *
+ * This can be used if an applications wants to perform any sort of
+ * DNS caching or "pinning"; it can implement its own #GResolver that
+ * calls the original default resolver for DNS operations, and
+ * implements its own cache policies on top of that, and then set
+ * itself as the default resolver for all later code to use.
+ **/
+void
+g_resolver_set_default (GResolver *resolver)
+{
+  if (default_resolver)
+    g_object_unref (default_resolver);
+  default_resolver = g_object_ref (resolver);
+}
+
+
+/**
+ * g_resolver_lookup_by_name:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously resolves @hostname to determine its associated IP
+ * address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
+ * the textual form of an IP address (in which case this just becomes
+ * a wrapper around g_inet_address_new_from_string()).
+ *
+ * On success, g_resolver_lookup_by_name() will return a #GList of
+ * #GInetAddress, sorted in order of preference. (That is, you should
+ * attempt to connect to the first address first, then the second if
+ * the first fails, etc.) You must unref each address and free the
+ * list when you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to a
+ * value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to a socket on the resolved IP
+ * address, it may be easier to create a #GNetworkAddress and use its
+ * #GSocketConnectable interface.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. You
+ * must unref each of the addresses and free the list when you are
+ * done with it. (You can use g_resolver_free_addresses() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name (GResolver     *resolver,
+                           const gchar   *hostname,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GInetAddress *addr;
+  GList *addrs;
+  gchar *ascii_hostname = NULL;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (hostname != NULL, NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    return g_list_append (NULL, addr);
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  addrs = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name (resolver, hostname, cancellable, error);
+
+  g_free (ascii_hostname);
+  return addrs;
+}
+
+/**
+ * g_resolver_lookup_by_name_async:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up the address of
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously resolving @hostname to determine its
+ * associated IP address(es), and eventually calls @callback, which
+ * must call g_resolver_lookup_by_name_finish() to get the result. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_name_async (GResolver           *resolver,
+                                 const gchar         *hostname,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  GInetAddress *addr;
+  gchar *ascii_hostname = NULL;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (hostname != NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    {
+      GSimpleAsyncResult *simple;
+      GList *addrs;
+
+      simple = g_simple_async_result_new (G_OBJECT (resolver),
+                                          callback, user_data,
+                                          g_resolver_lookup_by_name_async);
+
+      addrs = g_list_append (NULL, addr);
+      g_simple_async_result_set_op_res_gpointer (simple, addrs, (GDestroyNotify)g_resolver_free_addresses);
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_async (resolver, hostname, cancellable, callback, user_data);
+
+  g_free (ascii_hostname);
+}
+
+/**
+ * g_resolver_lookup_by_name_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a call to
+ * g_resolver_lookup_by_name_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+
+      /* Handle the stringified-IP-addr case */
+      if (g_simple_async_result_get_source_tag (simple) == g_resolver_lookup_by_name_async)
+        {
+          GList *addrs;
+
+          addrs = g_simple_async_result_get_op_res_gpointer (simple);
+          g_simple_async_result_set_op_res_gpointer (simple, NULL, NULL);
+          return addrs;
+        }
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_addresses:
+ * @addresses: a #GList of #GInetAddress
+ *
+ * Frees @addresses (which should be the return value from
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
+ * (This is a convenience method; you can also simply free the results
+ * by hand.)
+ **/
+void
+g_resolver_free_addresses (GList *addresses)
+{
+  GList *a;
+
+  for (a = addresses; a; a = a->next)
+    g_object_unref (a->data);
+  g_list_free (addresses);
+}
+
+/**
+ * g_resolver_lookup_by_address:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously reverse-resolves @address to determine its
+ * associated hostname.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address (GResolver     *resolver,
+                              GInetAddress  *address,
+                              GCancellable  *cancellable,
+                              GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address (resolver, address, cancellable, error);
+}
+
+/**
+ * g_resolver_lookup_by_address_async:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously reverse-resolving @address to determine its
+ * associated hostname, and eventually calls @callback, which must
+ * call g_resolver_lookup_by_address_finish() to get the final result.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_address_async (GResolver           *resolver,
+                                    GInetAddress        *address,
+                                    GCancellable        *cancellable,
+                                    GAsyncReadyCallback  callback,
+                                    gpointer             user_data)
+{
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (G_IS_INET_ADDRESS (address));
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_async (resolver, address, cancellable, callback, user_data);
+}
+
+/**
+ * g_resolver_lookup_by_address_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_by_address_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address_finish (GResolver     *resolver,
+                                     GAsyncResult  *result,
+                                     GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_finish (resolver, result, error);
+}
+
+static gchar *
+g_resolver_get_service_rrname (const char *service,
+                               const char *protocol,
+                               const char *domain)
+{
+  gchar *rrname, *ascii_domain = NULL;
+
+  if (g_hostname_is_non_ascii (domain))
+    domain = ascii_domain = g_hostname_to_ascii (domain);
+
+  rrname = g_strdup_printf ("_%s._%s.%s", service, protocol, domain);
+
+  g_free (ascii_domain);
+  return rrname;
+}
+
+/**
+ * g_resolver_lookup_service:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously performs a DNS SRV lookup for the given @service and
+ * @protocol in the given @domain and returns an array of #GSrvTarget.
+ * @domain may be an ASCII-only or UTF-8 hostname. Note also that the
+ * @service and @protocol arguments DO NOT include the leading
+ * underscore that appears in the actual DNS entry.
+ *
+ * On success, g_resolver_lookup_service() will return a #GList of
+ * #GSrvTarget, sorted in order of preference. (That is, you should
+ * attempt to connect to the first target first, then the second if
+ * the first fails, etc.) You must free each target and the list when
+ * you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to the service, it is usually easier
+ * to create a #GNetworkService and use its #GSocketConnectable
+ * interface.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. You must
+ * free each of the targets and the list when you are done with it.
+ * (You can use g_resolver_free_targets() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service (GResolver     *resolver,
+                           const gchar   *service,
+                           const gchar   *protocol,
+                           const gchar   *domain,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GList *targets;
+  gchar *rrname;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (service != NULL, NULL);
+  g_return_val_if_fail (protocol != NULL, NULL);
+  g_return_val_if_fail (domain != NULL, NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  targets = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service (resolver, rrname, cancellable, error);
+
+  g_free (rrname);
+  return targets;
+}
+
+/**
+ * g_resolver_lookup_service_async:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously performing a DNS SRV lookup for the given
+ * @service and @protocol in the given @domain, and eventually calls
+ * @callback, which must call g_resolver_lookup_service_finish() to
+ * get the final result. See g_resolver_lookup_service() for more
+ * details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_service_async (GResolver           *resolver,
+                                 const gchar         *service,
+                                 const gchar         *protocol,
+                                 const gchar         *domain,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  gchar *rrname;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (service != NULL);
+  g_return_if_fail (protocol != NULL);
+  g_return_if_fail (domain != NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_async (resolver, rrname, cancellable, callback, user_data);
+
+  g_free (rrname);
+}
+
+/**
+ * g_resolver_lookup_service_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_service_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. See
+ * g_resolver_lookup_service() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_targets:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Frees @targets (which should be the return value from
+ * g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
+ * (This is a convenience method; you can also simply free the
+ * results by hand.)
+ **/
+void
+g_resolver_free_targets (GList *targets)
+{
+  GList *t;
+
+  for (t = targets; t; t = t->next)
+    g_srv_target_free (t->data);
+  g_list_free (targets);
+}
+
+/**
+ * g_resolver_error_quark:
+ * 
+ * Gets the #GResolver Error Quark.
+ *
+ * Return value: a #GQuark.
+ *
+ * Since: 2.20
+ **/
+GQuark
+g_resolver_error_quark (void)
+{
+  return g_quark_from_static_string ("g-resolver-error-quark");
+}
+
+
+static GResolverError
+g_resolver_error_from_addrinfo_error (gint err)
+{
+  switch (err)
+    {
+    case EAI_FAIL:
+    case EAI_NODATA:
+    case EAI_NONAME:
+      return G_RESOLVER_ERROR_NOT_FOUND;
+
+    case EAI_AGAIN:
+      return G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+
+    default:
+      return G_RESOLVER_ERROR_INTERNAL;
+    }
+}
+
+struct addrinfo _g_resolver_addrinfo_hints;
+
+/* Private method to process a getaddrinfo() response. */
+GList *
+_g_resolver_addresses_from_addrinfo (const char       *hostname,
+                                     struct addrinfo  *res,
+                                     gint              gai_retval,
+                                     GError          **error)
+{
+  struct addrinfo *ai;
+  GSocketAddress *sockaddr;
+  GInetAddress *addr;
+  GList *addrs;
+
+  if (gai_retval != 0)
+    {
+      g_set_error (error, G_RESOLVER_ERROR,
+		   g_resolver_error_from_addrinfo_error (gai_retval),
+		   _("Error resolving '%s': %s"),
+		   hostname, gai_strerror (gai_retval));
+      return NULL;
+    }
+
+  g_return_val_if_fail (res != NULL, NULL);
+
+  addrs = NULL;
+  for (ai = res; ai; ai = ai->ai_next)
+    {
+      sockaddr = g_socket_address_new_from_native (ai->ai_addr, ai->ai_addrlen);
+      if (!sockaddr || !G_IS_INET_SOCKET_ADDRESS (sockaddr))
+        continue;
+
+      addr = g_object_ref (g_inet_socket_address_get_address ((GInetSocketAddress *)sockaddr));
+      addrs = g_list_prepend (addrs, addr);
+      g_object_unref (sockaddr);
+    }
+
+  return g_list_reverse (addrs);
+}
+
+/* Private method to set up a getnameinfo() request */
+void
+_g_resolver_address_to_sockaddr (GInetAddress            *address,
+                                 struct sockaddr_storage *sa,
+                                 gsize                   *sa_len)
+{
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_inet_socket_address_new (address, 0);
+  g_socket_address_to_native (sockaddr, (struct sockaddr *)sa, sizeof (*sa));
+  *sa_len = g_socket_address_get_native_size (sockaddr);
+  g_object_unref (sockaddr);
+}
+
+/* Private method to process a getnameinfo() response. */
+char *
+_g_resolver_name_from_nameinfo (GInetAddress  *address,
+                                const gchar   *name,
+                                gint           gni_retval,
+                                GError       **error)
+{
+  if (gni_retval != 0)
+    {
+      gchar *phys;
+
+      phys = g_inet_address_to_string (address);
+      g_set_error (error, G_RESOLVER_ERROR,
+                   g_resolver_error_from_addrinfo_error (gni_retval),
+                   _("Error reverse-resolving '%s': %s"),
+                   phys ? phys : "(unknown)", gai_strerror (gni_retval));
+      g_free (phys);
+      return NULL;
+    }
+
+  return g_strdup (name);
+}
+
+#if defined(G_OS_UNIX)
+/* Private method to process a res_query response into GSrvTargets */
+GList *
+_g_resolver_targets_from_res_query (const gchar      *rrname,
+                                    guchar           *answer,
+                                    gint              len,
+                                    gint              herr,
+                                    GError          **error)
+{
+  gint count;
+  gchar namebuf[1024];
+  guchar *end, *p;
+  guint16 type, qclass, rdlength, priority, weight, port;
+  guint32 ttl;
+  HEADER *header;
+  time_t now = time (NULL);
+  GSrvTarget *target;
+  GList *targets;
+
+  if (len < 0)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (herr == HOST_NOT_FOUND || herr == NO_DATA)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (herr == TRY_AGAIN)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+
+  header = (HEADER *)answer;
+  p = answer + sizeof (HEADER);
+  end = answer + len;
+
+  /* Skip query */
+  count = ntohs (header->qdcount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      p += 4;
+    }
+
+  /* Read answers */
+  count = ntohs (header->ancount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      GETSHORT (type, p);
+      GETSHORT (qclass, p);
+      GETLONG  (ttl, p);
+      GETSHORT (rdlength, p);
+
+      if (type != T_SRV || qclass != C_IN)
+        {
+          p += rdlength;
+          continue;
+        }
+
+      GETSHORT (priority, p);
+      GETSHORT (weight, p);
+      GETSHORT (port, p);
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+
+      target = g_srv_target_new (namebuf, port, priority, weight, now + ttl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+#elif defined(G_OS_WIN32)
+/* Private method to process a DnsQuery response into GSrvTargets */
+GList *
+_g_resolver_targets_from_DnsQuery (const gchar  *rrname,
+                                   DNS_STATUS    status,
+                                   DNS_RECORD   *results,
+                                   GError      **error)
+{
+  DNS_RECORD *rec;
+  GSrvTarget *target;
+  GList *targets;
+  time_t now = time (NULL);
+
+  if (status != ERROR_SUCCESS)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (status == DNS_ERROR_RCODE_NAME_ERROR)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (status == DNS_ERROR_RCODE_SERVER_FAILURE)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+  for (rec = results; rec; rec = rec->pNext)
+    {
+      if (rec->wType != DNS_TYPE_SRV)
+        continue;
+
+      target = g_srv_target_new (rec->Data.SRV.pNameTarget,
+                                 rec->Data.SRV.wPort,
+                                 rec->Data.SRV.wPriority,
+                                 rec->Data.SRV.wWeight,
+                                 now + rec->dwTtl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+
+#endif
+
+#define __G_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gresolver.h b/gio/gresolver.h
new file mode 100644
index 0000000..788851e
--- /dev/null
+++ b/gio/gresolver.h
@@ -0,0 +1,159 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_RESOLVER_H__
+#define __G_RESOLVER_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_RESOLVER         (g_resolver_get_type ())
+#define G_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
+#define G_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
+#define G_IS_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
+#define G_IS_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
+#define G_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))
+
+struct _GResolver {
+  GObject parent_instance;
+
+};
+
+typedef struct {
+  GObjectClass parent_class;
+
+  GList * ( *lookup_by_name)           (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_name_async)     (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_by_name_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  gchar * ( *lookup_by_address)        (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_address_async)  (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  gchar * ( *lookup_by_address_finish) (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  GList * ( *lookup_service)           (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_service_async)     (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_service_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  /* Padding for future expansion */
+  void (*_g_reserved1) (void);
+  void (*_g_reserved2) (void);
+  void (*_g_reserved3) (void);
+  void (*_g_reserved4) (void);
+  void (*_g_reserved5) (void);
+  void (*_g_reserved6) (void);
+
+} GResolverClass;
+
+GType      g_resolver_get_type                  (void) G_GNUC_CONST;
+GResolver *g_resolver_get_default               (void);
+void       g_resolver_set_default               (GResolver            *resolver);
+
+GList     *g_resolver_lookup_by_name            (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_name_async      (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_by_name_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_addresses            (GList                *addresses);
+
+gchar     *g_resolver_lookup_by_address         (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_address_async   (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+gchar     *g_resolver_lookup_by_address_finish  (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+GList     *g_resolver_lookup_service            (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_service_async      (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_service_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_targets              (GList                *targets);
+
+/**
+ * G_RESOLVER_ERROR:
+ *
+ * Error domain for #GResolver. Errors in this domain will be from the
+ * #GResolverError enumeration. See #GError for more information on
+ * error domains.
+ **/
+#define G_RESOLVER_ERROR (g_resolver_error_quark ())
+GQuark g_resolver_error_quark (void);
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gsocketaddress.c b/gio/gsocketaddress.c
new file mode 100644
index 0000000..a7e7cfb
--- /dev/null
+++ b/gio/gsocketaddress.c
@@ -0,0 +1,268 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "gsocketaddress.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gnetworkingprivate.h"
+#include "gsocketconnectable.h"
+#include "glibintl.h"
+#include "gioenumtypes.h"
+
+#ifdef G_OS_UNIX
+#include "gunixsocketaddress.h"
+#endif
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketaddress
+ * @short_description: Abstract base class representing endpoints for
+ * socket communication
+ *
+ * #GSocketAddress is the equivalent of <type>struct sockaddr</type>
+ * in the BSD sockets API. This is an abstract class; use
+ * #GInetSocketAddress for internet sockets, or #GUnixSocketAddress
+ * for UNIX domain sockets.
+ **/
+
+/**
+ * GSocketAddress:
+ *
+ * A socket endpoint address, corresponding to <type>struct sockaddr</type>
+ * or one of its subtypes.
+ **/
+
+enum
+{
+  PROP_NONE,
+  PROP_FAMILY
+};
+
+static void            g_socket_address_connectable_iface_init (GSocketConnectableIface *iface);
+static GSocketAddress *g_socket_address_connectable_get_next   (GSocketConnectable  *connectable,
+								GCancellable        *cancellable,
+								GError             **error);
+static void            g_socket_address_connectable_reset      (GSocketConnectable  *connectable);
+
+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (GSocketAddress, g_socket_address, G_TYPE_OBJECT,
+				  G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+							 g_socket_address_connectable_iface_init))
+
+/**
+ * g_socket_address_get_family:
+ * @address: a #GSocketAddress
+ *
+ * Gets the socket family type of @address.
+ *
+ * Returns: the socket family type of @address.
+ */
+GSocketFamily
+g_socket_address_get_family (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), 0);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_family (address);
+}
+
+static void
+g_socket_address_get_property (GObject *object, guint prop_id,
+			       GValue *value, GParamSpec *pspec)
+{
+  GSocketAddress *address = G_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+     case PROP_FAMILY:
+      g_value_set_enum (value, g_socket_address_get_family (address));
+      break;
+
+     default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_socket_address_class_init (GSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->get_property = g_socket_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The family of the socket address"),
+						      G_TYPE_SOCKET_FAMILY,
+						      G_SOCKET_FAMILY_INVALID,
+						      G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_socket_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next = g_socket_address_connectable_get_next;
+  connectable_iface->reset    = g_socket_address_connectable_reset;
+}
+
+static void
+g_socket_address_init (GSocketAddress *address)
+{
+
+}
+
+/**
+ * g_socket_address_get_native_size:
+ * @address: a #GSocketAddress
+ *
+ * Gets the size of @address's native <type>struct sockaddr</type>.
+ * You can use this to allocate memory to pass to
+ * g_socket_address_to_native().
+ *
+ * Returns: the size of the native <type>struct sockaddr</type> that
+ * @address represents
+ */
+gssize
+g_socket_address_get_native_size (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), -1);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_native_size (address);
+}
+
+/**
+ * g_socket_address_to_native:
+ * @address: a #GSocketAddress
+ * @dest: a pointer to a memory location that will contain the native
+ * <type>struct sockaddr</type>.
+ * @destlen: the size of @dest. Must be at least as large as
+ * g_socket_address_get_native_size().
+ *
+ * Converts a #GSocketAddress to a native <type>struct
+ * sockaddr</type>, which can be passed to low-level functions like
+ * connect() or bind().
+ *
+ * Returns: %TRUE if @dest was filled in, %FALSE if @address is invalid
+ * or @destlen is too small.
+ */
+gboolean
+g_socket_address_to_native (GSocketAddress *address,
+			    gpointer        dest,
+			    gsize           destlen)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->to_native (address, dest, destlen);
+}
+
+/**
+ * g_socket_address_new_from_native:
+ * @native: a pointer to a <type>struct sockaddr</type>
+ * @len: the size of the memory location pointed to by @native
+ *
+ * Creates a #GSocketAddress subclass corresponding to the native
+ * <type>struct sockaddr</type> @native.
+ *
+ * Returns: a new #GSocketAddress if @native could successfully be converted,
+ * otherwise %NULL.
+ */
+GSocketAddress *
+g_socket_address_new_from_native (gpointer native,
+				  gsize    len)
+{
+  gshort family;
+
+  if (len < sizeof (gshort))
+    return NULL;
+
+  family = ((struct sockaddr *) native)->sa_family;
+
+  if (family == AF_UNSPEC)
+    return NULL;
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *addr = (struct sockaddr_in *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin_addr), AF_INET);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+  if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *addr = (struct sockaddr_in6 *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin6_addr), AF_INET6);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin6_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+#ifdef G_OS_UNIX
+  if (family == AF_UNIX)
+    {
+      struct sockaddr_un *addr = (struct sockaddr_un *) native;
+
+      return g_unix_socket_address_new (addr->sun_path);
+    }
+#endif
+
+  return NULL;
+}
+
+static GSocketAddress *
+g_socket_address_connectable_get_next (GSocketConnectable  *connectable,
+				       GCancellable        *cancellable,
+				       GError             **error)
+{
+  /* Rather than creating a GSocketAddressPrivate for just 1 bit of
+   * data, we cheat and use GObject data.
+   */
+  if (g_object_get_data (G_OBJECT (connectable), "GSocketConnectable-iterated"))
+    return NULL;
+  else
+    {
+      g_object_set_data (G_OBJECT (connectable),
+			 "GSocketConnectable-iterated",
+			 GINT_TO_POINTER (TRUE));
+      return g_object_ref (connectable);
+    }
+}
+
+static void
+g_socket_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  g_object_set_data (G_OBJECT (connectable),
+		     "GSocketConnectable-iterated",
+		     NULL);
+}
+
+#define __G_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketaddress.h b/gio/gsocketaddress.h
new file mode 100644
index 0000000..1649ba6
--- /dev/null
+++ b/gio/gsocketaddress.h
@@ -0,0 +1,77 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_ADDRESS_H__
+#define __G_SOCKET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_ADDRESS         (g_socket_address_get_type ())
+#define G_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
+#define G_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+#define G_IS_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
+#define G_IS_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
+#define G_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+
+typedef struct _GSocketAddressClass   GSocketAddressClass;
+
+struct _GSocketAddress
+{
+  GObject parent_instance;
+};
+
+struct _GSocketAddressClass
+{
+  GObjectClass parent_class;
+
+  GSocketFamily  (*get_family)      (GSocketAddress *address);
+
+  gssize         (*get_native_size) (GSocketAddress *address);
+
+  gboolean       (*to_native)       (GSocketAddress *address,
+                                     gpointer        dest,
+                                     gsize           destlen);
+};
+
+GType                 g_socket_address_get_type        (void) G_GNUC_CONST;
+
+GSocketFamily         g_socket_address_get_family      (GSocketAddress *address);
+
+GSocketAddress *      g_socket_address_new_from_native (gpointer        native,
+                                                        gsize           len);
+
+gboolean              g_socket_address_to_native       (GSocketAddress *address,
+                                                        gpointer        dest,
+                                                        gsize           destlen);
+
+gssize                g_socket_address_get_native_size (GSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_SOCKET_ADDRESS_H__ */
diff --git a/gio/gsocketconnectable.c b/gio/gsocketconnectable.c
new file mode 100644
index 0000000..c72dd7c
--- /dev/null
+++ b/gio/gsocketconnectable.c
@@ -0,0 +1,269 @@
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include "gsocketconnectable.h"
+#include "gsimpleasyncresult.h"
+#include "glibintl.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketconnectable
+ * @short_description: Interface for potential socket endpoints.
+ *
+ * Objects that describe one or more potential socket endpoints
+ * implement #GSocketConnectable. The caller can then use
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() to try out each
+ * #GSocketAddress in turn until it suceeds in connecting to one of
+ * them.
+ **/
+
+static void g_socket_connectable_base_init  (gpointer g_class);
+static void g_socket_connectable_class_init (gpointer g_class,
+					     gpointer class_data);
+
+static void            g_socket_connectable_real_get_next_async  (GSocketConnectable   *connectable,
+								  GCancellable         *cancellable,
+								  GAsyncReadyCallback   callback,
+								  gpointer              user_data);
+static GSocketAddress *g_socket_connectable_real_get_next_finish (GSocketConnectable   *connectable,
+								  GAsyncResult         *result,
+								  GError              **error);
+
+GType
+g_socket_connectable_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      const GTypeInfo connectable_info =
+      {
+        sizeof (GSocketConnectableIface), /* class_size */
+	g_socket_connectable_base_init,		/* base_init */
+	NULL,		/* base_finalize */
+	g_socket_connectable_class_init,
+	NULL,		/* class_finalize */
+	NULL,		/* class_data */
+	0,
+	0,              /* n_preallocs */
+	NULL
+      };
+      GType g_define_type_id =
+	g_type_register_static (G_TYPE_INTERFACE, I_("GSocketConnectable"),
+				&connectable_info, 0);
+
+      g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_OBJECT);
+
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
+
+static void
+g_socket_connectable_class_init (gpointer g_class,
+				 gpointer class_data)
+{
+  GSocketConnectableIface *iface = g_class;
+
+  iface->get_next_async = g_socket_connectable_real_get_next_async;
+  iface->get_next_finish = g_socket_connectable_real_get_next_finish;
+}
+
+static void
+g_socket_connectable_base_init (gpointer g_class)
+{
+}
+
+/**
+ * g_socket_connectable_get_next:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @error: a #GError.
+ *
+ * Retrieves the next #GSocketAddress from @connectable. Note that
+ * this may block for some amount of time. (Eg, @connectable may need
+ * to do a DNS lookup before it can return an address.) Use
+ * g_socket_connectable_get_next_async() if you need to avoid
+ * blocking.
+ *
+ * If @connectable is unable to yield any addresses (eg, because of a
+ * DNS error), then the first call to g_socket_connectable_get_next()
+ * will return an appropriate error in *@error. However, if the first
+ * call to g_socket_connectable_get_next() succeeds, then any further
+ * internal errors (other than @cancellable being triggered) will be
+ * ignored.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next (GSocketConnectable  *connectable,
+			       GCancellable        *cancellable,
+			       GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next) (connectable, cancellable, error);
+}
+
+/* Default implementation of get_next_async just calls the synchronous
+ * method; this can be used if the implementation already knows all of
+ * its addresses, and so the synchronous method will never block.
+ */
+static void
+g_socket_connectable_real_get_next_async (GSocketConnectable  *connectable,
+					  GCancellable        *cancellable,
+					  GAsyncReadyCallback  callback,
+					  gpointer             user_data)
+{
+  GSimpleAsyncResult *result;
+  GSocketAddress *address;
+  GError *error = NULL;
+
+  result = g_simple_async_result_new (G_OBJECT (connectable),
+				      callback, user_data,
+				      g_socket_connectable_real_get_next_async);
+  address = g_socket_connectable_get_next (connectable, cancellable, &error);
+  if (address)
+    g_simple_async_result_set_op_res_gpointer (result, address, g_object_unref);
+  else if (error)
+    {
+      g_simple_async_result_set_from_error (result, error);
+      g_error_free (error);
+    }
+  g_simple_async_result_complete_in_idle (result);
+  g_object_unref (result);
+}
+
+/**
+ * g_socket_connectable_get_next_async:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @callback: a #GAsyncReadyCallback to call when the request is satisfied
+ * @user_data: the data to pass to callback function
+ *
+ * Asynchronously retrieves the next #GSocketAddress from @connectable
+ * and then calls @callback, which must call
+ * g_socket_connectable_get_next_finish() to get the result.
+ **/
+void
+g_socket_connectable_get_next_async (GSocketConnectable  *connectable,
+				     GCancellable        *cancellable,
+				     GAsyncReadyCallback  callback,
+				     gpointer             user_data)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  (* iface->get_next_async) (connectable, cancellable, callback, user_data);
+}
+
+static GSocketAddress *
+g_socket_connectable_real_get_next_finish (GSocketConnectable  *connectable,
+					   GAsyncResult        *result,
+					   GError             **error)
+{
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (connectable), g_socket_connectable_real_get_next_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+/**
+ * g_socket_connectable_get_next_finish:
+ * @connectable: a #GSocketConnectable
+ * @result: a #GAsyncResult.
+ * @error: a #GError.
+ *
+ * Retrieves the result of a completed call to
+ * g_socket_connectable_get_next_async(). See
+ * g_socket_connectable_get_next() for more information about
+ * error handling.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next_finish (GSocketConnectable  *connectable,
+				      GAsyncResult        *result,
+				      GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+	return NULL;
+    }
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next_finish) (connectable, result, error);
+}
+
+/**
+ * g_socket_connectable_reset:
+ * @connectable: a #GSocketConnectable
+ *
+ * Resets @connectable's iterator state, so that the next call to
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() will return the first
+ * available #GSocketAddress again.
+ *
+ * You can only call this after successfully enumerating all
+ * addresses. Resetting a connectable at any other time may not
+ * necessarily work correctly.
+ **/
+void
+g_socket_connectable_reset (GSocketConnectable *connectable)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  if (iface->reset)
+    (* iface->reset) (connectable);
+}
+
+#define __G_SOCKET_CONNECTABLE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketconnectable.h b/gio/gsocketconnectable.h
new file mode 100644
index 0000000..115d6e3
--- /dev/null
+++ b/gio/gsocketconnectable.h
@@ -0,0 +1,94 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_CONNECTABLE_H__
+#define __G_SOCKET_CONNECTABLE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_CONNECTABLE            (g_socket_connectable_get_type ())
+#define G_SOCKET_CONNECTABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
+#define G_IS_SOCKET_CONNECTABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
+#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))
+
+/**
+ * GSocketConnectable:
+ *
+ * Interface for objects that enumerate #GSocketAddress<!-- -->es.
+ **/
+typedef struct _GSocketConnectableIface GSocketConnectableIface;
+
+/**
+ * GSocketConnectableIface:
+ * @g_iface: The parent interface.
+ * @get_next: Synchronously gets the next #GSocketAddress
+ * @get_next_async: Begins asynchronously getting the next #GSocketAddress
+ * @get_next_finish: Finishes asynchronously getting a #GSocketAddress
+ * @reset: Resets the enumerator
+ *
+ * Provides an interface for enumerating #GSocketAddress<!-- -->es.
+ **/
+struct _GSocketConnectableIface
+{
+  GTypeInterface g_iface;
+
+  /* Virtual Table */
+
+  GSocketAddress * (* get_next)        (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GError              **error);
+
+  void             (* get_next_async)  (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GAsyncReadyCallback   callback,
+		  			gpointer              user_data);
+  GSocketAddress * (* get_next_finish) (GSocketConnectable   *connectable,
+					GAsyncResult         *result,
+					GError              **error);
+
+  void             (* reset)           (GSocketConnectable   *connectable);
+};
+
+GType           g_socket_connectable_get_type        (void) G_GNUC_CONST;
+
+GSocketAddress *g_socket_connectable_get_next        (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GError              **error);
+
+void            g_socket_connectable_get_next_async  (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GAsyncReadyCallback   callback,
+						      gpointer              user_data);
+GSocketAddress *g_socket_connectable_get_next_finish (GSocketConnectable   *connectable,
+						      GAsyncResult         *result,
+						      GError              **error);
+
+void            g_socket_connectable_reset           (GSocketConnectable   *connectable);
+
+G_END_DECLS
+
+
+#endif /* __G_SOCKET_CONNECTABLE_H__ */
diff --git a/gio/gsrvtarget.c b/gio/gsrvtarget.c
new file mode 100644
index 0000000..6e2cb55
--- /dev/null
+++ b/gio/gsrvtarget.c
@@ -0,0 +1,353 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsrvtarget
+ * @short_description: DNS SRV record target
+ * @include: gio/gio.h
+ *
+ * SRV (service) records are used by some network protocols to provide
+ * service-specific aliasing and load-balancing. For example, XMPP
+ * (Jabber) uses SRV records to locate the XMPP server for a domain;
+ * rather than connecting directly to "example.com" or assuming a
+ * specific server hostname like "xmpp.example.com", an XMPP client
+ * would look up the "xmpp-client" SRV record for "example.com", and
+ * then connect to whatever host was pointed to by that record.
+ *
+ * Use g_resolver_lookup_service() or
+ * g_resolver_lookup_service_async() to find the #GSrvTarget<!-- -->s
+ * for a given service.
+ **/
+
+struct _GSrvTarget {
+  gchar   *hostname;
+  guint16  port;
+
+  guint16  priority;
+  guint16  weight;
+  time_t   expires;
+};
+
+/**
+ * GSrvTarget:
+ *
+ * A single target host/port that a network service is running on.
+ */
+
+GType
+g_srv_target_get_type (void)
+{
+  static volatile gsize type_volatile = 0;
+
+  if (g_once_init_enter (&type_volatile))
+    {
+      GType type = g_boxed_type_register_static (
+                        g_intern_static_string ("GSrvTarget"),
+			(GBoxedCopyFunc) g_srv_target_copy,
+			(GBoxedFreeFunc) g_srv_target_free);
+      g_once_init_leave (&type_volatile, type);
+    }
+  return type_volatile;
+}
+
+/**
+ * g_srv_target_new:
+ * @hostname: the host that the service is running on
+ * @port: the port that the service is running on
+ * @priority: the target's priority
+ * @weight: the target's weight
+ * @expires: the target's expiration time
+ *
+ * Creates a new #GSrvTarget with the given parameters.
+ *
+ * You should not need to use this; normally #GSrvTarget<!-- -->s are
+ * created by #GResolver.
+ *
+ * Return value: a new #GSrvTarget.
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_new (const gchar *hostname,
+                  guint16      port,
+                  guint16      priority,
+                  guint16      weight,
+                  time_t       expires)
+{
+  GSrvTarget *target = g_slice_new0 (GSrvTarget);
+
+  target->hostname = g_strdup (hostname);
+  target->port = port;
+  target->priority = priority;
+  target->weight = weight;
+  target->expires = expires;
+
+  return target;
+}
+
+/**
+ * g_srv_target_copy:
+ * @target: a #GSrvTarget
+ *
+ * Copies @target
+ *
+ * Return value: a copy of @target
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_copy (GSrvTarget *target)
+{
+  return g_srv_target_new (target->hostname, target->port,
+                           target->priority, target->weight,
+                           target->expires);
+}
+
+/**
+ * g_srv_target_free:
+ * @target: a #GSrvTarget
+ *
+ * Frees @target
+ *
+ * Since: 2.20
+ **/
+void
+g_srv_target_free (GSrvTarget *target)
+{
+  g_free (target->hostname);
+  g_slice_free (GSrvTarget, target);
+}
+
+/**
+ * g_srv_target_get_hostname:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's hostname (in ASCII form; if you are going to present
+ * this to the user, you should use g_hostname_is_ascii_encoded() to
+ * check if it contains encoded Unicode segments, and use
+ * g_hostname_to_unicode() to convert it if it does.)
+ *
+ * Return value: @target's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_srv_target_get_hostname (GSrvTarget *target)
+{
+  return target->hostname;
+}
+
+/**
+ * g_srv_target_get_port:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's port
+ *
+ * Return value: @target's port
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_port (GSrvTarget *target)
+{
+  return target->port;
+}
+
+/**
+ * g_srv_target_get_priority:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's priority. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's priority
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_priority (GSrvTarget *target)
+{
+  return target->priority;
+}
+
+/**
+ * g_srv_target_get_weight:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's weight. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's weight
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_weight (GSrvTarget *target)
+{
+  return target->weight;
+}
+
+/**
+ * g_srv_target_get_expires:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's expiration time.
+ *
+ * Return value: @target's expiration time
+ *
+ * Since: 2.20
+ **/
+time_t
+g_srv_target_get_expires (GSrvTarget *target)
+{
+  return target->expires;
+}
+
+gint
+compare_target (gconstpointer a, gconstpointer b)
+{
+  GSrvTarget *ta = (GSrvTarget *)a;
+  GSrvTarget *tb = (GSrvTarget *)b;
+
+  if (ta->priority == tb->priority)
+    {
+      /* Arrange targets of the same priority "in any order, except
+       * that all those with weight 0 are placed at the beginning of
+       * the list"
+       */
+      if (ta->weight == 0)
+        return -1;
+      else if (tb->weight == 0)
+        return 1;
+      else
+        return g_random_int_range (-1, 1);
+    }
+  else
+    return ta->priority - tb->priority;
+}
+
+/**
+ * g_srv_target_list_sort:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Sorts @targets in place according to the algorithm in RFC 2782.
+ *
+ * Return value: the head of the sorted list.
+ **/ 
+GList *
+g_srv_target_list_sort (GList *targets)
+{
+  gint sum, val, priority, weight;
+  GList *first, *last, *n;
+  GSrvTarget *target;
+  gpointer tmp;
+
+  if (!targets)
+    return NULL;
+
+  if (!targets->next)
+    {
+      target = targets->data;
+      if (!strcmp (target->hostname, "."))
+        {
+          /* 'A Target of "." means that the service is decidedly not
+           * available at this domain.'
+           */
+          g_srv_target_free (target);
+          g_list_free (targets);
+          return NULL;
+        }
+    }
+
+  /* Sort by priority, and partly by weight */
+  targets = g_list_sort (targets, compare_target);
+
+  /* For each group of targets with the same priority, rebalance them
+   * according to weight.
+   */
+  for (first = targets; first; first = last->next)
+    {
+      /* Skip @first to a non-0-weight target. */
+      while (first && ((GSrvTarget *)first->data)->weight == 0)
+        first = first->next;
+      if (!first)
+        break;
+
+      /* Skip @last to the last target of the same priority. */
+      priority = ((GSrvTarget *)first->data)->priority;
+      last = first;
+      while (last->next &&
+             ((GSrvTarget *)last->next->data)->priority == priority)
+        last = last->next;
+
+      /* If there's only one non-0 weight target at this priority,
+       * we can move on to the next priority level.
+       */
+      if (last == first)
+        continue;
+
+      /* Randomly reorder the non-0 weight targets, giving precedence
+       * to the ones with higher weight. RFC 2782 describes this in
+       * terms of assigning a running sum to each target and building
+       * a new list. We do things slightly differently, but should get
+       * the same result.
+       */
+      for (n = first, sum = 0; n != last->next; n = n->next)
+        sum += ((GSrvTarget *)n->data)->weight;
+      while (first != last)
+        {
+          val = g_random_int_range (0, sum);
+          for (n = first; n != last; n = n->next)
+            {
+              weight = ((GSrvTarget *)n->data)->weight;
+              if (val < weight)
+                break;
+              val -= weight;
+            }
+
+          tmp = first->data;
+          first->data = n->data;
+          n->data = tmp;
+
+          sum -= weight;
+          first = first->next;
+        }
+    }
+
+  return targets;
+}
+
+#define __G_SRV_TARGET_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsrvtarget.h b/gio/gsrvtarget.h
new file mode 100644
index 0000000..995b09a
--- /dev/null
+++ b/gio/gsrvtarget.h
@@ -0,0 +1,54 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SRV_TARGET_H__
+#define __G_SRV_TARGET_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+GType g_srv_target_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SRV_TARGET (g_srv_target_get_type ())
+
+GSrvTarget  *g_srv_target_new          (const gchar *hostname,
+				        guint16      port,
+				        guint16      priority,
+				        guint16      weight,
+				        time_t       expires);
+GSrvTarget  *g_srv_target_copy         (GSrvTarget  *target);
+void         g_srv_target_free         (GSrvTarget  *target);
+
+const gchar *g_srv_target_get_hostname (GSrvTarget  *target);
+guint16      g_srv_target_get_port     (GSrvTarget  *target);
+guint16      g_srv_target_get_priority (GSrvTarget  *target);
+guint16      g_srv_target_get_weight   (GSrvTarget  *target);
+time_t       g_srv_target_get_expires  (GSrvTarget  *target);
+
+GList       *g_srv_target_list_sort    (GList       *targets);
+
+G_END_DECLS
+
+#endif /* __G_SRV_TARGET_H__ */
+
diff --git a/gio/gthreadedresolver.c b/gio/gthreadedresolver.c
new file mode 100644
index 0000000..0440a3d
--- /dev/null
+++ b/gio/gthreadedresolver.c
@@ -0,0 +1,617 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gthreadedresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GThreadedResolver, g_threaded_resolver, G_TYPE_RESOLVER)
+
+static void threaded_resolver_thread (gpointer thread_data, gpointer pool_data);
+
+static void
+g_threaded_resolver_init (GThreadedResolver *gtr)
+{
+  if (g_thread_supported ())
+    {
+      gtr->thread_pool = g_thread_pool_new (threaded_resolver_thread, gtr,
+					    -1, FALSE, NULL);
+    }
+}
+
+static void
+finalize (GObject *object)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (object);
+
+  g_thread_pool_free (gtr->thread_pool, FALSE, FALSE);
+
+  G_OBJECT_CLASS (g_threaded_resolver_parent_class)->finalize (object);
+}
+
+/* A GThreadedResolverRequest represents a request in progress
+ * (usually, but see case 1). It is refcounted, to make sure that it
+ * doesn't get freed too soon. In particular, it can't be freed until
+ * (a) the resolver thread has finished resolving, (b) the calling
+ * thread has received an answer, and (c) no other thread could be in
+ * the process of trying to cancel it.
+ *
+ * The possibilities:
+ *
+ * 1. Synchronous non-cancellable request: in this case, the request
+ *    is simply done in the calling thread, without using
+ *    GThreadedResolverRequest at all.
+ *
+ * 2. Synchronous cancellable request: A req is created with a GCond,
+ *    and 3 refs (for the resolution thread, the calling thread, and
+ *    the cancellation signal handler).
+ *
+ *      a. If the resolution completes successfully, the thread pool
+ *         function (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (dropping one ref on req)
+ *         and signal the GCond, and then unref the req. The calling
+ *         thread receives the signal from the GCond, processes the
+ *         response, and unrefs the req, causing it to be freed.
+ *
+ *      b. If the resolution is cancelled before completing,
+ *         request_cancelled() will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the signal handler (as above, unreffing the req), set
+ *         req->error to indicate that it was cancelled, and signal
+ *         the GCond. The calling thread receives the signal from the
+ *         GCond, processes the response, and unrefs the req.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * 3. Asynchronous request: A req is created with a GSimpleAsyncResult
+ *    (and no GCond). The calling thread's ref on req is set up to be
+ *    automatically dropped when the async_result is freed. Two
+ *    sub-possibilities:
+ *
+ *      a. If the resolution completes, the thread pool function
+ *         (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (if it was present)
+ *         (unreffing the req), queue the async_result to complete in
+ *         an idle handler, unref the async_result (which is still
+ *         reffed by the idle handler though), and then unref the req.
+ *         The main thread then invokes the async_result's callback
+ *         and processes the response. When it finishes, the
+ *         async_result drops the ref that was taken by
+ *         g_simple_async_result_complete_in_idle(), which causes the
+ *         async_result to be freed, which causes req to be unreffed
+ *         and freed.
+ *
+ *      b. If the resolution is cancelled, request_cancelled() will
+ *         call g_threaded_resolver_request_complete(), which will
+ *         detach the signal handler (as above, unreffing the req) set
+ *         req->error to indicate that it was cancelled, and queue and
+ *         unref the async_result. The main thread completes the
+ *         async_request and unrefs it and the req, as above.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * g_threaded_resolver_request_complete() ensures that if the request
+ * completes and cancels "at the same time" that only one of the two
+ * conditions gets processed.
+ */
+
+typedef struct _GThreadedResolverRequest GThreadedResolverRequest;
+typedef void (*GThreadedResolverResolveFunc) (GThreadedResolverRequest *, GError **);
+typedef void (*GThreadedResolverFreeFunc) (GThreadedResolverRequest *);
+
+struct _GThreadedResolverRequest {
+  GThreadedResolverResolveFunc resolve_func;
+  GThreadedResolverFreeFunc free_func;
+
+  union {
+    struct {
+      gchar *hostname;
+      GList *addresses;
+    } name;
+    struct {
+      GInetAddress *address;
+      gchar *name;
+    } address;
+    struct {
+      gchar *rrname;
+      GList *targets;
+    } service;
+  } u;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  GMutex *mutex;
+  guint ref_count;
+
+  GCond *cond;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+
+};
+
+static void g_threaded_resolver_request_unref (GThreadedResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable, gpointer req);
+static void request_cancelled_disconnect_notify (gpointer req, GClosure *closure);
+
+static GThreadedResolverRequest *
+g_threaded_resolver_request_new (GThreadedResolverResolveFunc  resolve_func,
+                                 GThreadedResolverFreeFunc     free_func,
+				 GCancellable                 *cancellable)
+{
+  GThreadedResolverRequest *req;
+
+  req = g_slice_new0 (GThreadedResolverRequest);
+  req->resolve_func = resolve_func;
+  req->free_func = free_func;
+
+  /* Initial refcount is 2; one for the caller and one for resolve_func */
+  req->ref_count = 2;
+
+  if (g_thread_supported ())
+    req->mutex = g_mutex_new ();
+  /* Initially locked; caller must unlock */
+  g_mutex_lock (req->mutex);
+
+  if (cancellable)
+    {
+      req->ref_count++;
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect_data (cancellable, "cancelled",
+			     G_CALLBACK (request_cancelled), req,
+			     request_cancelled_disconnect_notify, 0);
+    }
+
+  return req;
+}
+
+static void
+g_threaded_resolver_request_unref (GThreadedResolverRequest *req)
+{
+  guint ref_count;
+
+  g_mutex_lock (req->mutex);
+  ref_count = --req->ref_count;
+  g_mutex_unlock (req->mutex);
+  if (ref_count > 0)
+    return;
+
+  g_mutex_free (req->mutex);
+
+  if (req->cond)
+    g_cond_free (req->cond);
+
+  if (req->error)
+    g_error_free (req->error);
+
+  if (req->free_func)
+    req->free_func (req);
+
+  /* We don't have to free req->cancellable or req->async_result,
+   * since (if set), they must already have been freed by
+   * request_complete() in order to get here.
+   */
+
+  g_slice_free (GThreadedResolverRequest, req);
+}
+
+static void
+g_threaded_resolver_request_complete (GThreadedResolverRequest *req,
+				      gboolean                  cancelled)
+{
+  g_mutex_lock (req->mutex);
+  if (req->complete)
+    {
+      /* The req was cancelled, and now it has finished resolving as
+       * well. But we have nowhere to send the result, so just return.
+       */
+      g_mutex_unlock (req->mutex);
+      return;
+    }
+
+  req->complete = TRUE;
+  g_mutex_unlock (req->mutex);
+
+  if (req->cancellable)
+    {
+      /* Possibly propagate a cancellation error */
+      if (cancelled && !req->error)
+        g_cancellable_set_error_if_cancelled (req->cancellable, &req->error);
+
+      /* Drop the signal handler's ref on @req */
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (req->cond)
+    g_cond_signal (req->cond);
+  else if (req->async_result)
+    {
+      if (req->error)
+        g_simple_async_result_set_from_error (req->async_result, req->error);
+      g_simple_async_result_complete_in_idle (req->async_result);
+
+      /* Drop our ref on the async_result, which will eventually cause
+       * it to drop its ref on req.
+       */
+      g_object_unref (req->async_result);
+      req->async_result = NULL;
+    }
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GThreadedResolverRequest *req = user_data;
+
+  g_threaded_resolver_request_complete (req, TRUE);
+
+  /* We can't actually cancel the resolver thread; it will eventually
+   * complete on its own and call request_complete() again, which will
+   * do nothing the second time.
+   */
+}
+
+static void
+request_cancelled_disconnect_notify (gpointer  req,
+                                     GClosure *closure)
+{
+  g_threaded_resolver_request_unref (req);
+}
+
+static void
+threaded_resolver_thread (gpointer thread_data,
+                          gpointer pool_data)
+{
+  GThreadedResolverRequest *req = thread_data;
+
+  req->resolve_func (req, &req->error);
+  g_threaded_resolver_request_complete (req, FALSE);
+  g_threaded_resolver_request_unref (req);
+}  
+
+static void
+resolve_sync (GThreadedResolver         *gtr,
+              GThreadedResolverRequest  *req,
+              GError                   **error)
+{
+  if (!req->cancellable || !gtr->thread_pool)
+    {
+      req->resolve_func (req, error);
+      return;
+    }
+
+  req->cond = g_cond_new ();
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_cond_wait (req->cond, req->mutex);
+  g_mutex_unlock (req->mutex);
+
+  if (req->error)
+    {
+      g_propagate_error (error, req->error);
+      req->error = NULL;
+    }
+}
+
+static void
+resolve_async (GThreadedResolver        *gtr,
+               GThreadedResolverRequest *req,
+               GAsyncReadyCallback       callback,
+               gpointer                  user_data,
+               gpointer                  tag)
+{
+  req->async_result = g_simple_async_result_new (G_OBJECT (gtr),
+                                                 callback, user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_mutex_unlock (req->mutex);
+}
+
+static GThreadedResolverRequest *
+resolve_finish (GResolver     *resolver,
+                GAsyncResult  *result,
+		gpointer       tag,
+                GError       **error)
+{
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), tag), NULL);
+
+  return g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result));
+}
+
+static void
+do_lookup_by_name (GThreadedResolverRequest  *req,
+                   GError                   **error)
+{
+  struct addrinfo *res = NULL;
+  gint retval;
+
+  retval = getaddrinfo (req->u.name.hostname, NULL,
+                        &_g_resolver_addrinfo_hints, &res);
+  req->u.name.addresses =
+    _g_resolver_addresses_from_addrinfo (req->u.name.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+}
+
+static GList *
+lookup_by_name (GResolver     *resolver,
+                const gchar   *hostname,
+                GCancellable  *cancellable,
+                GError       **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, NULL, cancellable);
+  req->u.name.hostname = (gchar *)hostname;
+  resolve_sync (gtr, req, error);
+
+  addresses = req->u.name.addresses;
+  g_threaded_resolver_request_unref (req);
+  return addresses;
+}
+
+static void
+free_lookup_by_name (GThreadedResolverRequest *req)
+{
+  g_free (req->u.name.hostname);
+  if (req->u.name.addresses)
+    g_resolver_free_addresses (req->u.name.addresses);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, free_lookup_by_name,
+                                         cancellable);
+  req->u.name.hostname = g_strdup (hostname);
+  resolve_async (gtr, req, callback, user_data, lookup_by_name_async);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = resolve_finish (resolver, result, lookup_by_name_async, error);
+  addresses = req->u.name.addresses;
+  req->u.name.addresses = NULL;
+  return addresses;
+}
+
+
+static void
+do_lookup_by_address (GThreadedResolverRequest  *req,
+                      GError                   **error)
+{
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+  gchar name[NI_MAXHOST];
+  gint retval;
+
+  _g_resolver_address_to_sockaddr (req->u.address.address,
+                                   &sockaddr, &sockaddr_size);
+
+  retval = getnameinfo ((struct sockaddr *)&sockaddr, sockaddr_size,
+                        name, sizeof (name), NULL, 0, NI_NAMEREQD);
+  req->u.address.name = _g_resolver_name_from_nameinfo (req->u.address.address,
+                                                        name, retval, error);
+}
+
+static gchar *
+lookup_by_address (GResolver        *resolver,
+                   GInetAddress     *address,
+                   GCancellable     *cancellable,
+                   GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address, NULL, cancellable);
+  req->u.address.address = address;
+  resolve_sync (gtr, req, error);
+
+  name = req->u.address.name;
+  g_threaded_resolver_request_unref (req);
+  return name;
+}
+
+static void
+free_lookup_by_address (GThreadedResolverRequest *req)
+{
+  g_object_unref (req->u.address.address);
+  if (req->u.address.name)
+    g_free (req->u.address.name);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address,
+                                         free_lookup_by_address,
+                                         cancellable);
+  req->u.address.address = g_object_ref (address);
+  resolve_async (gtr, req, callback, user_data, lookup_by_address_async);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = resolve_finish (resolver, result, lookup_by_address_async, error);
+  name = req->u.address.name;
+  req->u.address.name = NULL;
+  return name;
+}
+
+
+static void
+do_lookup_service (GThreadedResolverRequest *req,
+                   GError   **error)
+{
+#if defined(G_OS_UNIX)
+  gint len, herr;
+  guchar answer[1024];
+#elif defined(G_OS_WIN32)
+  DNS_STATUS status;
+  DNS_RECORD *results;
+#endif
+
+#if defined(G_OS_UNIX)
+  len = res_query (req->u.service.rrname, C_IN, T_SRV, answer, sizeof (answer));
+  herr = h_errno;
+  req->u.service.targets = _g_resolver_targets_from_res_query (req->u.service.rrname, answer, len, herr, error);
+#elif defined(G_OS_WIN32)
+  status = DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV,
+                       DNS_QUERY_STANDARD, NULL, &results, NULL);
+  req->u.service.targets = _g_resolver_targets_from_DnsQuery (req->u.service.rrname, status, results, error);
+  DnsRecordListFree (results, DnsFreeRecordList);
+#endif
+}
+
+static GList *
+lookup_service (GResolver        *resolver,
+                const gchar      *rrname,
+		GCancellable     *cancellable,
+                GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = g_threaded_resolver_request_new (do_lookup_service, NULL, cancellable);
+  req->u.service.rrname = (char *)rrname;
+  resolve_sync (gtr, req, error);
+
+  targets = req->u.service.targets;
+  g_threaded_resolver_request_unref (req);
+  return targets;
+}
+
+static void
+free_lookup_service (GThreadedResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.targets)
+    g_resolver_free_targets (req->u.service.targets);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_service,
+                                         free_lookup_service,
+                                         cancellable);
+  req->u.service.rrname = g_strdup (rrname);
+  resolve_async (gtr, req, callback, user_data, lookup_service_async);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = resolve_finish (resolver, result, lookup_service_async, error);
+  targets = req->u.service.targets;
+  req->u.service.targets = NULL;
+  return targets;
+}
+
+
+static void
+g_threaded_resolver_class_init (GThreadedResolverClass *threaded_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (threaded_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (threaded_class);
+
+  resolver_class->lookup_by_name           = lookup_by_name;
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address        = lookup_by_address;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service           = lookup_service;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = finalize;
+}
+
+#define __G_THREADED_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gthreadedresolver.h b/gio/gthreadedresolver.h
new file mode 100644
index 0000000..79d3327
--- /dev/null
+++ b/gio/gthreadedresolver.h
@@ -0,0 +1,50 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_THREADED_RESOLVER_H__
+#define __G_THREADED_RESOLVER_H__
+
+#include <gio/gresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_THREADED_RESOLVER         (g_threaded_resolver_get_type ())
+#define G_THREADED_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolver))
+#define G_THREADED_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+#define G_IS_THREADED_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THREADED_RESOLVER))
+#define G_IS_THREADED_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THREADED_RESOLVER))
+#define G_THREADED_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+
+typedef struct {
+  GResolver parent_instance;
+
+  GThreadPool *thread_pool;
+} GThreadedResolver;
+
+typedef struct {
+  GResolverClass parent_class;
+
+} GThreadedResolverClass;
+
+GType g_threaded_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixresolver.c b/gio/gunixresolver.c
new file mode 100644
index 0000000..36bb046
--- /dev/null
+++ b/gio/gunixresolver.c
@@ -0,0 +1,433 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <resolv.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "gunixresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GUnixResolver, g_unix_resolver, G_TYPE_THREADED_RESOLVER)
+
+static gboolean g_unix_resolver_watch (GIOChannel   *iochannel,
+                                       GIOCondition  condition,
+                                       gpointer      user_data);
+
+static void
+g_unix_resolver_init (GUnixResolver *gur)
+{
+  gint fd;
+  GIOChannel *io;
+
+  /* FIXME: how many workers? */
+  gur->asyncns = _g_asyncns_new (2);
+
+  fd = _g_asyncns_fd (gur->asyncns);
+  io = g_io_channel_unix_new (fd);
+  gur->watch = g_io_add_watch (io, G_IO_IN | G_IO_HUP | G_IO_ERR,
+                               g_unix_resolver_watch, gur);
+  g_io_channel_unref (io);
+}
+
+static void
+g_unix_resolver_finalize (GObject *object)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (object);
+
+  if (gur->watch)
+    g_source_remove (gur->watch);
+  _g_asyncns_free (gur->asyncns);
+
+  G_OBJECT_CLASS (g_unix_resolver_parent_class)->finalize (object);
+}
+
+/* The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: An appropriate _g_asyncns_query_t is created, and
+ *    then a GUnixResolverRequest is created with that query and a
+ *    GSimpleAsyncResult. Two sub-possibilities:
+ *
+ *      a. The resolution completes: g_unix_resolver_watch() sees that
+ *         the request has completed, and calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         "cancelled" signal handler (if it was present) and then
+ *         immediately completes the async_result (since
+ *         g_unix_resolver_watch() is already run from main-loop
+ *         time.) After completing the async_result, it unrefs it,
+ *         causing the req to be freed as well.
+ *
+ *      b. The resolution is cancelled: request_cancelled() calls
+ *         _g_asyncns_cancel() to cancel the resolution. Then it calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         signal handler, and queues async_result to complete in an
+ *         idle handler. It then unrefs the async_result to ensure
+ *         that after its callback runs, it will be destroyed, in turn
+ *         causing the req to be freed. Because the asyncns resolution
+ *         was cancelled, g_unix_resolver_watch() will never be
+ *         triggered for this req.
+ *
+ *    Since there's only a single thread, it's not possible for the
+ *    request to both complete and be cancelled "at the same time",
+ *    and each of the two possibilities takes steps to block the other
+ *    from being able to happen later, so it's always safe to free req
+ *    after the async_result completes.
+ */
+
+typedef struct _GUnixResolverRequest GUnixResolverRequest;
+typedef void (*GUnixResolverFreeFunc) (GUnixResolverRequest *);
+
+struct _GUnixResolverRequest {
+  GUnixResolver *gur;
+
+  _g_asyncns_query_t *qy;
+  union {
+    gchar *hostname;
+    GInetAddress *address;
+    gchar *service;
+  } u;
+  GUnixResolverFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GSimpleAsyncResult *async_result;
+
+};
+
+static void g_unix_resolver_request_free (GUnixResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable,
+                               gpointer      user_data);
+
+static GUnixResolverRequest *
+g_unix_resolver_request_new (GUnixResolver         *gur,
+                             _g_asyncns_query_t    *qy,
+                             GUnixResolverFreeFunc  free_func,
+                             GCancellable          *cancellable,
+                             GSimpleAsyncResult    *async_result)
+{
+  GUnixResolverRequest *req;
+
+  req = g_slice_new0 (GUnixResolverRequest);
+  req->gur = g_object_ref (gur);
+  req->qy = qy;
+  req->free_func = free_func;
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  req->async_result = g_object_ref (async_result);
+
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, (GDestroyNotify)g_unix_resolver_request_free);
+
+  return req;
+}
+
+static void
+g_unix_resolver_request_free (GUnixResolverRequest *req)
+{
+  /* If the user didn't call _finish the qy will still be around. */
+  if (req->qy)
+    _g_asyncns_cancel (req->gur->asyncns, req->qy);
+
+  /* We don't have to free req->cancellable and req->async_result,
+   * since they must already have been freed if we're here.
+   */
+
+  g_slice_free (GUnixResolverRequest, req);
+}
+
+static void
+g_unix_resolver_request_complete (GUnixResolverRequest *req,
+                                  gboolean              need_idle)
+{
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (need_idle)
+    g_simple_async_result_complete_in_idle (req->async_result);
+  else
+    g_simple_async_result_complete (req->async_result);
+
+  /* If we completed_in_idle, that will have taken an extra ref on
+   * req->async_result; if not, then we're already done. Either way we
+   * need to unref the async_result to make sure it eventually is
+   * destroyed, causing req to be freed.
+   */
+  g_object_unref (req->async_result);
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GUnixResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  _g_asyncns_cancel (req->gur->asyncns, req->qy);
+  req->qy = NULL;
+
+  g_cancellable_set_error_if_cancelled (cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_error_free (error);
+
+  g_unix_resolver_request_complete (req, TRUE);
+}
+
+static gboolean
+g_unix_resolver_watch (GIOChannel   *iochannel,
+                       GIOCondition  condition,
+                       gpointer      user_data)
+{
+  GUnixResolver *gur = user_data;
+  _g_asyncns_query_t *qy;
+  GUnixResolverRequest *req;
+
+  if (condition & (G_IO_HUP | G_IO_ERR))
+    {
+      /* Shouldn't happen. Should we create a new asyncns? FIXME */
+      g_warning ("asyncns died");
+      gur->watch = 0;
+      return FALSE;
+    }
+
+  while (_g_asyncns_wait (gur->asyncns, FALSE) == 0 &&
+         (qy = _g_asyncns_getnext (gur->asyncns)) != NULL)
+    {
+      req = _g_asyncns_getuserdata (gur->asyncns, qy);
+      g_unix_resolver_request_complete (req, FALSE);
+    }
+
+  return TRUE;
+}
+
+static GUnixResolverRequest *
+resolve_async (GUnixResolver         *gur,
+               _g_asyncns_query_t    *qy,
+               GUnixResolverFreeFunc  free_func,
+               GCancellable          *cancellable,
+               GAsyncReadyCallback    callback,
+               gpointer               user_data,
+               gpointer               tag)
+{
+  GSimpleAsyncResult *result;
+  GUnixResolverRequest *req;
+
+  result = g_simple_async_result_new (G_OBJECT (gur), callback, user_data, tag);
+  req = g_unix_resolver_request_new (gur, qy, free_func, cancellable, result);
+  g_object_unref (result);
+  _g_asyncns_setuserdata (gur->asyncns, qy, req);
+
+  return req;
+}
+
+static void
+lookup_by_name_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.hostname);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_getaddrinfo (gur->asyncns, hostname, NULL,
+                               &_g_resolver_addrinfo_hints);
+  req = resolve_async (gur, qy, lookup_by_name_free, cancellable,
+                       callback, user_data, lookup_by_name_async);
+  req->u.hostname = g_strdup (hostname);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  struct addrinfo *res;
+  gint retval;
+  GList *addresses;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getaddrinfo_done (req->gur->asyncns, req->qy, &res);
+  req->qy = NULL;
+  addresses = _g_resolver_addresses_from_addrinfo (req->u.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+
+  return addresses;
+}
+
+
+static void
+lookup_by_address_free (GUnixResolverRequest *req)
+{
+  g_object_unref (req->u.address);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+
+  _g_resolver_address_to_sockaddr (address, &sockaddr, &sockaddr_size);
+  qy = _g_asyncns_getnameinfo (gur->asyncns,
+                               (struct sockaddr *)&sockaddr, sockaddr_size,
+                               NI_NAMEREQD, TRUE, FALSE);
+  req = resolve_async (gur, qy, lookup_by_address_free, cancellable,
+                       callback, user_data, lookup_by_address_async);
+  req->u.address = g_object_ref (address);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  gchar host[NI_MAXHOST], *name;
+  gint retval;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getnameinfo_done (req->gur->asyncns, req->qy,
+                                        host, sizeof (host), NULL, 0);
+  req->qy = NULL;
+  name = _g_resolver_name_from_nameinfo (req->u.address, host, retval, error);
+
+  return name;
+}
+
+
+static void
+lookup_service_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.service);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_res_query (gur->asyncns, rrname, C_IN, T_SRV);
+  req = resolve_async (gur, qy, lookup_service_free, cancellable,
+                       callback, user_data, lookup_service_async);
+  req->u.service = g_strdup (rrname);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  guchar *answer;
+  gint len, herr;
+  GList *targets;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  len = _g_asyncns_res_done (req->gur->asyncns, req->qy, &answer);
+  req->qy = NULL;
+  if (len < 0)
+    herr = h_errno;
+  else
+    herr = 0;
+
+  targets = _g_resolver_targets_from_res_query (req->u.service, answer, len, herr, error);
+  _g_asyncns_freeanswer (answer);
+
+  return targets;
+}
+
+
+static void
+g_unix_resolver_class_init (GUnixResolverClass *unix_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (unix_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (unix_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = g_unix_resolver_finalize;
+}
+
+#define __G_UNIX_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixresolver.h b/gio/gunixresolver.h
new file mode 100644
index 0000000..cf7765b
--- /dev/null
+++ b/gio/gunixresolver.h
@@ -0,0 +1,53 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_UNIX_RESOLVER_H__
+#define __G_UNIX_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+#include "libasyncns/asyncns.h"
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_RESOLVER         (g_unix_resolver_get_type ())
+#define G_UNIX_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_RESOLVER, GUnixResolver))
+#define G_UNIX_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+#define G_IS_UNIX_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_RESOLVER))
+#define G_IS_UNIX_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_RESOLVER))
+#define G_UNIX_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+  _g_asyncns_t *asyncns;
+  guint watch;
+
+} GUnixResolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GUnixResolverClass;
+
+GType g_unix_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixsocketaddress.c b/gio/gunixsocketaddress.c
new file mode 100644
index 0000000..0bc293f
--- /dev/null
+++ b/gio/gunixsocketaddress.c
@@ -0,0 +1,204 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "gunixsocketaddress.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gunixsocketaddress
+ * @short_description: Unix socket addresses
+ *
+ * Support for UNIX-domain (aka local) sockets.
+ **/
+
+/**
+ * GUnixSocketAddress:
+ *
+ * A UNIX-domain (local) socket address, corresponding to a
+ * <type>struct sockaddr_un</type>.
+ **/
+G_DEFINE_TYPE (GUnixSocketAddress, g_unix_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum
+{
+  PROP_0,
+  PROP_PATH,
+};
+
+struct _GUnixSocketAddressPrivate
+{
+  char *path;
+};
+
+static void
+g_unix_socket_address_finalize (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  g_free (address->priv->path);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize)
+    (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_unix_socket_address_dispose (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_unix_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_value_set_string (value, address->priv->path);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketFamily
+g_unix_socket_address_get_family (GSocketAddress *address)
+{
+  g_assert (PF_UNIX == G_SOCKET_FAMILY_UNIX);
+
+  return G_SOCKET_FAMILY_UNIX;
+}
+
+static void
+g_unix_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_free (address->priv->path);
+        address->priv->path = g_value_dup_string (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static gssize
+g_unix_socket_address_get_native_size (GSocketAddress *address)
+{
+  return sizeof (struct sockaddr_un);
+}
+
+static gboolean
+g_unix_socket_address_to_native (GSocketAddress *address,
+				 gpointer        dest,
+				 gsize           destlen)
+{
+  GUnixSocketAddress *addr = G_UNIX_SOCKET_ADDRESS (address);
+  struct sockaddr_un *sock;
+
+  if (destlen < sizeof (*sock))
+    return FALSE;
+
+  sock = (struct sockaddr_un *) dest;
+  sock->sun_family = AF_UNIX;
+  g_strlcpy (sock->sun_path, addr->priv->path, sizeof (sock->sun_path));
+
+  return TRUE;
+}
+
+static void
+g_unix_socket_address_class_init (GUnixSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GUnixSocketAddressPrivate));
+
+  gobject_class->finalize = g_unix_socket_address_finalize;
+  gobject_class->dispose = g_unix_socket_address_dispose;
+  gobject_class->set_property = g_unix_socket_address_set_property;
+  gobject_class->get_property = g_unix_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_unix_socket_address_get_family;
+  gsocketaddress_class->to_native = g_unix_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_unix_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_PATH,
+                                   g_param_spec_string ("path",
+                                                        _("Path"),
+                                                        _("UNIX socket path"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB));
+}
+
+static void
+g_unix_socket_address_init (GUnixSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_UNIX_SOCKET_ADDRESS,
+                                               GUnixSocketAddressPrivate);
+
+  address->priv->path = NULL;
+}
+
+/**
+ * g_unix_socket_address_new:
+ * @path: the socket path
+ *
+ * Creates a new #GUnixSocketAddress for @path.
+ *
+ * Returns: a new #GUnixSocketAddress
+ */
+GSocketAddress *
+g_unix_socket_address_new (const gchar *path)
+{
+  return g_object_new (G_TYPE_UNIX_SOCKET_ADDRESS,
+		       "path", path,
+		       NULL);
+}
+
+#define __G_UNIX_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixsocketaddress.h b/gio/gunixsocketaddress.h
new file mode 100644
index 0000000..527937f
--- /dev/null
+++ b/gio/gunixsocketaddress.h
@@ -0,0 +1,61 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#ifndef __G_UNIX_SOCKET_ADDRESS_H__
+#define __G_UNIX_SOCKET_ADDRESS_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_SOCKET_ADDRESS         (g_unix_socket_address_get_type ())
+#define G_UNIX_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
+#define G_UNIX_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+#define G_IS_UNIX_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+
+typedef struct _GUnixSocketAddress        GUnixSocketAddress;
+typedef struct _GUnixSocketAddressClass   GUnixSocketAddressClass;
+typedef struct _GUnixSocketAddressPrivate GUnixSocketAddressPrivate;
+
+struct _GUnixSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GUnixSocketAddressPrivate *priv;
+};
+
+struct _GUnixSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_unix_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_unix_socket_address_new         (const gchar *path);
+
+G_END_DECLS
+
+#endif /* __G_UNIX_SOCKET_ADDRESS_H__ */
diff --git a/gio/gwin32resolver.c b/gio/gwin32resolver.c
new file mode 100644
index 0000000..cab45cc
--- /dev/null
+++ b/gio/gwin32resolver.c
@@ -0,0 +1,481 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gwin32resolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GWin32Resolver, g_win32_resolver, G_TYPE_THREADED_RESOLVER)
+
+static void
+g_win32_resolver_init (GWin32Resolver *gwr)
+{
+}
+
+/* This is simpler than GThreadedResolver since we don't have to worry
+ * about multiple application-level threads, but more complicated than
+ * GUnixResolver, since we do have to deal with multiple threads of
+ * our own.
+ *
+ * The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: A GWin32ResolverRequest is created with
+ *    appropriate query-specific information, a Windows event handle,
+ *    and a GSimpleAsyncResult. This is then handed to the
+ *    Windows-internal thread pool, which does the raw DNS query part
+ *    of the operation (being careful to not call any glib methods
+ *    that might fail when called from another thread when
+ *    g_thread_init() has not been called). The main thread sets up a
+ *    GSource to asynchronously poll the event handle. There are two
+ *    sub-possibilities:
+ *
+ *      a. The resolution completes: the threadpool function calls
+ *         SetEvent() on the event handle and then returns.
+ *
+ *      b. The resolution is cancelled: request_cancelled()
+ *         disconnects the "cancelled" signal handler, and queues an
+ *         idle handler to complete the async_result.
+ *
+ *    Since we can't free the request from the threadpool thread
+ *    (because of glib locking issues), we *always* have to have it
+ *    call SetEvent and trigger the callback to indicate that it is
+ *    done. But this means that it's possible for the request to be
+ *    cancelled (queuing an idle handler to return that result) and
+ *    then have the resolution thread complete before the idle handler
+ *    runs. So the event callback and the idle handler need to both
+ *    watch out for this, making sure we don't complete the same
+ *    result twice.
+ */
+
+typedef struct GWin32ResolverRequest GWin32ResolverRequest;
+typedef void (*GWin32ResolverRequestFreeFunc) (GWin32ResolverRequest *);
+
+struct GWin32ResolverRequest {
+  GWin32ResolverRequestFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  HANDLE *event;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+  guint cancelled_idle;
+
+  union {
+    struct {
+      gchar *name;
+      gint retval;
+      struct addrinfo *res;
+    } name;
+
+    struct {
+      GInetAddress *iaddr;
+      struct sockaddr_storage addr;
+      gsize addrlen;
+      gint retval;
+      gchar *namebuf;
+    } address;
+
+    struct {
+      gchar *rrname;
+      DNS_STATUS retval;
+      DNS_RECORD *results;
+    } service;
+  } u;
+
+};
+
+static GSource *g_win32_handle_source_add (HANDLE      handle,
+                                           GSourceFunc callback,
+                                           gpointer    user_data);
+
+static gboolean request_completed (gpointer      user_data);
+static void     request_cancelled (GCancellable *cancellable,
+                                   gpointer      user_data);
+
+GWin32ResolverRequest *
+g_win32_resolver_request_new (GResolver                     *resolver,
+                              GWin32ResolverRequestFreeFunc  free_func,
+                              GCancellable                  *cancellable,
+                              GAsyncReadyCallback            callback,
+                              gpointer                       user_data,
+                              gpointer                       tag)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_slice_new0 (GWin32ResolverRequest);
+  req->free_func = free_func;
+
+  req->async_result = g_simple_async_result_new (G_OBJECT (resolver), callback,
+                                                 user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+
+  req->event = CreateEvent (NULL, FALSE, FALSE, NULL);
+  g_win32_handle_source_add (req->event, request_completed, req);  
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  return req;
+}
+
+static gboolean
+request_completed (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  /* Clean up cancellation-related stuff first */
+  if (req->cancelled_idle)
+    {
+      g_source_remove (req->cancelled_idle);
+      req->cancelled_idle = 0;
+    }
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+    }
+
+  /* Now complete the result (assuming it wasn't already completed) */
+  if (req->async_result)
+    {
+      g_simple_async_result_complete (req->async_result);
+      g_object_unref (req->async_result);
+    }
+
+  /* And free req */
+  CloseHandle (req->event);
+  req->free_func (req);
+  g_slice_free (GWin32ResolverRequest, req);
+
+  return FALSE;
+}
+
+static gboolean
+request_cancelled_idle (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  req->cancelled_idle = 0;
+
+  g_cancellable_set_error_if_cancelled (req->cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_simple_async_result_complete (req->async_result);
+
+  g_object_unref (req->async_result);
+  req->async_result = NULL;
+
+  /* request_completed will eventually be called to free req */
+
+  return FALSE;
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  /* We need to wait until main-loop-time to actually complete the
+   * result; we don't use _complete_in_idle() here because we need to
+   * keep track of the source id.
+   */
+  req->cancelled_idle = g_idle_add (request_cancelled_idle, req);
+}
+
+static DWORD WINAPI
+lookup_by_name_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.name.retval = getaddrinfo (req->u.name.name, NULL,
+                                    &_g_resolver_addrinfo_hints,
+                                    &req->u.name.res);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_name (GWin32ResolverRequest *req)
+{
+  g_free (req->u.name.name);
+  if (req->u.name.res)
+    freeaddrinfo (req->u.name.res);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_name,
+                                      cancellable, callback, user_data,
+                                      lookup_by_name_async);
+  req->u.name.name = g_strdup (hostname);
+
+  QueueUserWorkItem (lookup_by_name_in_thread, req, 0);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_addresses_from_addrinfo (req->u.name.name, req->u.name.res,
+                                              req->u.name.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_by_addresses_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.address.retval =
+    getnameinfo ((struct sockaddr *)&req->u.address.addr,
+                 req->u.address.addrlen,
+                 req->u.address.namebuf, NI_MAXHOST, NULL, 0, NI_NAMEREQD);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_address (GWin32ResolverRequest *req)
+{
+  g_object_unref (req->u.address.iaddr);
+  g_free (req->u.address.namebuf);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_address,
+                                      cancellable, callback, user_data,
+                                      lookup_by_address_async);
+
+  req->u.address.iaddr = g_object_ref (address);
+  _g_resolver_address_to_sockaddr (address, &req->u.address.addr,
+                                   &req->u.address.addrlen);
+  req->u.address.namebuf = g_malloc (NI_MAXHOST);
+
+  QueueUserWorkItem (lookup_by_addresses_in_thread, req, 0);
+}
+
+static char *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_name_from_nameinfo (req->u.address.iaddr,
+                                         req->u.address.namebuf,
+                                         req->u.address.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_service_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.service.retval =
+    DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV, DNS_QUERY_STANDARD,
+                NULL, &req->u.service.results, NULL);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_service (GWin32ResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.results)
+    DnsRecordListFree (req->u.service.results, DnsFreeRecordList);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_service,
+                                      cancellable, callback, user_data,
+                                      lookup_service_async);
+  req->u.service.rrname = g_strdup (rrname);
+
+  QueueUserWorkItem (lookup_service_in_thread, req, 0);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_targets_from_DnsQuery (req->u.service.rrname,
+                                            req->u.service.retval,
+                                            req->u.service.results, error);
+}
+
+
+static void
+g_win32_resolver_class_init (GWin32ResolverClass *win32_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (win32_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+}
+
+
+/* Windows HANDLE GSource */
+
+typedef struct {
+  GSource source;
+  GPollFD pollfd;
+} GWin32HandleSource;
+
+static gboolean
+g_win32_handle_source_prepare (GSource *source,
+                               gint    *timeout)
+{
+  *timeout = -1;
+  return FALSE;
+}
+
+static gboolean
+g_win32_handle_source_check (GSource *source)
+{
+  GWin32HandleSource *hsource = (GWin32HandleSource *)source;
+
+  return hsource->pollfd.revents;
+}
+
+static gboolean
+g_win32_handle_source_dispatch (GSource     *source,
+                                GSourceFunc  callback,
+                                gpointer     user_data)
+{
+  return (*callback) (user_data);
+}
+
+static void
+g_win32_handle_source_finalize (GSource *source)
+{
+  ;
+}
+
+GSourceFuncs g_win32_handle_source_funcs = {
+  g_win32_handle_source_prepare,
+  g_win32_handle_source_check,
+  g_win32_handle_source_dispatch,
+  g_win32_handle_source_finalize
+};
+
+static GSource *
+g_win32_handle_source_add (HANDLE      handle,
+                           GSourceFunc callback,
+                           gpointer    user_data)
+{
+  GWin32HandleSource *hsource;
+  GSource *source;
+
+  source = g_source_new (&g_win32_handle_source_funcs, sizeof (GWin32HandleSource));
+  hsource = (GWin32HandleSource *)source;
+  hsource->pollfd.fd = (gint)handle;
+  hsource->pollfd.events = G_IO_IN;
+  hsource->pollfd.revents = 0;
+  g_source_add_poll (source, &hsource->pollfd);
+
+  g_source_set_callback (source, callback, user_data, NULL);
+  g_source_attach (source, NULL);
+  return source;
+}
+
+#define __G_WIN32_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gwin32resolver.h b/gio/gwin32resolver.h
new file mode 100644
index 0000000..5cc6a2c
--- /dev/null
+++ b/gio/gwin32resolver.h
@@ -0,0 +1,49 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_WIN32_RESOLVER_H__
+#define __G_WIN32_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_WIN32_RESOLVER         (g_win32_resolver_get_type ())
+#define G_WIN32_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_RESOLVER, GWin32Resolver))
+#define G_WIN32_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+#define G_IS_WIN32_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_RESOLVER))
+#define G_IS_WIN32_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_RESOLVER))
+#define G_WIN32_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+} GWin32Resolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GWin32ResolverClass;
+
+GType g_win32_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/libasyncns/Makefile.am b/gio/libasyncns/Makefile.am
new file mode 100644
index 0000000..80b20a2
--- /dev/null
+++ b/gio/libasyncns/Makefile.am
@@ -0,0 +1,15 @@
+## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/Makefile.decl
+
+INCLUDES = -I$(top_srcdir)
+
+noinst_LTLIBRARIES = libasyncns.la
+
+libasyncns_la_SOURCES = \
+	asyncns.c \
+	asyncns.h \
+	g-asyncns.h
+
+libasyncns_la_LIBADD = $(LIBASYNCNS_LIBADD)
+
+EXTRA_DIST += README update.sh
diff --git a/gio/libasyncns/README b/gio/libasyncns/README
new file mode 100644
index 0000000..b926291
--- /dev/null
+++ b/gio/libasyncns/README
@@ -0,0 +1,7 @@
+The sources are derived from Lennart Poettering's libasyncns library:
+
+ http://0pointer.de/lennart/projects/libasyncns/
+
+The 'update.sh' script in this directory, when pointed at
+the original sources updates the files in this directory
+to the new version
diff --git a/gio/libasyncns/asyncns.c b/gio/libasyncns/asyncns.c
new file mode 100644
index 0000000..3c4db73
--- /dev/null
+++ b/gio/libasyncns/asyncns.c
@@ -0,0 +1,1498 @@
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include "g-asyncns.h"
+#endif
+
+/* #undef HAVE_PTHREAD */
+
+#include <assert.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/select.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <dirent.h>
+
+#if HAVE_ARPA_NAMESER_COMPAT_H
+#include <arpa/nameser_compat.h>
+#endif
+
+#ifdef HAVE_SYS_PRCTL_H
+#include <sys/prctl.h>
+#endif
+
+#if HAVE_PTHREAD
+#include <pthread.h>
+#endif
+
+#include "asyncns.h"
+
+#ifndef MSG_NOSIGNAL
+#define MSG_NOSIGNAL 0
+#endif
+
+#define MAX_WORKERS 16
+#define MAX_QUERIES 256
+#define BUFSIZE (10240)
+
+typedef enum {
+    REQUEST_ADDRINFO,
+    RESPONSE_ADDRINFO,
+    REQUEST_NAMEINFO,
+    RESPONSE_NAMEINFO,
+    REQUEST_RES_QUERY,
+    REQUEST_RES_SEARCH,
+    RESPONSE_RES,
+    REQUEST_TERMINATE,
+    RESPONSE_DIED
+} query_type_t;
+
+enum {
+    REQUEST_RECV_FD = 0,
+    REQUEST_SEND_FD = 1,
+    RESPONSE_RECV_FD = 2,
+    RESPONSE_SEND_FD = 3,
+    MESSAGE_FD_MAX = 4
+};
+
+struct asyncns {
+    int fds[4];
+
+#ifndef HAVE_PTHREAD
+    pid_t workers[MAX_WORKERS];
+#else
+    pthread_t workers[MAX_WORKERS];
+#endif
+    unsigned valid_workers;
+
+    unsigned current_id, current_index;
+    _g_asyncns_query_t* queries[MAX_QUERIES];
+
+    _g_asyncns_query_t *done_head, *done_tail;
+
+    int n_queries;
+    int dead;
+};
+
+struct _g_asyncns_query {
+    _g_asyncns_t *asyncns;
+    int done;
+    unsigned id;
+    query_type_t type;
+    _g_asyncns_query_t *done_next, *done_prev;
+    int ret;
+    int _errno;
+    int _h_errno;
+    struct addrinfo *addrinfo;
+    char *serv, *host;
+    void *userdata;
+};
+
+typedef struct rheader {
+    query_type_t type;
+    unsigned id;
+    size_t length;
+} rheader_t;
+
+typedef struct addrinfo_request {
+    struct rheader header;
+    int hints_is_null;
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t node_len, service_len;
+} addrinfo_request_t;
+
+typedef struct addrinfo_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+    /* followed by addrinfo_serialization[] */
+} addrinfo_response_t;
+
+typedef struct addrinfo_serialization {
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t ai_addrlen;
+    size_t canonname_len;
+    /* Followed by ai_addr amd ai_canonname with variable lengths */
+} addrinfo_serialization_t;
+
+typedef struct nameinfo_request {
+    struct rheader header;
+    int flags;
+    socklen_t sockaddr_len;
+    int gethost, getserv;
+} nameinfo_request_t;
+
+typedef struct nameinfo_response {
+    struct rheader header;
+    size_t hostlen, servlen;
+    int ret;
+    int _errno;
+    int _h_errno;
+} nameinfo_response_t;
+
+typedef struct res_query_request {
+    struct rheader header;
+    int class;
+    int type;
+    size_t dname_len;
+} res_request_t;
+
+typedef struct res_query_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+} res_response_t;
+
+#ifndef HAVE_STRNDUP
+
+static char *strndup(const char *s, size_t l) {
+    size_t a;
+    char *n;
+
+    a = strlen(s);
+    if (a > l)
+        a = l;
+
+    if (!(n = malloc(a+1)))
+        return NULL;
+
+    memcpy(n, s, a);
+    n[a] = 0;
+
+    return n;
+}
+
+#endif
+
+#ifndef HAVE_PTHREAD
+
+static int close_allv(const int except_fds[]) {
+    struct rlimit rl;
+    int fd;
+
+#ifdef __linux__
+
+    DIR *d;
+
+    assert(except_fds);
+
+    if ((d = opendir("/proc/self/fd"))) {
+
+        struct dirent *de;
+
+        while ((de = readdir(d))) {
+            int found;
+            long l;
+            char *e = NULL;
+            int i;
+
+            if (de->d_name[0] == '.')
+                continue;
+
+            errno = 0;
+            l = strtol(de->d_name, &e, 10);
+            if (errno != 0 || !e || *e) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            fd = (int) l;
+
+            if ((long) fd != l) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            if (fd < 3)
+                continue;
+
+            if (fd == dirfd(d))
+                continue;
+
+            found = 0;
+            for (i = 0; except_fds[i] >= 0; i++)
+                if (except_fds[i] == fd) {
+                    found = 1;
+                    break;
+                }
+
+            if (found)
+                continue;
+
+            if (close(fd) < 0) {
+                int saved_errno;
+
+                saved_errno = errno;
+                closedir(d);
+                errno = saved_errno;
+
+                return -1;
+            }
+        }
+
+        closedir(d);
+        return 0;
+    }
+
+#endif
+
+    if (getrlimit(RLIMIT_NOFILE, &rl) < 0)
+        return -1;
+
+    for (fd = 0; fd < (int) rl.rlim_max; fd++) {
+        int i;
+
+        if (fd <= 3)
+            continue;
+
+        for (i = 0; except_fds[i] >= 0; i++)
+            if (except_fds[i] == fd)
+                continue;
+
+        if (close(fd) < 0 && errno != EBADF)
+            return -1;
+    }
+
+    return 0;
+}
+
+static int reset_sigsv(const int except[]) {
+    int sig;
+    assert(except);
+
+    for (sig = 1; sig < NSIG; sig++) {
+        int reset = 1;
+
+        switch (sig) {
+            case SIGKILL:
+            case SIGSTOP:
+                reset = 0;
+                break;
+
+            default: {
+                int i;
+
+                for (i = 0; except[i] > 0; i++) {
+                    if (sig == except[i]) {
+                        reset = 0;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (reset) {
+            struct sigaction sa;
+
+            memset(&sa, 0, sizeof(sa));
+            sa.sa_handler = SIG_DFL;
+
+            /* On Linux the first two RT signals are reserved by
+             * glibc, and sigaction() will return EINVAL for them. */
+            if ((sigaction(sig, &sa, NULL) < 0))
+                if (errno != EINVAL)
+                    return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int ignore_sigsv(const int ignore[]) {
+    int i;
+    assert(ignore);
+
+    for (i = 0; ignore[i] > 0; i++) {
+        struct sigaction sa;
+
+        memset(&sa, 0, sizeof(sa));
+        sa.sa_handler = SIG_IGN;
+
+        if ((sigaction(ignore[i], &sa, NULL) < 0))
+            return -1;
+    }
+
+    return 0;
+}
+
+#endif
+
+static int fd_nonblock(int fd) {
+    int i;
+    assert(fd >= 0);
+
+    if ((i = fcntl(fd, F_GETFL, 0)) < 0)
+        return -1;
+
+    if (i & O_NONBLOCK)
+        return 0;
+
+    return fcntl(fd, F_SETFL, i | O_NONBLOCK);
+}
+
+static int fd_cloexec(int fd) {
+    int v;
+    assert(fd >= 0);
+
+    if ((v = fcntl(fd, F_GETFD, 0)) < 0)
+        return -1;
+
+    if (v & FD_CLOEXEC)
+        return 0;
+
+    return fcntl(fd, F_SETFD, v | FD_CLOEXEC);
+}
+
+static int send_died(int out_fd) {
+    rheader_t rh;
+    assert(out_fd > 0);
+
+    memset(&rh, 0, sizeof(rh));
+    rh.type = RESPONSE_DIED;
+    rh.id = 0;
+    rh.length = sizeof(rh);
+
+    return send(out_fd, &rh, rh.length, MSG_NOSIGNAL);
+}
+
+static void *serialize_addrinfo(void *p, const struct addrinfo *ai, size_t *length, size_t maxlength) {
+    addrinfo_serialization_t s;
+    size_t cnl, l;
+    assert(p);
+    assert(ai);
+    assert(length);
+    assert(*length <= maxlength);
+
+    cnl = (ai->ai_canonname ? strlen(ai->ai_canonname)+1 : 0);
+    l = sizeof(addrinfo_serialization_t) + ai->ai_addrlen + cnl;
+
+    if (*length + l > maxlength)
+        return NULL;
+
+    s.ai_flags = ai->ai_flags;
+    s.ai_family = ai->ai_family;
+    s.ai_socktype = ai->ai_socktype;
+    s.ai_protocol = ai->ai_protocol;
+    s.ai_addrlen = ai->ai_addrlen;
+    s.canonname_len = cnl;
+
+    memcpy((uint8_t*) p, &s, sizeof(addrinfo_serialization_t));
+    memcpy((uint8_t*) p + sizeof(addrinfo_serialization_t), ai->ai_addr, ai->ai_addrlen);
+
+    if (ai->ai_canonname)
+        strcpy((char*) p + sizeof(addrinfo_serialization_t) + ai->ai_addrlen, ai->ai_canonname);
+
+    *length += l;
+    return (uint8_t*) p + l;
+}
+
+static int send_addrinfo_reply(int out_fd, unsigned id, int ret, struct addrinfo *ai, int _errno, int _h_errno) {
+    addrinfo_response_t data[BUFSIZE/sizeof(addrinfo_response_t) + 1];
+    addrinfo_response_t *resp = data;
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_ADDRINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(addrinfo_response_t);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    if (ret == 0 && ai) {
+        void *p = data + 1;
+        struct addrinfo *k;
+
+        for (k = ai; k; k = k->ai_next) {
+
+            if (!(p = serialize_addrinfo(p, k, &resp->header.length, (char*) data + BUFSIZE - (char*) p))) {
+                resp->ret = EAI_MEMORY;
+                break;
+            }
+        }
+    }
+
+    if (ai)
+        freeaddrinfo(ai);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_nameinfo_reply(int out_fd, unsigned id, int ret, const char *host, const char *serv, int _errno, int _h_errno) {
+    nameinfo_response_t data[BUFSIZE/sizeof(nameinfo_response_t) + 1];
+    size_t hl, sl;
+    nameinfo_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    sl = serv ? strlen(serv)+1 : 0;
+    hl = host ? strlen(host)+1 : 0;
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_NAMEINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(nameinfo_response_t) + hl + sl;
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+    resp->hostlen = hl;
+    resp->servlen = sl;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (host)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t), host, hl);
+
+    if (serv)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t) + hl, serv, sl);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_res_reply(int out_fd, unsigned id, const unsigned char *answer, int ret, int _errno, int _h_errno) {
+    res_response_t data[BUFSIZE/sizeof(res_response_t) + 1];
+    res_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_RES;
+    resp->header.id = id;
+    resp->header.length = sizeof(res_response_t) + (ret < 0 ? 0 : ret);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (ret > 0)
+        memcpy((uint8_t *)data + sizeof(res_response_t), answer, ret);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int handle_request(int out_fd, const rheader_t *req, size_t length) {
+    assert(out_fd >= 0);
+    assert(req);
+    assert(length >= sizeof(rheader_t));
+    assert(length == req->length);
+
+    switch (req->type) {
+        case REQUEST_ADDRINFO: {
+            struct addrinfo ai, *result = NULL;
+            const addrinfo_request_t *ai_req = (const addrinfo_request_t*) req;
+            const char *node, *service;
+            int ret;
+
+            assert(length >= sizeof(addrinfo_request_t));
+            assert(length == sizeof(addrinfo_request_t) + ai_req->node_len + ai_req->service_len);
+
+            memset(&ai, 0, sizeof(ai));
+            ai.ai_flags = ai_req->ai_flags;
+            ai.ai_family = ai_req->ai_family;
+            ai.ai_socktype = ai_req->ai_socktype;
+            ai.ai_protocol = ai_req->ai_protocol;
+
+            node = ai_req->node_len ? (const char*) req + sizeof(addrinfo_request_t) : NULL;
+            service = ai_req->service_len ? (const char*) req + sizeof(addrinfo_request_t) + ai_req->node_len : NULL;
+
+            ret = getaddrinfo(node, service,
+                              ai_req->hints_is_null ? NULL : &ai,
+                              &result);
+
+            /* send_addrinfo_reply() frees result */
+            return send_addrinfo_reply(out_fd, req->id, ret, result, errno, h_errno);
+        }
+
+        case REQUEST_NAMEINFO: {
+            int ret;
+            const nameinfo_request_t *ni_req = (const nameinfo_request_t*) req;
+            char hostbuf[NI_MAXHOST], servbuf[NI_MAXSERV];
+            struct sockaddr_storage sa;
+
+            assert(length >= sizeof(nameinfo_request_t));
+            assert(length == sizeof(nameinfo_request_t) + ni_req->sockaddr_len);
+
+            memcpy(&sa, (const uint8_t *)req + sizeof(nameinfo_request_t), ni_req->sockaddr_len);
+
+            ret = getnameinfo((struct sockaddr *)&sa, ni_req->sockaddr_len,
+                              ni_req->gethost ? hostbuf : NULL, ni_req->gethost ? sizeof(hostbuf) : 0,
+                              ni_req->getserv ? servbuf : NULL, ni_req->getserv ? sizeof(servbuf) : 0,
+                              ni_req->flags);
+
+            return send_nameinfo_reply(out_fd, req->id, ret,
+                                       ret == 0 && ni_req->gethost ? hostbuf : NULL,
+                                       ret == 0 && ni_req->getserv ? servbuf : NULL,
+                                       errno, h_errno);
+        }
+
+        case REQUEST_RES_QUERY:
+        case REQUEST_RES_SEARCH: {
+            int ret;
+            HEADER answer[BUFSIZE/sizeof(HEADER) + 1];
+            const res_request_t *res_req = (const res_request_t *)req;
+            const char *dname;
+
+            assert(length >= sizeof(res_request_t));
+            assert(length == sizeof(res_request_t) + res_req->dname_len);
+
+            dname = (const char *) req + sizeof(res_request_t);
+
+            if (req->type == REQUEST_RES_QUERY)
+                ret = res_query(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+            else
+                ret = res_search(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+
+            return send_res_reply(out_fd, req->id, (unsigned char *) answer, ret, errno, h_errno);
+        }
+
+        case REQUEST_TERMINATE:
+            /* Quit */
+            return -1;
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+#ifndef HAVE_PTHREAD
+
+static int process_worker(int in_fd, int out_fd) {
+    int have_death_sig = 0;
+    int good_fds[3];
+    int ret = 1;
+
+    const int ignore_sigs[] = {
+        SIGINT,
+        SIGHUP,
+        SIGPIPE,
+        SIGUSR1,
+        SIGUSR2,
+        -1
+    };
+
+    assert(in_fd > 2);
+    assert(out_fd > 2);
+
+    close(0);
+    close(1);
+    close(2);
+
+    if (open("/dev/null", O_RDONLY) != 0)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 1)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 2)
+        goto fail;
+
+    if (chdir("/") < 0)
+        goto fail;
+
+    if (geteuid() == 0) {
+        struct passwd *pw;
+        int r;
+
+        if ((pw = getpwnam("nobody"))) {
+#ifdef HAVE_SETRESUID
+            r = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
+#elif HAVE_SETREUID
+            r = setreuid(pw->pw_uid, pw->pw_uid);
+#else
+            if ((r = setuid(pw->pw_uid)) >= 0)
+                r = seteuid(pw->pw_uid);
+#endif
+            if (r < 0)
+                goto fail;
+        }
+    }
+
+    if (reset_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    if (ignore_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    good_fds[0] = in_fd; good_fds[1] = out_fd; good_fds[2] = -1;
+    if (close_allv(good_fds) < 0)
+        goto fail;
+
+#ifdef PR_SET_PDEATHSIG
+    if (prctl(PR_SET_PDEATHSIG, SIGTERM) >= 0)
+        have_death_sig = 1;
+#endif
+
+    if (!have_death_sig)
+        fd_nonblock(in_fd);
+
+    while (getppid() > 1) { /* if the parent PID is 1 our parent process died. */
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if (!have_death_sig) {
+            fd_set fds;
+            struct timeval tv = { 0, 500000 };
+
+            FD_ZERO(&fds);
+            FD_SET(in_fd, &fds);
+
+            if (select(in_fd+1, &fds, NULL, NULL, &tv) < 0)
+                break;
+
+            if (getppid() == 1)
+                break;
+        }
+
+        if ((length = recv(in_fd, buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (handle_request(out_fd, buf, (size_t) length) < 0)
+            break;
+    }
+
+    ret = 0;
+
+fail:
+    send_died(out_fd);
+
+    return ret;
+}
+
+#else
+
+static void* thread_worker(void *p) {
+    _g_asyncns_t *asyncns = p;
+    sigset_t fullset;
+
+    /* No signals in this thread please */
+    sigfillset(&fullset);
+    pthread_sigmask(SIG_BLOCK, &fullset, NULL);
+
+    while (!asyncns->dead) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if ((length = recv(asyncns->fds[REQUEST_RECV_FD], buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (asyncns->dead)
+            break;
+
+        if (handle_request(asyncns->fds[RESPONSE_SEND_FD], buf, (size_t) length) < 0)
+            break;
+    }
+
+    send_died(asyncns->fds[RESPONSE_SEND_FD]);
+
+    return NULL;
+}
+
+#endif
+
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc) {
+    _g_asyncns_t *asyncns = NULL;
+    int i;
+    assert(n_proc >= 1);
+
+    if (n_proc > MAX_WORKERS)
+        n_proc = MAX_WORKERS;
+
+    if (!(asyncns = malloc(sizeof(_g_asyncns_t)))) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    asyncns->dead = 0;
+    asyncns->valid_workers = 0;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        asyncns->fds[i] = -1;
+
+    memset(asyncns->queries, 0, sizeof(asyncns->queries));
+
+    if (socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds) < 0 ||
+        socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds+2) < 0)
+        goto fail;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        fd_cloexec(asyncns->fds[i]);
+
+    for (asyncns->valid_workers = 0; asyncns->valid_workers < n_proc; asyncns->valid_workers++) {
+
+#ifndef HAVE_PTHREAD
+        if ((asyncns->workers[asyncns->valid_workers] = fork()) < 0)
+            goto fail;
+        else if (asyncns->workers[asyncns->valid_workers] == 0) {
+            int ret;
+
+            close(asyncns->fds[REQUEST_SEND_FD]);
+            close(asyncns->fds[RESPONSE_RECV_FD]);
+            ret = process_worker(asyncns->fds[REQUEST_RECV_FD], asyncns->fds[RESPONSE_SEND_FD]);
+            close(asyncns->fds[REQUEST_RECV_FD]);
+            close(asyncns->fds[RESPONSE_SEND_FD]);
+            _exit(ret);
+        }
+#else
+        int r;
+
+        if ((r = pthread_create(&asyncns->workers[asyncns->valid_workers], NULL, thread_worker, asyncns)) != 0) {
+            errno = r;
+            goto fail;
+        }
+#endif
+    }
+
+#ifndef HAVE_PTHREAD
+    close(asyncns->fds[REQUEST_RECV_FD]);
+    close(asyncns->fds[RESPONSE_SEND_FD]);
+    asyncns->fds[REQUEST_RECV_FD] = asyncns->fds[RESPONSE_SEND_FD] = -1;
+#endif
+
+    asyncns->current_index = asyncns->current_id = 0;
+    asyncns->done_head = asyncns->done_tail = NULL;
+    asyncns->n_queries = 0;
+
+    fd_nonblock(asyncns->fds[RESPONSE_RECV_FD]);
+
+    return asyncns;
+
+fail:
+    if (asyncns)
+        _g_asyncns_free(asyncns);
+
+    return NULL;
+}
+
+void _g_asyncns_free(_g_asyncns_t *asyncns) {
+    int i;
+    int saved_errno = errno;
+    unsigned p;
+
+    assert(asyncns);
+
+    asyncns->dead = 1;
+
+    if (asyncns->fds[REQUEST_SEND_FD] >= 0) {
+        rheader_t req;
+
+        memset(&req, 0, sizeof(req));
+        req.type = REQUEST_TERMINATE;
+        req.length = sizeof(req);
+        req.id = 0;
+
+        /* Send one termination packet for each worker */
+        for (p = 0; p < asyncns->valid_workers; p++)
+            send(asyncns->fds[REQUEST_SEND_FD], &req, req.length, MSG_NOSIGNAL);
+    }
+
+    /* Now terminate them and wait until they are gone. */
+    for (p = 0; p < asyncns->valid_workers; p++) {
+#ifndef HAVE_PTHREAD
+        kill(asyncns->workers[p], SIGTERM);
+        for (;;) {
+            if (waitpid(asyncns->workers[p], NULL, 0) >= 0 || errno != EINTR)
+                break;
+        }
+#else
+        for (;;) {
+            if (pthread_join(asyncns->workers[p], NULL) != EINTR)
+                break;
+        }
+#endif
+    }
+
+    /* Close all communication channels */
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        if (asyncns->fds[i] >= 0)
+            close(asyncns->fds[i]);
+
+    for (p = 0; p < MAX_QUERIES; p++)
+        if (asyncns->queries[p])
+            _g_asyncns_cancel(asyncns, asyncns->queries[p]);
+
+    free(asyncns);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_fd(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+
+    return asyncns->fds[RESPONSE_RECV_FD];
+}
+
+static _g_asyncns_query_t *lookup_query(_g_asyncns_t *asyncns, unsigned id) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if ((q = asyncns->queries[id % MAX_QUERIES]))
+        if (q->id == id)
+            return q;
+
+    return NULL;
+}
+
+static void complete_query(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(asyncns);
+    assert(q);
+    assert(!q->done);
+
+    q->done = 1;
+
+    if ((q->done_prev = asyncns->done_tail))
+        asyncns->done_tail->done_next = q;
+    else
+        asyncns->done_head = q;
+
+    asyncns->done_tail = q;
+    q->done_next = NULL;
+}
+
+static void *unserialize_addrinfo(void *p, struct addrinfo **ret_ai, size_t *length) {
+    addrinfo_serialization_t s;
+    size_t l;
+    struct addrinfo *ai;
+    assert(p);
+    assert(ret_ai);
+    assert(length);
+
+    if (*length < sizeof(addrinfo_serialization_t))
+        return NULL;
+
+    memcpy(&s, p, sizeof(s));
+
+    l = sizeof(addrinfo_serialization_t) + s.ai_addrlen + s.canonname_len;
+    if (*length < l)
+        return NULL;
+
+    if (!(ai = malloc(sizeof(struct addrinfo))))
+        goto fail;
+
+    ai->ai_addr = NULL;
+    ai->ai_canonname = NULL;
+    ai->ai_next = NULL;
+
+    if (s.ai_addrlen && !(ai->ai_addr = malloc(s.ai_addrlen)))
+        goto fail;
+
+    if (s.canonname_len && !(ai->ai_canonname = malloc(s.canonname_len)))
+        goto fail;
+
+    ai->ai_flags = s.ai_flags;
+    ai->ai_family = s.ai_family;
+    ai->ai_socktype = s.ai_socktype;
+    ai->ai_protocol = s.ai_protocol;
+    ai->ai_addrlen = s.ai_addrlen;
+
+    if (ai->ai_addr)
+        memcpy(ai->ai_addr, (uint8_t*) p + sizeof(addrinfo_serialization_t), s.ai_addrlen);
+
+    if (ai->ai_canonname)
+        memcpy(ai->ai_canonname, (uint8_t*) p + sizeof(addrinfo_serialization_t) + s.ai_addrlen, s.canonname_len);
+
+    *length -= l;
+    *ret_ai = ai;
+
+    return (uint8_t*) p + l;
+
+
+fail:
+    if (ai)
+        _g_asyncns_freeaddrinfo(ai);
+
+    return NULL;
+}
+
+static int handle_response(_g_asyncns_t *asyncns, rheader_t *resp, size_t length) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(resp);
+    assert(length >= sizeof(rheader_t));
+    assert(length == resp->length);
+
+    if (resp->type == RESPONSE_DIED) {
+        asyncns->dead = 1;
+        return 0;
+    }
+
+    if (!(q = lookup_query(asyncns, resp->id)))
+        return 0;
+
+    switch (resp->type) {
+        case RESPONSE_ADDRINFO: {
+            const addrinfo_response_t *ai_resp = (addrinfo_response_t*) resp;
+            void *p;
+            size_t l;
+            struct addrinfo *prev = NULL;
+
+            assert(length >= sizeof(addrinfo_response_t));
+            assert(q->type == REQUEST_ADDRINFO);
+
+            q->ret = ai_resp->ret;
+            q->_errno = ai_resp->_errno;
+            q->_h_errno = ai_resp->_h_errno;
+            l = length - sizeof(addrinfo_response_t);
+            p = (uint8_t*) resp + sizeof(addrinfo_response_t);
+
+            while (l > 0 && p) {
+                struct addrinfo *ai = NULL;
+                p = unserialize_addrinfo(p, &ai, &l);
+
+                if (!p || !ai) {
+                    q->ret = EAI_MEMORY;
+                    break;
+                }
+
+                if (prev)
+                    prev->ai_next = ai;
+                else
+                    q->addrinfo = ai;
+
+                prev = ai;
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_NAMEINFO: {
+            const nameinfo_response_t *ni_resp = (nameinfo_response_t*) resp;
+
+            assert(length >= sizeof(nameinfo_response_t));
+            assert(q->type == REQUEST_NAMEINFO);
+
+            q->ret = ni_resp->ret;
+            q->_errno = ni_resp->_errno;
+            q->_h_errno = ni_resp->_h_errno;
+
+            if (ni_resp->hostlen)
+                if (!(q->host = strndup((const char*) ni_resp + sizeof(nameinfo_response_t), ni_resp->hostlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            if (ni_resp->servlen)
+                if (!(q->serv = strndup((const char*) ni_resp + sizeof(nameinfo_response_t) + ni_resp->hostlen, ni_resp->servlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_RES: {
+            const res_response_t *res_resp = (res_response_t *)resp;
+
+            assert(length >= sizeof(res_response_t));
+            assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+
+            q->ret = res_resp->ret;
+            q->_errno = res_resp->_errno;
+            q->_h_errno = res_resp->_h_errno;
+
+            if (res_resp->ret >= 0)  {
+                if (!(q->serv = malloc(res_resp->ret))) {
+                    q->ret = -1;
+                    q->_errno = ENOMEM;
+                } else
+                    memcpy(q->serv, (char *)resp + sizeof(res_response_t), res_resp->ret);
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block) {
+    int handled = 0;
+    assert(asyncns);
+
+    for (;;) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t l;
+
+        if (asyncns->dead) {
+            errno = ECHILD;
+            return -1;
+        }
+
+        if (((l = recv(asyncns->fds[RESPONSE_RECV_FD], buf, sizeof(buf), 0)) < 0)) {
+            fd_set fds;
+
+            if (errno != EAGAIN)
+                return -1;
+
+            if (!block || handled)
+                return 0;
+
+            FD_ZERO(&fds);
+            FD_SET(asyncns->fds[RESPONSE_RECV_FD], &fds);
+
+            if (select(asyncns->fds[RESPONSE_RECV_FD]+1, &fds, NULL, NULL, NULL) < 0)
+                return -1;
+
+            continue;
+        }
+
+        if (handle_response(asyncns, buf, (size_t) l) < 0)
+            return -1;
+
+        handled = 1;
+    }
+}
+
+static _g_asyncns_query_t *alloc_query(_g_asyncns_t *asyncns) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if (asyncns->n_queries >= MAX_QUERIES) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    while (asyncns->queries[asyncns->current_index]) {
+
+        asyncns->current_index++;
+        asyncns->current_id++;
+
+        while (asyncns->current_index >= MAX_QUERIES)
+            asyncns->current_index -= MAX_QUERIES;
+    }
+
+    if (!(q = asyncns->queries[asyncns->current_index] = malloc(sizeof(_g_asyncns_query_t)))) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    asyncns->n_queries++;
+
+    q->asyncns = asyncns;
+    q->done = 0;
+    q->id = asyncns->current_id;
+    q->done_next = q->done_prev = NULL;
+    q->ret = 0;
+    q->_errno = 0;
+    q->_h_errno = 0;
+    q->addrinfo = NULL;
+    q->userdata = NULL;
+    q->host = q->serv = NULL;
+
+    return q;
+}
+
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints) {
+    addrinfo_request_t data[BUFSIZE/sizeof(addrinfo_request_t) + 1];
+    addrinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(node || service);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(addrinfo_request_t));
+
+    req->node_len = node ? strlen(node)+1 : 0;
+    req->service_len = service ? strlen(service)+1 : 0;
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_ADDRINFO;
+    req->header.length = sizeof(addrinfo_request_t) + req->node_len + req->service_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    if (!(req->hints_is_null = !hints)) {
+        req->ai_flags = hints->ai_flags;
+        req->ai_family = hints->ai_family;
+        req->ai_socktype = hints->ai_socktype;
+        req->ai_protocol = hints->ai_protocol;
+    }
+
+    if (node)
+        strcpy((char*) req + sizeof(addrinfo_request_t), node);
+
+    if (service)
+        strcpy((char*) req + sizeof(addrinfo_request_t) + req->node_len, service);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_ADDRINFO);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    *ret_res = q->addrinfo;
+    q->addrinfo = NULL;
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv) {
+    nameinfo_request_t data[BUFSIZE/sizeof(nameinfo_request_t) + 1];
+    nameinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(sa);
+    assert(salen > 0);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(nameinfo_request_t));
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_NAMEINFO;
+    req->header.length = sizeof(nameinfo_request_t) + salen;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->flags = flags;
+    req->sockaddr_len = salen;
+    req->gethost = gethost;
+    req->getserv = getserv;
+
+    memcpy((uint8_t*) req + sizeof(nameinfo_request_t), sa, salen);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_NAMEINFO);
+    assert(!ret_host || hostlen);
+    assert(!ret_serv || servlen);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    if (ret_host && q->host) {
+        strncpy(ret_host, q->host, hostlen);
+        ret_host[hostlen-1] = 0;
+    }
+
+    if (ret_serv && q->serv) {
+        strncpy(ret_serv, q->serv, servlen);
+        ret_serv[servlen-1] = 0;
+    }
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+static _g_asyncns_query_t * _g_asyncns_res(_g_asyncns_t *asyncns, query_type_t qtype, const char *dname, int class, int type) {
+    res_request_t data[BUFSIZE/sizeof(res_request_t) + 1];
+    res_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(dname);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(res_request_t));
+
+    req->dname_len = strlen(dname) + 1;
+
+    req->header.id = q->id;
+    req->header.type = q->type = qtype;
+    req->header.length = sizeof(res_request_t) + req->dname_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->class = class;
+    req->type = type;
+
+    strcpy((char*) req + sizeof(res_request_t), dname);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_QUERY, dname, class, type);
+}
+
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_SEARCH, dname, class, type);
+}
+
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+    assert(answer);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return -ECHILD;
+    }
+
+    if (!q->done) {
+        errno = EAGAIN;
+        return -EAGAIN;
+    }
+
+    *answer = (unsigned char *)q->serv;
+    q->serv = NULL;
+
+    ret = q->ret;
+
+    if (ret < 0) {
+        errno = q->_errno;
+        h_errno = q->_h_errno;
+    }
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret < 0 ? -errno : ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->done_head;
+}
+
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->n_queries;
+}
+
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q) {
+    int i;
+    int saved_errno = errno;
+
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(asyncns->n_queries > 0);
+
+    if (q->done) {
+
+        if (q->done_prev)
+            q->done_prev->done_next = q->done_next;
+        else
+            asyncns->done_head = q->done_next;
+
+        if (q->done_next)
+            q->done_next->done_prev = q->done_prev;
+        else
+            asyncns->done_tail = q->done_prev;
+    }
+
+    i = q->id % MAX_QUERIES;
+    assert(asyncns->queries[i] == q);
+    asyncns->queries[i] = NULL;
+
+    _g_asyncns_freeaddrinfo(q->addrinfo);
+    free(q->host);
+    free(q->serv);
+
+    asyncns->n_queries--;
+    free(q);
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai) {
+    int saved_errno = errno;
+
+    while (ai) {
+        struct addrinfo *next = ai->ai_next;
+
+        free(ai->ai_addr);
+        free(ai->ai_canonname);
+        free(ai);
+
+        ai = next;
+    }
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeanswer(unsigned char *answer) {
+    int saved_errno = errno;
+
+    if (!answer)
+        return;
+
+    /* Please note that this function is new in libasyncns 0.4. In
+     * older versions you were supposed to free the answer directly
+     * with free(). Hence, if this function is changed to do more than
+     * just a simple free() this must be considered ABI/API breakage! */
+
+    free(answer);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q) {
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+
+    return q->done;
+}
+
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    q->userdata = userdata;
+}
+
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    return q->userdata;
+}
diff --git a/gio/libasyncns/asyncns.h b/gio/libasyncns/asyncns.h
new file mode 100644
index 0000000..b3d49ff
--- /dev/null
+++ b/gio/libasyncns/asyncns.h
@@ -0,0 +1,163 @@
+#ifndef fooasyncnshfoo
+#define fooasyncnshfoo
+
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+/** \mainpage
+ *
+ * \section moo Method of operation
+ *
+ * To use libasyncns allocate an _g_asyncns_t object with
+ * _g_asyncns_new(). This will spawn a number of worker threads (or processes, depending on what is available) which
+ * are subsequently used to process the queries the controlling
+ * program issues via _g_asyncns_getaddrinfo() and
+ * _g_asyncns_getnameinfo(). Use _g_asyncns_free() to shut down the worker
+ * threads/processes.
+ *
+ * Since libasyncns may fork off new processes you have to make sure that
+ * your program is not irritated by spurious SIGCHLD signals.
+ */
+
+/** \example asyncns-test.c
+ * An example program */
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/** An opaque libasyncns session structure */
+typedef struct asyncns _g_asyncns_t;
+
+/** An opaque libasyncns query structure */
+typedef struct _g_asyncns_query _g_asyncns_query_t;
+
+/** Allocate a new libasyncns session with n_proc worker processes/threads */
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc);
+
+/** Free a libasyncns session. This destroys all attached
+ * _g_asyncns_query_t objects automatically */
+void _g_asyncns_free(_g_asyncns_t *asyncns);
+
+/** Return the UNIX file descriptor to select() for readability
+ * on. Use this function to integrate libasyncns with your custom main
+ * loop. */
+int _g_asyncns_fd(_g_asyncns_t *asyncns);
+
+/** Process pending responses. After this function is called you can
+ * get the next completed query object(s) using _g_asyncns_getnext(). If
+ * block is non-zero wait until at least one response has been
+ * processed. If block is zero, process all pending responses and
+ * return. */
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block);
+
+/** Issue a name to address query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getaddrinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getaddrinfo_done().*/
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints);
+
+/** Retrieve the results of a preceding _g_asyncns_getaddrinfo()
+ * call. Returns a addrinfo structure and a return value compatible
+ * with libc's getaddrinfo(3). The query object q is destroyed by this
+ * call and may not be used any further. Make sure to free the
+ * returned addrinfo structure with _g_asyncns_freeaddrinfo() and not
+ * libc's freeaddrinfo(3)! If the query is not completed yet EAI_AGAIN
+ * is returned.*/
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res);
+
+/** Issue an address to name query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getnameinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getnameinfo_done(). Set gethost (resp. getserv) to non-zero
+ * if you want to query the hostname (resp. the service name). */
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv);
+
+/** Retrieve the results of a preceding _g_asyncns_getnameinfo()
+ * call. Returns the hostname and the service name in ret_host and
+ * ret_serv. The query object q is destroyed by this call and may not
+ * be used any further. If the query is not completed yet EAI_AGAIN is
+ * returned. */
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen);
+
+/** Issue a resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_query(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Issue an resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_search(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Retrieve the results of a preceding _g_asyncns_res_query() or
+ * _g_asyncns_res_search call.  The query object q is destroyed by this
+ * call and may not be used any further. Returns a pointer to the
+ * answer of the res_query call. If the query is not completed yet
+ * -EAGAIN is returned, on failure -errno is returned, otherwise the
+ * length of answer is returned. Make sure to free the answer is a
+ * call to _g_asyncns_freeanswer(). */
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer);
+
+/** Return the next completed query object. If no query has been
+ * completed yet, return NULL. Please note that you need to run
+ * _g_asyncns_wait() before this function will return sensible data.  */
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns);
+
+/** Return the number of query objects (completed or not) attached to
+ * this session */
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns);
+
+/** Cancel a currently running query. q is is destroyed by this call
+ * and may not be used any futher. */
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q);
+
+/** Free the addrinfo structure as returned by
+ * _g_asyncns_getaddrinfo_done(). Make sure to use this functions instead
+ * of the libc's freeaddrinfo()! */
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai);
+
+/** Free the answer data as returned by _g_asyncns_res_done().*/
+void _g_asyncns_freeanswer(unsigned char *answer);
+
+/** Returns non-zero when the query operation specified by q has been completed */
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q);
+
+/** Assign some opaque userdata with a query object */
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata);
+
+/** Return userdata assigned to a query object. Use
+ * _g_asyncns_setuserdata() to set this data. If no data has been set
+ * prior to this call it returns NULL. */
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gio/libasyncns/g-asyncns.h b/gio/libasyncns/g-asyncns.h
new file mode 100644
index 0000000..a40fadb
--- /dev/null
+++ b/gio/libasyncns/g-asyncns.h
@@ -0,0 +1,28 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_ASYNCNS_H__
+
+#include "config.h"
+
+#define _GNU_SOURCE
+#undef HAVE_PTHREAD
+
+#include "asyncns.h"
+
+#endif
diff --git a/gio/libasyncns/update.sh b/gio/libasyncns/update.sh
new file mode 100644
index 0000000..4c43ca5
--- /dev/null
+++ b/gio/libasyncns/update.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+if test $# = 1 ; then 
+  ORIGINAL=$1
+else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+if test -f $ORIGINAL/libasyncns/asyncns.c ; then : ; else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+for i in asyncns.c asyncns.h ; do
+  sed -e 's/\([^a-z]\)asyncns_/\1_g_asyncns_/g' \
+      -e 's/^asyncns_/_g_asyncns_/' \
+      -e 's/<config\.h>/"g-asyncns\.h"/' \
+    $ORIGINAL/libasyncns/$i > $i
+done
diff --git a/gio/pltcheck.sh b/gio/pltcheck.sh
index e09a587..be29be8 100755
--- a/gio/pltcheck.sh
+++ b/gio/pltcheck.sh
@@ -9,7 +9,7 @@ if ! which readelf 2>/dev/null >/dev/null; then
 	exit 0
 fi
 
-SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_build_filename\|\<g_byte_array\|\<g_child_watch\|\<g_convert\|\<g_dir_\|\<g_error_\|\<g_clear_error\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_\|\<g_enum_\|\<g_flags_\|\<g_checksum\|\<g_io_add_watch\|\<g_bit_\|\<g_poll\|\<g_boxed'
+SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_bit_\|\<g_boxed\|\<g_build_filename\|\<g_byte_array\|\<g_checksum\|\<g_child_watch\|\<g_clear_error\|\<g_convert\|\<g_dir_\|\<g_enum_\|\<g_error_\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_flags_\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_hostname_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_add_watch\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_poll\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_random_int_range\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_'
 
 for so in .libs/lib*.so; do
 	echo Checking $so for local PLT entries
diff --git a/gio/tests/Makefile.am b/gio/tests/Makefile.am
index 70a9ae8..eddaaa2 100644
--- a/gio/tests/Makefile.am
+++ b/gio/tests/Makefile.am
@@ -9,7 +9,7 @@ INCLUDES = 			\
 	-I$(top_srcdir)/gio 	\
 	$(GLIB_DEBUG_FLAGS)
 
-noinst_PROGRAMS = $(TEST_PROGS)
+noinst_PROGRAMS = $(TEST_PROGS) $(SAMPLE_PROGS)
 progs_ldadd     = 					\
 	$(top_builddir)/glib/libglib-2.0.la 		\
 	$(top_builddir)/gobject/libgobject-2.0.la	\
@@ -29,6 +29,8 @@ TEST_PROGS +=	 		\
 	filter-streams		\
 	simple-async-result
 
+SAMPLE_PROGS = resolver
+
 if OS_UNIX
 TEST_PROGS += live-g-file unix-streams desktop-app-info
 endif
@@ -76,4 +78,8 @@ sleepy_stream_LDADD		= $(progs_ldadd)
 filter_streams_SOURCES		= filter-streams.c
 filter_streams_LDADD		= $(progs_ldadd)
 
+resolver_SOURCES	  = resolver.c
+resolver_LDADD		  = $(progs_ldadd) \
+	$(top_builddir)/gthread/libgthread-2.0.la
+
 DISTCLEAN_FILES = applications/mimeinfo.cache
diff --git a/gio/tests/resolver.c b/gio/tests/resolver.c
new file mode 100644
index 0000000..4f0b71b
--- /dev/null
+++ b/gio/tests/resolver.c
@@ -0,0 +1,502 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <gio/gio.h>
+
+static GResolver *resolver;
+static GCancellable *cancellable;
+static GMainLoop *loop;
+static int nlookups = 0;
+
+static void
+usage (void)
+{
+	fprintf (stderr, "Usage: resolver [-t] [-s] [hostname | IP | service/protocol/domain ] ...\n");
+	fprintf (stderr, "       resolver [-t] [-s] -c [hostname | IP | service/protocol/domain ]\n");
+	fprintf (stderr, "       Use -t to enable threading.\n");
+	fprintf (stderr, "       Use -s to do synchronous lookups.\n");
+	fprintf (stderr, "       Both together will result in simultaneous lookups in multiple threads\n");
+	fprintf (stderr, "       Use -c (and only a single resolvable argument) to test GSocketConnectable.\n");
+	exit (1);
+}
+
+G_LOCK_DEFINE_STATIC (response);
+
+static void
+done_lookup (void)
+{
+  nlookups--;
+  if (nlookups == 0)
+    {
+      /* In the sync case we need to make sure we don't call
+       * g_main_loop_quit before the loop is actually running...
+       */
+      g_idle_add ((GSourceFunc)g_main_loop_quit, loop);
+    }
+}
+
+static void
+print_resolved_name (const char *phys,
+                     char       *name,
+                     GError     *error)
+{
+  G_LOCK (response);
+  printf ("Address: %s\n", phys);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      printf ("Name:    %s\n", name);
+      g_free (name);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_addresses (const char *name,
+                          GList      *addresses,
+			  GError     *error)
+{
+  char *phys;
+  GList *a;
+
+  G_LOCK (response);
+  printf ("Name:    %s\n", name);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (a = addresses; a; a = a->next)
+	{
+	  phys = g_inet_address_to_string (a->data);
+	  printf ("Address: %s\n", phys);
+	  g_free (phys);
+          g_object_unref (a->data);
+	}
+      g_list_free (addresses);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_service (const char *service,
+                        GList      *targets,
+			GError     *error)
+{
+  GList *t;  
+
+  G_LOCK (response);
+  printf ("Service: %s\n", service);
+  if (error)
+    {
+      printf ("Error: %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (t = targets; t; t = t->next)
+	{
+	  printf ("%s:%u (pri %u, weight %u)\n",
+		  g_srv_target_get_hostname (t->data),
+		  g_srv_target_get_port (t->data),
+		  g_srv_target_get_priority (t->data),
+		  g_srv_target_get_weight (t->data));
+          g_srv_target_free (t->data);
+	}
+      g_list_free (targets);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+lookup_one_sync (const char *arg)
+{
+  GError *error = NULL;
+
+  if (strchr (arg, '/'))
+    {
+      GList *targets;
+      /* service/protocol/domain */
+      char **parts = g_strsplit (arg, "/", 3);
+
+      if (!parts || !parts[2])
+	usage ();
+
+      targets = g_resolver_lookup_service (resolver,
+                                           parts[0], parts[1], parts[2],
+                                           cancellable, &error);
+      print_resolved_service (arg, targets, error);
+    }
+  else if (g_hostname_is_ip_address (arg))
+    {
+      GInetAddress *addr = g_inet_address_new_from_string (arg);
+      char *name;
+
+      name = g_resolver_lookup_by_address (resolver, addr, cancellable, &error);
+      print_resolved_name (arg, name, error);
+      g_object_unref (addr);
+    }
+  else
+    {
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver, arg, cancellable, &error);
+      print_resolved_addresses (arg, addresses, error);
+    }
+}
+
+static gpointer
+lookup_thread (gpointer arg)
+{
+  lookup_one_sync (arg);
+  return NULL;
+}
+
+static void
+start_threaded_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    g_thread_create (lookup_thread, argv[i], FALSE, NULL);
+}
+
+static void
+start_sync_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    lookup_one_sync (argv[i]);
+}
+
+static void
+lookup_by_addr_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *phys = user_data;
+  GError *error = NULL;
+  char *name;
+
+  name = g_resolver_lookup_by_address_finish (resolver, result, &error);
+  print_resolved_name (phys, name, error);
+}
+
+static void
+lookup_by_name_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *name = user_data;
+  GError *error = NULL;
+  GList *addresses;
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  print_resolved_addresses (name, addresses, error);
+}
+
+static void
+lookup_service_callback (GObject *source, GAsyncResult *result,
+			 gpointer user_data)
+{
+  const char *service = user_data;
+  GError *error = NULL;
+  GList *targets;
+
+  targets = g_resolver_lookup_service_finish (resolver, result, &error);
+  print_resolved_service (service, targets, error);
+}
+
+static void
+start_async_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    {
+      if (strchr (argv[i], '/'))
+	{
+	  /* service/protocol/domain */
+	  char **parts = g_strsplit (argv[i], "/", 3);
+
+	  if (!parts || !parts[2])
+	    usage ();
+
+	  g_resolver_lookup_service_async (resolver,
+					   parts[0], parts[1], parts[2],
+					   cancellable,
+					   lookup_service_callback, argv[i]);
+	}
+      else if (g_hostname_is_ip_address (argv[i]))
+	{
+          GInetAddress *addr = g_inet_address_new_from_string (argv[i]);
+
+	  g_resolver_lookup_by_address_async (resolver, addr, cancellable,
+                                              lookup_by_addr_callback, argv[i]);
+	  g_object_unref (addr);
+	}
+      else
+	{
+	  g_resolver_lookup_by_name_async (resolver, argv[i], cancellable,
+                                           lookup_by_name_callback,
+                                           argv[i]);
+	}
+    }
+}
+
+static void
+print_connectable_sockaddr (GSocketAddress *sockaddr,
+                            GError         *error)
+{
+  char *phys;
+
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else if (!G_IS_INET_SOCKET_ADDRESS (sockaddr))
+    {
+      printf ("Error:   Unexpected sockaddr type '%s'\n", g_type_name_from_instance ((GTypeInstance *)sockaddr));
+      g_object_unref (sockaddr);
+    }
+  else
+    {
+      GInetSocketAddress *isa = G_INET_SOCKET_ADDRESS (sockaddr);
+      phys = g_inet_address_to_string (g_inet_socket_address_get_address (isa));
+      printf ("Address: %s%s%s:%d\n",
+              strchr (phys, ':') ? "[" : "", phys, strchr (phys, ':') ? "]" : "",
+              g_inet_socket_address_get_port (isa));
+      g_free (phys);
+      g_object_unref (sockaddr);
+    }
+}
+
+static void
+do_sync_connectable (GSocketConnectable *connectable)
+{
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  while ((sockaddr = g_socket_connectable_get_next (connectable, cancellable, &error)))
+    print_connectable_sockaddr (sockaddr, error);
+
+  g_object_unref (connectable);
+  done_lookup ();
+}
+
+static void do_async_connectable (GSocketConnectable *connectable);
+
+static void
+got_next_async (GObject *source, GAsyncResult *result, gpointer user_data)
+{
+  GSocketConnectable *connectable = G_SOCKET_CONNECTABLE (source);
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  sockaddr = g_socket_connectable_get_next_finish (connectable, result, &error);
+  if (sockaddr || error)
+    print_connectable_sockaddr (sockaddr, error);
+  if (sockaddr)
+    do_async_connectable (connectable);
+  else
+    {
+      g_object_unref (connectable);
+      done_lookup ();
+    }
+}
+
+static void
+do_async_connectable (GSocketConnectable *connectable)
+{
+  g_socket_connectable_get_next_async (connectable, cancellable,
+                                       got_next_async, NULL);
+}
+
+static void
+do_connectable (const char *arg, gboolean synchronous)
+{
+  char **parts;
+  GSocketConnectable *connectable;
+
+  if (strchr (arg, '/'))
+    {
+      /* service/protocol/domain */
+      parts = g_strsplit (arg, "/", 3);
+      if (!parts || !parts[2])
+	usage ();
+
+      connectable = g_network_service_new (parts[0], parts[1], parts[2]);
+    }
+  else
+    {
+      guint16 port;
+
+      parts = g_strsplit (arg, ":", 2);
+      if (parts && parts[1])
+	{
+	  arg = parts[0];
+	  port = strtoul (parts[1], NULL, 10);
+	}
+      else
+	port = 0;
+
+      if (g_hostname_is_ip_address (arg))
+	{
+	  GInetAddress *addr = g_inet_address_new_from_string (arg);
+	  GSocketAddress *sockaddr = g_inet_socket_address_new (addr, port);
+
+	  g_object_unref (addr);
+	  connectable = G_SOCKET_CONNECTABLE (sockaddr);
+	}
+      else
+        connectable = g_network_address_new (arg, port);
+    }
+
+  if (synchronous)
+    do_sync_connectable (connectable);
+  else
+    do_async_connectable (connectable);
+}
+
+#ifdef G_OS_UNIX
+static int cancel_fds[2];
+
+static void
+interrupted (int sig)
+{
+  signal (SIGINT, SIG_DFL);
+  write (cancel_fds[1], "x", 1);
+}
+
+static gboolean
+async_cancel (GIOChannel *source, GIOCondition cond, gpointer cancellable)
+{
+  g_cancellable_cancel (cancellable);
+  return FALSE;
+}
+#endif
+
+int
+main (int argc, char **argv)
+{
+  gboolean threaded = FALSE, synchronous = FALSE;
+  gboolean use_connectable = FALSE;
+#ifdef G_OS_UNIX
+  GIOChannel *chan;
+  guint watch;
+#endif
+
+  /* We can't use GOptionContext because we use the arguments to
+   * decide whether or not to call g_thread_init().
+   */
+  while (argc >= 2 && argv[1][0] == '-')
+    {
+      if (!strcmp (argv[1], "-t"))
+        {
+          g_thread_init (NULL);
+          threaded = TRUE;
+        }
+      else if (!strcmp (argv[1], "-s"))
+        synchronous = TRUE;
+      else if (!strcmp (argv[1], "-c"))
+        use_connectable = TRUE;
+      else
+        usage ();
+
+      argv++;
+      argc--;
+    }
+  g_type_init ();
+
+  if (argc < 2 || (argc > 2 && use_connectable))
+    usage ();
+
+  resolver = g_resolver_get_default ();
+
+  cancellable = g_cancellable_new ();
+
+#ifdef G_OS_UNIX
+  /* Set up cancellation; we want to cancel if the user ^C's the
+   * program, but we can't cancel directly from an interrupt.
+   */
+  signal (SIGINT, interrupted);
+
+  if (pipe (cancel_fds) == -1)
+    {
+      perror ("pipe");
+      exit (1);
+    }
+  chan = g_io_channel_unix_new (cancel_fds[0]);
+  watch = g_io_add_watch (chan, G_IO_IN, async_cancel, cancellable);
+  g_io_channel_unref (chan);
+#endif
+
+  nlookups = argc - 1;
+  loop = g_main_loop_new (NULL, TRUE);
+
+  if (use_connectable)
+    do_connectable (argv[1], synchronous);
+  else
+    {
+      if (threaded && synchronous)
+        start_threaded_lookups (argv + 1, argc - 1);
+      else if (synchronous)
+        start_sync_lookups (argv + 1, argc - 1);
+      else
+        start_async_lookups (argv + 1, argc - 1);
+    }
+
+  g_main_run (loop);
+  g_main_loop_unref (loop);
+
+#ifdef G_OS_UNIX
+  g_source_remove (watch);
+#endif
+  g_object_unref (cancellable);
+
+  return 0;
+}
diff --git a/glib/Makefile.am b/glib/Makefile.am
index c6f20bb..eb220e6 100644
--- a/glib/Makefile.am
+++ b/glib/Makefile.am
@@ -116,6 +116,7 @@ libglib_2_0_la_SOURCES = 	\
 	gfileutils.c		\
 	ghash.c			\
 	ghook.c			\
+	ghostutils.c		\
 	giochannel.c    	\
 	gkeyfile.c        	\
 	glibintl.h		\
@@ -199,6 +200,7 @@ glibsubinclude_HEADERS =   \
 	gfileutils.h	\
 	ghash.h		\
 	ghook.h		\
+	ghostutils.h	\
 	gi18n.h		\
 	gi18n-lib.h	\
 	giochannel.h	\
diff --git a/glib/ghostutils.c b/glib/ghostutils.c
new file mode 100644
index 0000000..63e1dff
--- /dev/null
+++ b/glib/ghostutils.c
@@ -0,0 +1,758 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include "glib.h"
+#include "glibintl.h"
+
+#include <string.h>
+
+#include "galias.h"
+
+/**
+ * SECTION:ghostutils
+ * @short_description: Internet hostname utilities
+ * @include: glib.h
+ *
+ * Functions for manipulating internet hostnames; in particular, for
+ * converting between Unicode and ASCII-encoded forms of
+ * Internationalized Domain Names (IDNs).
+ *
+ * The <ulink
+ * link="http://www.ietf.org/rfc/rfc3490.txt">Internationalized Domain
+ * Names for Applications (IDNA)</ulink> standards allow for the use
+ * of Unicode domain names in applications, while providing
+ * backward-compatibility with the old ASCII-only DNS, by defining an
+ * ASCII-Compatible Encoding of any given Unicode name, which can be
+ * used with non-IDN-aware applications and protocols. (For example,
+ * "Παν語.org" maps to "xn--4wa8awb4637h.org".)
+ **/
+
+#define IDNA_ACE_PREFIX     "xn--"
+#define IDNA_ACE_PREFIX_LEN 4
+
+/* Punycode constants, from RFC 3492. */
+
+#define PUNYCODE_BASE          36
+#define PUNYCODE_TMIN           1
+#define PUNYCODE_TMAX          26
+#define PUNYCODE_SKEW          38
+#define PUNYCODE_DAMP         700
+#define PUNYCODE_INITIAL_BIAS  72
+#define PUNYCODE_INITIAL_N   0x80
+
+#define PUNYCODE_IS_BASIC(cp) ((guint)(cp) < 0x80)
+
+/* Encode/decode a single base-36 digit */
+static inline gchar
+encode_digit (guint dig)
+{
+  if (dig < 26)
+    return dig + 'a';
+  else
+    return dig - 26 + '0';
+}
+
+static inline guint
+decode_digit (gchar dig)
+{
+  if (dig >= 'A' && dig <= 'Z')
+    return dig - 'A';
+  else if (dig >= 'a' && dig <= 'z')
+    return dig - 'a';
+  else if (dig >= '0' && dig <= '9')
+    return dig - '0' + 26;
+  else
+    return G_MAXUINT;
+}
+
+/* Punycode bias adaptation algorithm, RFC 3492 section 6.1 */
+static guint
+adapt (guint    delta,
+       guint    numpoints,
+       gboolean firsttime)
+{
+  guint k;
+
+  delta = firsttime ? delta / PUNYCODE_DAMP : delta / 2;
+  delta += delta / numpoints;
+
+  k = 0;
+  while (delta > ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2)
+    {
+      delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
+      k += PUNYCODE_BASE;
+    }
+
+  return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
+	      (delta + PUNYCODE_SKEW));
+}
+
+/* Punycode encoder, RFC 3492 section 6.3. The algorithm is
+ * sufficiently bizarre that it's not really worth trying to explain
+ * here.
+ */
+static gboolean
+punycode_encode (const gchar *input_utf8,
+                 gsize        input_utf8_length,
+		 GString     *output)
+{
+  guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
+  gunichar n, m, *input;
+  glong input_length;
+  gboolean success = FALSE;
+
+  /* Convert from UTF-8 to Unicode code points */
+  input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
+			  &input_length, NULL);
+  if (!input)
+    return FALSE;
+
+  /* Copy basic chars */
+  for (j = num_basic_chars = 0; j < input_length; j++)
+    {
+      if (PUNYCODE_IS_BASIC (input[j]))
+	{
+	  g_string_append_c (output, g_ascii_tolower (input[j]));
+	  num_basic_chars++;
+	}
+    }
+  if (num_basic_chars)
+    g_string_append_c (output, '-');
+
+  handled_chars = num_basic_chars;
+
+  /* Encode non-basic chars */
+  delta = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+  n = PUNYCODE_INITIAL_N;
+  while (handled_chars < input_length)
+    {
+      /* let m = the minimum {non-basic} code point >= n in the input */
+      for (m = G_MAXUINT, j = 0; j < input_length; j++)
+	{
+	  if (input[j] >= n && input[j] < m)
+	    m = input[j];
+	}
+
+      if (m - n > (G_MAXUINT - delta) / (handled_chars + 1))
+	goto fail;
+      delta += (m - n) * (handled_chars + 1);
+      n = m;
+
+      for (j = 0; j < input_length; j++)
+	{
+	  if (input[j] < n)
+	    {
+	      if (++delta == 0)
+		goto fail;
+	    }
+	  else if (input[j] == n)
+	    {
+	      q = delta;
+	      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+		{
+		  if (k <= bias)
+		    t = PUNYCODE_TMIN;
+		  else if (k >= bias + PUNYCODE_TMAX)
+		    t = PUNYCODE_TMAX;
+		  else
+		    t = k - bias;
+		  if (q < t)
+		    break;
+		  digit = t + (q - t) % (PUNYCODE_BASE - t);
+		  g_string_append_c (output, encode_digit (digit));
+		  q = (q - t) / (PUNYCODE_BASE - t);
+		}
+
+	      g_string_append_c (output, encode_digit (q));
+	      bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);
+	      delta = 0;
+	      handled_chars++;
+	    }
+	}
+
+      delta++;
+      n++;
+    }
+
+  success = TRUE;
+
+ fail:
+  g_free (input);
+  return success;
+}
+
+/* From RFC 3454, Table B.1 */
+#define idna_is_junk(ch) ((ch) == 0x00AD || (ch) == 0x1806 || (ch) == 0x200B || (ch) == 0x2060 || (ch) == 0xFEFF || (ch) == 0x034F || (ch) == 0x180B || (ch) == 0x180C || (ch) == 0x180D || (ch) == 0x200C || (ch) == 0x200D || ((ch) >= 0xFE00 && (ch) <= 0xFE0F))
+
+/* Scan @str for "junk" and return a cleaned-up string if any junk
+ * is found. Else return %NULL.
+ */
+static gchar *
+remove_junk (const gchar *str,
+             gint         len)
+{
+  GString *cleaned = NULL;
+  const gchar *p;
+  gunichar ch;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      ch = g_utf8_get_char (p);
+      if (idna_is_junk (ch))
+	{
+	  if (!cleaned)
+	    {
+	      cleaned = g_string_new (NULL);
+	      g_string_append_len (cleaned, str, p - str);
+	    }
+	}
+      else if (cleaned)
+	g_string_append_unichar (cleaned, ch);
+    }
+
+  if (cleaned)
+    return g_string_free (cleaned, FALSE);
+  else
+    return NULL;
+}
+
+static inline gboolean
+contains_uppercase_letters (const gchar *str,
+                            gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      if (g_unichar_isupper (g_utf8_get_char (p)))
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static inline gboolean
+contains_non_ascii (const gchar *str,
+                    gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p++)
+    {
+      if ((guchar)*p > 0x80)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+/* RFC 3454, Appendix C. ish. */
+static inline gboolean
+idna_is_prohibited (gunichar ch)
+{
+  switch (g_unichar_type (ch))
+    {
+    case G_UNICODE_CONTROL:
+    case G_UNICODE_FORMAT:
+    case G_UNICODE_UNASSIGNED:
+    case G_UNICODE_PRIVATE_USE:
+    case G_UNICODE_SURROGATE:
+    case G_UNICODE_LINE_SEPARATOR:
+    case G_UNICODE_PARAGRAPH_SEPARATOR:
+    case G_UNICODE_SPACE_SEPARATOR:
+      return TRUE;
+
+    case G_UNICODE_OTHER_SYMBOL:
+      if (ch == 0xFFFC || ch == 0xFFFD ||
+	  (ch >= 0x2FF0 && ch <= 0x2FFB))
+	return TRUE;
+      return FALSE;
+
+    case G_UNICODE_NON_SPACING_MARK:
+      if (ch == 0x0340 || ch == 0x0341)
+	return TRUE;
+      return FALSE;
+
+    default:
+      return FALSE;
+    }
+}
+
+/* RFC 3491 IDN cleanup algorithm. */
+static gchar *
+nameprep (const gchar *hostname,
+          gint         len)
+{
+  gchar *name, *tmp = NULL, *p;
+
+  /* It would be nice if we could do this without repeatedly
+   * allocating strings and converting back and forth between
+   * gunichars and UTF-8... The code does at least avoid doing most of
+   * the sub-operations when they would just be equivalent to a
+   * g_strdup().
+   */
+
+  /* Remove presentation-only characters */
+  name = remove_junk (hostname, len);
+  if (name)
+    {
+      tmp = name;
+      len = -1;
+    }
+  else
+    name = (gchar *)hostname;
+
+  /* Convert to lowercase */
+  if (contains_uppercase_letters (name, len))
+    {
+      name = g_utf8_strdown (name, len);
+      g_free (tmp);
+      tmp = name;
+      len = -1;
+    }
+
+  /* If there are no UTF8 characters, we're done. */
+  if (!contains_non_ascii (name, len))
+    {
+      if (name == (gchar *)hostname)
+        return len == -1 ? g_strdup (hostname) : g_strndup (hostname, len);
+      else
+        return name;
+    }
+
+  /* Normalize */
+  name = g_utf8_normalize (name, len, G_NORMALIZE_NFKC);
+  g_free (tmp);
+  tmp = name;
+
+  /* KC normalization may have created more capital letters (eg,
+   * angstrom -> capital A with ring). So we have to lowercasify a
+   * second time. (This is more-or-less how the nameprep algorithm
+   * does it. If tolower(nfkc(tolower(X))) is guaranteed to be the
+   * same as tolower(nfkc(X)), then we could skip the first tolower,
+   * but I'm not sure it is.)
+   */
+  if (contains_uppercase_letters (name, -1))
+    {
+      name = g_utf8_strdown (name, -1);
+      g_free (tmp);
+      tmp = name;
+    }
+
+  /* Check for prohibited characters */
+  for (p = name; *p; p = g_utf8_next_char (p))
+    {
+      if (idna_is_prohibited (g_utf8_get_char (p)))
+	{
+	  name = NULL;
+          g_free (tmp);
+	  goto done;
+	}
+    }
+
+  /* FIXME: We're supposed to verify certain constraints on bidi
+   * characters, but glib does not appear to have that information.
+   */
+
+ done:
+  return name;
+}
+
+/**
+ * g_hostname_to_ascii:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical ASCII form; an ASCII-only
+ * string containing no uppercase letters and not ending with a
+ * trailing dot.
+ *
+ * Return value: an ASCII hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_ascii (const gchar *hostname)
+{
+  gchar *name, *label, *p;
+  GString *out;
+  gssize llen, oldlen;
+  gboolean unicode;
+
+  out = g_string_new (NULL);
+  label = name = nameprep (hostname, -1);
+
+  do
+    {
+      unicode = FALSE;
+      for (p = label; *p && *p != '.'; p++)
+	{
+	  if ((guchar)*p > 0x80)
+	    unicode = TRUE;
+	}
+
+      oldlen = out->len;
+      llen = p - label;
+      if (unicode)
+	{
+          if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+            goto fail;
+
+	  g_string_append (out, IDNA_ACE_PREFIX);
+	  if (!punycode_encode (label, llen, out))
+	    goto fail;
+	}
+      else
+        g_string_append_len (out, label, llen);
+
+      if (out->len - oldlen > 63)
+	goto fail;
+
+      label += llen;
+      if (*label && *++label)
+        g_string_append_c (out, '.');
+    }
+  while (*label);
+
+  g_free (name);
+  return g_string_free (out, FALSE);
+
+ fail:
+  g_free (name);
+  g_string_free (out, TRUE);
+  return NULL;
+}
+
+/**
+ * g_hostname_is_non_ascii:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains Unicode characters. If this returns
+ * %TRUE, you need to encode the hostname with g_hostname_to_ascii()
+ * before using it in non-IDN-aware contexts.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any non-ASCII characters
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_non_ascii (const gchar *hostname)
+{
+  return contains_non_ascii (hostname, -1);
+}
+
+/* Punycode decoder, RFC 3492 section 6.2. As with punycode_encode(),
+ * read the RFC if you want to understand what this is actually doing.
+ */
+static gboolean
+punycode_decode (const gchar *input,
+                 gsize        input_length,
+                 GString     *output)
+{
+  GArray *output_chars;
+  gunichar n;
+  guint i, bias;
+  guint oldi, w, k, digit, t;
+  const gchar *split;
+
+  n = PUNYCODE_INITIAL_N;
+  i = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+
+  split = input + input_length - 1;
+  while (split > input && *split != '-')
+    split--;
+  if (split > input)
+    {
+      output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
+					split - input);
+      input_length -= (split - input) + 1;
+      while (input < split)
+	{
+	  gunichar ch = (gunichar)*input++;
+	  if (!PUNYCODE_IS_BASIC (ch))
+	    goto fail;
+	  g_array_append_val (output_chars, ch);
+	}
+      input++;
+    }
+  else
+    output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
+
+  while (input_length)
+    {
+      oldi = i;
+      w = 1;
+      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+	{
+	  if (!input_length--)
+	    goto fail;
+	  digit = decode_digit (*input++);
+	  if (digit >= PUNYCODE_BASE)
+	    goto fail;
+	  if (digit > (G_MAXUINT - i) / w)
+	    goto fail;
+	  i += digit * w;
+	  if (k <= bias)
+	    t = PUNYCODE_TMIN;
+	  else if (k >= bias + PUNYCODE_TMAX)
+	    t = PUNYCODE_TMAX;
+	  else
+	    t = k - bias;
+	  if (digit < t)
+	    break;
+	  if (w > G_MAXUINT / (PUNYCODE_BASE - t))
+	    goto fail;
+	  w *= (PUNYCODE_BASE - t);
+	}
+
+      bias = adapt (i - oldi, output_chars->len + 1, oldi == 0);
+
+      if (i / (output_chars->len + 1) > G_MAXUINT - n)
+	goto fail;
+      n += i / (output_chars->len + 1);
+      i %= (output_chars->len + 1);
+
+      g_array_insert_val (output_chars, i++, n);
+    }
+
+  for (i = 0; i < output_chars->len; i++)
+    g_string_append_unichar (output, g_array_index (output_chars, gunichar, i));
+  g_array_free (output_chars, TRUE);
+  return TRUE;
+
+ fail:
+  g_array_free (output_chars, TRUE);
+  return FALSE;
+}
+
+/**
+ * g_hostname_to_unicode:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical presentation form; a UTF-8
+ * string in Unicode normalization form C, containing no uppercase
+ * letters, no forbidden characters, and no ASCII-encoded segments,
+ * and not ending with a trailing dot.
+ *
+ * Of course if @hostname is not an internationalized hostname, then
+ * the canonical presentation form will be entirely ASCII.
+ *
+ * Return value: a UTF-8 hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_unicode (const gchar *hostname)
+{
+  GString *out;
+  gssize llen;
+
+  out = g_string_new (NULL);
+
+  do
+    {
+      llen = strcspn (hostname, ".");
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	{
+	  hostname += IDNA_ACE_PREFIX_LEN;
+	  llen -= IDNA_ACE_PREFIX_LEN;
+	  if (!punycode_decode (hostname, llen, out))
+	    {
+	      g_string_free (out, TRUE);
+	      return NULL;
+	    }
+	}
+      else
+        {
+          gchar *canonicalized = nameprep (hostname, llen);
+
+          g_string_append (out, canonicalized);
+          g_free (canonicalized);
+        }
+
+      hostname += llen;
+      if (*hostname && *++hostname)
+        g_string_append_c (out, '.');
+    }
+  while (*hostname);
+
+  return g_string_free (out, FALSE);
+}
+
+/**
+ * g_hostname_is_ascii_encoded:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains segments with an ASCII-compatible
+ * encoding of an Internationalized Domain Name. If this returns
+ * %TRUE, you should decode the hostname with g_hostname_to_unicode()
+ * before displaying it to the user.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any ASCII-encoded
+ * segments.
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ascii_encoded (const gchar *hostname)
+{
+  while (1)
+    {
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	return TRUE;
+      hostname = strchr (hostname, '.');
+      if (!hostname++)
+	return FALSE;
+    }
+}
+
+/**
+ * g_hostname_is_ip_address:
+ * @hostname: a hostname (or IP address in string form)
+ *
+ * Tests if @hostname is the string form of an IPv4 or IPv6 address.
+ * (Eg, "192.168.0.1".)
+ *
+ * Return value: %TRUE if @hostname is an IP address
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ip_address (const gchar *hostname)
+{
+  gchar *p, *end;
+  gint nsegments, octet;
+
+  /* On Linux we could implement this using inet_pton, but the Windows
+   * equivalent of that requires linking against winsock, so we just
+   * figure this out ourselves. Tested by tests/hostutils.c.
+   */
+
+  p = (char *)hostname;
+
+  if (strchr (p, ':'))
+    {
+      gboolean skipped;
+
+      /* If it contains a ':', it's an IPv6 address (assuming it's an
+       * IP address at all). This consists of eight ':'-separated
+       * segments, each containing a 1-4 digit hex number, except that
+       * optionally: (a) the last two segments can be replaced by an
+       * IPv4 address, and (b) a single span of 1 to 8 "0000" segments
+       * can be replaced with just "::".
+       */
+
+      nsegments = 0;
+      skipped = FALSE;
+      while (*p && nsegments < 8)
+        {
+          /* Each segment after the first must be preceded by a ':'.
+           * (We also handle half of the "string starts with ::" case
+           * here.)
+           */
+          if (p != (char *)hostname || (p[0] == ':' && p[1] == ':'))
+            {
+              if (*p != ':')
+                return FALSE;
+              p++;
+            }
+
+          /* If there's another ':', it means we're skipping some segments */
+          if (*p == ':' && !skipped)
+            {
+              skipped = TRUE;
+              nsegments++;
+
+              /* Handle the "string ends with ::" case */
+              if (!p[1])
+                p++;
+
+              continue;
+            }
+
+          /* Read the segment, make sure it's valid. */
+          for (end = p; g_ascii_isxdigit (*end); end++)
+            ;
+          if (end == p || end > p + 4)
+            return FALSE;
+
+          if (*end == '.')
+            {
+              if ((nsegments == 6 && !skipped) || (nsegments <= 6 && skipped))
+                goto parse_ipv4;
+              else
+                return FALSE;
+            }
+
+          nsegments++;
+          p = end;
+        }
+
+      return !*p && (nsegments == 8 || skipped);
+    }
+
+ parse_ipv4:
+
+  /* Parse IPv4: N.N.N.N, where each N <= 255 and doesn't have leading 0s. */
+  for (nsegments = 0; nsegments < 4; nsegments++)
+    {
+      if (nsegments != 0)
+        {
+          if (*p != '.')
+            return FALSE;
+          p++;
+        }
+
+      /* Check the segment; a little tricker than the IPv6 case since
+       * we can't allow extra leading 0s, and we can't assume that all
+       * strings of valid length are within range.
+       */
+      octet = 0;
+      if (*p == '0')
+        end = p + 1;
+      else
+        {
+          for (end = p; g_ascii_isdigit (*end); end++)
+            octet = 10 * octet + (*end - '0');
+        }
+      if (end == p || end > p + 3 || octet > 255)
+        return FALSE;
+
+      p = end;
+    }
+
+  /* If there's nothing left to parse, then it's ok. */
+  return !*p;
+}
+
+#define __G_HOST_UTILS_C__
+#include "galiasdef.c"
diff --git a/glib/ghostutils.h b/glib/ghostutils.h
new file mode 100644
index 0000000..0349da3
--- /dev/null
+++ b/glib/ghostutils.h
@@ -0,0 +1,40 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
+#error "Only <glib.h> can be included directly."
+#endif
+
+#ifndef __G_HOST_UTILS_H__
+#define __G_HOST_UTILS_H__
+
+#include <glib/gtypes.h>
+
+G_BEGIN_DECLS
+
+gboolean  g_hostname_is_non_ascii     (const gchar *hostname);
+gboolean  g_hostname_is_ascii_encoded (const gchar *hostname);
+gboolean  g_hostname_is_ip_address    (const gchar *hostname);
+
+gchar    *g_hostname_to_ascii         (const gchar *hostname);
+gchar    *g_hostname_to_unicode       (const gchar *hostname);
+
+G_END_DECLS
+
+#endif /* __G_HOST_UTILS_H__ */
diff --git a/glib/glib.h b/glib/glib.h
index 000d417..f8acdd2 100644
--- a/glib/glib.h
+++ b/glib/glib.h
@@ -47,6 +47,7 @@
 #include <glib/gfileutils.h>
 #include <glib/ghash.h>
 #include <glib/ghook.h>
+#include <glib/ghostutils.h>
 #include <glib/giochannel.h>
 #include <glib/gkeyfile.h>
 #include <glib/glist.h>
diff --git a/glib/glib.symbols b/glib/glib.symbols
index 333164f..061a693 100644
--- a/glib/glib.symbols
+++ b/glib/glib.symbols
@@ -1637,6 +1637,16 @@ g_win32_locale_filename_from_utf8
 #endif
 #endif
 
+#if IN_HEADER(__G_HOST_UTILS_H__)
+#if IN_FILE(__G_HOST_UTILS_C__)
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+g_hostname_is_ip_address
+g_hostname_to_ascii
+g_hostname_to_unicode
+#endif
+#endif
+
 #ifdef INCLUDE_VARIABLES
 g_ascii_table
 g_utf8_skip
diff --git a/glib/tests/Makefile.am b/glib/tests/Makefile.am
index 3d497ac..673d338 100644
--- a/glib/tests/Makefile.am
+++ b/glib/tests/Makefile.am
@@ -44,6 +44,9 @@ markup_subparser_LDADD    = $(progs_ldadd)
 TEST_PROGS         += array-test
 array_test_LDADD    = $(progs_ldadd)
 
+TEST_PROGS         += hostutils
+hostutils_LDADD     = $(progs_ldadd)
+
 if OS_UNIX
 
 # some testing of gtester funcitonality
diff --git a/glib/tests/hostutils.c b/glib/tests/hostutils.c
new file mode 100644
index 0000000..515145a
--- /dev/null
+++ b/glib/tests/hostutils.c
@@ -0,0 +1,267 @@
+/* 
+ * Copyright (C) 2008 Red Hat, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <glib/glib.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+static const struct {
+  const gchar *ascii_name, *unicode_name;
+} idn_test_domains[] = {
+  /* "example.test" in various languages */
+  { "xn--mgbh0fb.xn--kgbechtv", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa5\xd8\xae\xd8\xaa\xd8\xa8\xd8\xa7\xd8\xb1" },
+  { "xn--fsqu00a.xn--0zwm56d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb5\x8b\xe8\xaf\x95" },
+  { "xn--fsqu00a.xn--g6w251d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb8\xac\xe8\xa9\xa6" },
+  { "xn--hxajbheg2az3al.xn--jxalpdlp", "\xcf\x80\xce\xb1\xcf\x81\xce\xac\xce\xb4\xce\xb5\xce\xb9\xce\xb3\xce\xbc\xce\xb1.\xce\xb4\xce\xbf\xce\xba\xce\xb9\xce\xbc\xce\xae" },
+  { "xn--p1b6ci4b4b3a.xn--11b5bs3a9aj6g", "\xe0\xa4\x89\xe0\xa4\xa6\xe0\xa4\xbe\xe0\xa4\xb9\xe0\xa4\xb0\xe0\xa4\xa3.\xe0\xa4\xaa\xe0\xa4\xb0\xe0\xa5\x80\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb7\xe0\xa4\xbe" },
+  { "xn--r8jz45g.xn--zckzah", "\xe4\xbe\x8b\xe3\x81\x88.\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88" },
+  { "xn--9n2bp8q.xn--9t4b11yi5a", "\xec\x8b\xa4\xeb\xa1\x80.\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8" },
+  { "xn--mgbh0fb.xn--hgbk6aj7f53bba", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa2\xd8\xb2\xd9\x85\xd8\xa7\xdb\x8c\xd8\xb4\xdb\x8c" },
+  { "xn--e1afmkfd.xn--80akhbyknj4f", "\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80.\xd0\xb8\xd1\x81\xd0\xbf\xd1\x8b\xd1\x82\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5" },
+  { "xn--zkc6cc5bi7f6e.xn--hlcj6aya9esc7a", "\xe0\xae\x89\xe0\xae\xa4\xe0\xae\xbe\xe0\xae\xb0\xe0\xae\xa3\xe0\xae\xae\xe0\xaf\x8d.\xe0\xae\xaa\xe0\xae\xb0\xe0\xae\xbf\xe0\xae\x9f\xe0\xaf\x8d\xe0\xae\x9a\xe0\xaf\x88" },
+  { "xn--fdbk5d8ap9b8a8d.xn--deba0ad", "\xd7\x91\xd7\xb2\xd6\xb7\xd7\xa9\xd7\xa4\xd6\xbc\xd7\x99\xd7\x9c.\xd7\x98\xd7\xa2\xd7\xa1\xd7\x98" },
+
+  /* further examples without their own IDN-ized TLD */
+  { "xn--1xd0bwwra.idn.icann.org", "\xe1\x8a\xa0\xe1\x88\x9b\xe1\x88\xad\xe1\x8a\x9b.idn.icann.org" },
+  { "xn--54b7fta0cc.idn.icann.org", "\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe.idn.icann.org" },
+  { "xn--5dbqzzl.idn.icann.org", "\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa.idn.icann.org" },
+  { "xn--j2e7beiw1lb2hqg.idn.icann.org", "\xe1\x9e\x97\xe1\x9e\xb6\xe1\x9e\x9f\xe1\x9e\xb6\xe1\x9e\x81\xe1\x9f\x92\xe1\x9e\x98\xe1\x9f\x82\xe1\x9e\x9a.idn.icann.org" },
+  { "xn--o3cw4h.idn.icann.org", "\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2.idn.icann.org" },
+  { "xn--mgbqf7g.idn.icann.org", "\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88.idn.icann.org" }
+};
+static const gint num_idn_test_domains = G_N_ELEMENTS (idn_test_domains);
+
+static void
+test_to_ascii (void)
+{
+  gint i;
+  gchar *ascii;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_non_ascii (idn_test_domains[i].unicode_name));
+      ascii = g_hostname_to_ascii (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+
+      ascii = g_hostname_to_ascii (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+    }
+}
+
+static void
+test_to_unicode (void)
+{
+  gint i;
+  gchar *unicode;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_ascii_encoded (idn_test_domains[i].ascii_name));
+      unicode = g_hostname_to_unicode (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+
+      unicode = g_hostname_to_unicode (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+    }
+}
+
+static const struct {
+  const gchar *addr;
+  gboolean is_addr;
+} ip_addr_tests[] = {
+  /* IPv6 tests */
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98::", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::", TRUE },
+  { "0123:4567:89AB:cdef:3210::", TRUE },
+  { "0123:4567:89AB:cdef::", TRUE },
+  { "0123:4567:89AB::", TRUE },
+  { "0123:4567::", TRUE },
+  { "0123::", TRUE },
+
+  { "::4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::3210:7654:ba98:FeDc", TRUE },
+  { "::7654:ba98:FeDc", TRUE },
+  { "::ba98:FeDc", TRUE },
+  { "::FeDc", TRUE },
+
+  { "0123::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::FeDc", TRUE },
+
+  { "0123::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::FeDc", TRUE },
+
+  { "0123::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::FeDc", TRUE },
+
+  { "0123::7654:ba98:FeDc", TRUE },
+  { "0123:4567::ba98:FeDc", TRUE },
+  { "0123:4567:89AB::FeDc", TRUE },
+
+  { "0123::ba98:FeDc", TRUE },
+  { "0123:4567::FeDc", TRUE },
+
+  { "0123::FeDc", TRUE },
+
+  { "::", TRUE },
+
+  { "0:12:345:6789:a:bc:def::", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef:3210::123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef::123.45.67.89", TRUE },
+  { "0123:4567:89AB::123.45.67.89", TRUE },
+  { "0123:4567::123.45.67.89", TRUE },
+  { "0123::123.45.67.89", TRUE },
+  { "::123.45.67.89", TRUE },
+
+  /* Contain non-hex chars */
+  { "012x:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:45x7:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:8xAB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:xdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:321;:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:76*4:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:b-98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:+eDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc and some trailing junk", FALSE },
+  { " 123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "012 :4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123: 567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeD ", FALSE },
+
+  /* Contains too-long/out-of-range segments */
+  { "00123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:04567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:189AB:cdef:3210:7654:ba98:FeDc", FALSE },
+
+  /* Too short */
+  { "0123:4567:89AB:cdef:3210:7654:ba98", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654", FALSE },
+  { "0123:4567:89AB:cdef:3210", FALSE },
+  { "0123", FALSE },
+  { "", FALSE },
+
+  /* Too long */
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:9999", FALSE },
+  { "0123::4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567::89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef::3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210::7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98::FeDc", FALSE },
+
+  /* Invalid use of ":"s */
+  { "0123::89AB::3210:7654:ba98:FeDc", FALSE },
+  { "::4567:89AB:cdef:3210:7654::FeDc", FALSE },
+  { "0123::89AB:cdef:3210:7654:ba98::", FALSE },
+  { ":4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:", FALSE },
+  { "0123:::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:", FALSE },
+  { ":0123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { ":::", FALSE },
+
+  /* IPv4 address at wrong place */
+  { "0123:4567:89AB:cdef:3210:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:123.45.67.89:FeDc", FALSE },
+
+
+  /* IPv4 tests */
+
+  { "123.45.67.89", TRUE },
+  { "1.2.3.4", TRUE },
+  { "1.2.3.0", TRUE },
+
+  { "023.045.067.089", FALSE },
+  { "1234.5.67.89", FALSE },
+  { "123.45.67.00", FALSE },
+  { " 1.2.3.4", FALSE },
+  { "1 .2.3.4", FALSE },
+  { "1. 2.3.4", FALSE },
+  { "1.2.3.4 ", FALSE },
+  { "1.2.3", FALSE },
+  { "1.2.3.4.5", FALSE },
+  { "1.b.3.4", FALSE },
+  { "1.2.3:4", FALSE },
+  { "1.2.3.4, etc", FALSE },
+  { "1,2,3,4", FALSE },
+  { "1.2.3.com", FALSE },
+  { "1.2.3.4.", FALSE },
+  { "1.2.3.", FALSE },
+  { ".1.2.3.4", FALSE },
+  { ".2.3.4", FALSE },
+  { "1..2.3.4", FALSE },
+  { "1..3.4", FALSE }
+};
+static const gint num_ip_addr_tests = G_N_ELEMENTS (ip_addr_tests);
+
+static void
+test_is_ip_addr (void)
+{
+  gint i;
+
+  for (i = 0; i < num_ip_addr_tests; i++)
+    {
+      if (g_hostname_is_ip_address (ip_addr_tests[i].addr) != ip_addr_tests[i].is_addr)
+	{
+	  char *msg = g_strdup_printf ("g_hostname_is_ip_address (\"%s\") == %s",
+				       ip_addr_tests[i].addr,
+				       ip_addr_tests[i].is_addr ? "TRUE" : "FALSE");
+	  g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
+	}
+    }
+}
+
+/* FIXME: test names with both unicode and ACE-encoded labels */
+/* FIXME: test invalid unicode names */
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+  
+  g_test_add_func ("/hostutils/to_ascii", test_to_ascii);
+  g_test_add_func ("/hostutils/to_unicode", test_to_unicode);
+  g_test_add_func ("/hostutils/is_ip_addr", test_is_ip_addr);
+
+  return g_test_run ();
+}
diff --git a/glibconfig.h.win32.in b/glibconfig.h.win32.in
index 92e8964..f10fa32 100644
--- a/glibconfig.h.win32.in
+++ b/glibconfig.h.win32.in
@@ -250,6 +250,9 @@ union _GSystemThread
  */
 typedef void * GPid;
 
+#define GLIB_SYSDEF_AF_INET 2
+#define GLIB_SYSDEF_AF_INET6 23
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
diff --git a/po/ChangeLog b/po/ChangeLog
index a5fbb1f..b9bdf8b 100644
--- a/po/ChangeLog
+++ b/po/ChangeLog
@@ -1,3 +1,19 @@
+2009-02-19  Gil Forcada  <gforcada@gnome.org>
+
+	* ca.po: Updated Catalan translation.
+
+2009-02-19  Gabor Kelemen  <kelemeng@gnome.hu>
+
+	* hu.po: Translation updated.
+
+2009-02-19  Theppitak Karoonboonyanan  <thep@linux.thai.net>
+
+	* th.po: Updated Thai translation.
+
+2009-02-18  Ilkka Tuohela <hile@iki.fi>
+
+	* fi.po: Updated Finnish translation.
+
 2009-02-17  Matthias Clasen  <mclasen@redhat.com>
 
 	* === Released 2.19.8 ===
diff --git a/po/ca.po b/po/ca.po
index 2a391fa..d5f503d 100644
--- a/po/ca.po
+++ b/po/ca.po
@@ -9,8 +9,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib 2.8\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-17 11:17-0500\n"
-"PO-Revision-Date: 2009-01-16 01:53+0100\n"
+"POT-Creation-Date: 2009-02-19 14:22+0100\n"
+"PO-Revision-Date: 2009-02-19 14:22+0100\n"
 "Last-Translator: Gil Forcada <gilforcada@guifi.net>\n"
 "Language-Team: Catalan <tradgnome@softcatala.org>\n"
 "MIME-Version: 1.0\n"
@@ -18,308 +18,309 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=n != 1;\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "No s'esperava l'atribut «%s» per a l'element «%s»"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "No s'ha trobat l'atribut «%s» de l'element «%s»"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "No s'esperava l'etiqueta «%s», s'esperava «%s»"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "No s'esperava l'etiqueta «%s» dins «%s»"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr ""
 "No s'ha trobat cap fitxer d'adreces d'interès dins dels directoris de dades"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Ja existeix una adreça d'interès per a l'URI «%s»"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "No s'ha trobat cap adreça d'interès per a l'URI «%s»"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "No hi ha cap tipus MIME definit a l'adreça d'interès per a l'URI «%s»"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr ""
 "No hi ha cap senyalador privat definit a l'adreça d'interès per a l'URI «%s»"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "No hi ha cap grup establert a l'adreça d'interès per a l'URI «%s»"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr ""
 "No hi ha cap aplicació amb el nom «%s» que hagi registrat l'adreça d'interès «%"
 "s»"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "No s'ha pogut expandir la línia d'execució «%s» amb URI «%s»"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "No es permet la conversió entre els jocs de caràcters «%s» a «%s»"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "No s'ha pogut obrir el convertidor de «%s» a «%s»"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:964
-#: glib/gutf8.c:1413
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:964
+#: ../glib/gutf8.c:1413
 msgid "Invalid byte sequence in conversion input"
 msgstr "La seqüència de bytes a l'entrada de conversió no és vàlida"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "S'ha produït un error durant la conversió: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:960 glib/gutf8.c:1164 glib/gutf8.c:1305
-#: glib/gutf8.c:1409
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:960 ../glib/gutf8.c:1164
+#: ../glib/gutf8.c:1305 ../glib/gutf8.c:1409
 msgid "Partial character sequence at end of input"
 msgstr "Seqüència de caràcters parcial al final de l'entrada"
 
 # FIXME: fallback
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "No es pot convertir el «fallback» «%s» al joc de codis «%s»"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "L'URI «%s» no és un URI absolut que utilitzi l'esquema «file»"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "Pot ser que l'URI del fitxer local «%s» no inclogui cap «#»"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "L'URI «%s» no és vàlid"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "El nom de l'ordinador de l'URI «%s» no és vàlid"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "L'URI «%s» conté caràcters d'escapada invàlids"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "El nom de camí «%s» no és un camí absolut"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "El nom de l'ordinador no és vàlid"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "S'ha produït un error en obrir el directori «%s»: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "No s'ha pogut assignar %lu bytes per a llegir el fitxer «%s»"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "S'ha produït un error en llegir el fitxer «%s»: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "El fitxer «%s» és massa gran"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "No s'ha pogut llegir del fitxer «%s»: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "No s'ha pogut obrir el fitxer «%s»: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr ""
 "No s'ha pogut obtenir els atributs del fitxer «%s»: ha fallat la funció fstat"
 "(): %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "No s'ha pogut obrir el fitxer «%s»: ha fallat la funció fdopen(): %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
 "No s'ha pogut canviar el nom del fitxer «%s» a «%s»: ha fallat la funció "
 "g_rename(): %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "No s'ha pogut crear el fitxer «%s»: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr ""
 "No s'ha pogut obrir el fitxer «%s» per a escriptura: ha fallat la funció "
 "fdopen(): %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "No s'ha pogut escriure el fitxer «%s»: ha fallat la funció fwrite(): %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "No s'ha pogut tancar el fitxer «%s»: ha fallat la funció fclose(): %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr ""
 "No s'ha pogut suprimir el fitxer existent «%s»: ha fallat la funció g_unlink"
 "(): %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "La plantilla «%s» no és vàlida, no hauria de tenir cap «%s»"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "La plantilla «%s» no conté XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "No s'ha pogut llegir l'enllaç simbòlic «%s»: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "No es poden utilitzar els enllaços simbòlics"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "No s'ha pogut obrir el convertidor de «%s» a «%s»: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "No es pot fer una lectura bàsica a g_io_channel_read_line_string"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "A la memòria intermèdia de lectura hi ha dades sobrants no convertides"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "El canal acaba en un caràcter parcial"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "No es pot fer una lectura bàsica a g_io_channel_read_to_end"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "No s'ha pogut obrir el fitxer «%s»: ha fallat la funció open(): %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "No s'ha pogut mapejar el fitxer «%s»: ha fallat la funció mmap(): %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "S'ha produït un error a la línia %d caràcter %d:"
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "S'ha produït un error a la línia %d: %s"
 
-#: glib/gmarkup.c:493
+#: ../glib/gmarkup.c:493
 msgid ""
 "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "S'ha vist una entitat buida «&;». Les entitats vàlides són: &amp; &quot; &lt; "
 "&gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -330,17 +331,17 @@ msgstr ""
 "comencen amb el caràcter &. Si amb aquest signe no es vol indicar una "
 "entitat, substituïu-lo per &amp;"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "El caràcter «%s» no és vàlid dins d'un nom d'entitat"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "No es coneix el nom de l'entitat «%s»"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -348,7 +349,7 @@ msgstr ""
 "L'entitat no acaba amb un punt i coma. Segurament heu utilitzat un caràcter "
 "«&» sense intenció d'iniciar una entitat. Substituïu el caràcter «&» per &amp;"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -357,17 +358,17 @@ msgstr ""
 "No s'ha pogut analitzar «%-.*s», hi hauria d'haver hagut un dígit dins un "
 "caràcter de referència (per exemple &#234;) - potser el dígit és massa llarg"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "El caràcter de referència «%-.*s» no codifica un caràcter permès"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr ""
 "El caràcter de referència és buit. Hauria d'incloure un dígit com ara &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -377,36 +378,36 @@ msgstr ""
 "utilitzat un caràcter «&» sense intenció d'iniciar una entitat. Substituïu el "
 "caràcter «&» per &amp;"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Referència a una entitat no acabada"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Referència a un caràcter no acabada"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr ""
 "El text no està codificat correctament a UTF-8 - la seqüència és massa llarga"
 
 # FIXME: "caràcter estrella" (josep)
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr ""
 "El text no està codificat correctament a UTF-8 - no és un caràcter estrella"
 
 # FIXME: això no funcionarà en català (josep)
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "El text no està codificat correctament a UTF-8 - no és un vàlid «%s»"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "El document ha de començar amb un element (p.ex. <llibre>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -415,7 +416,7 @@ msgstr ""
 "«%s» no és un caràcter vàlid després d'un caràcter «<». No pot començar un nom "
 "d'element"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -424,7 +425,7 @@ msgstr ""
 "S'ha trobat un caràcter estrany «%s». S'esperava el caràcter «>» per acabar "
 "l'etiqueta d'element buit «%s»"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
 msgid ""
 "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
@@ -432,7 +433,7 @@ msgstr ""
 "S'ha trobat un caràcter estrany «%s». S'esperava un «=» després del nom "
 "d'atribut «%s» de l'element «%s»"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -443,7 +444,7 @@ msgstr ""
 "finalitzar l'etiqueta d'inici de l'element «%s», o opcionalment un atribut. "
 "Potser heu utilitzat un caràcter no vàlid en un nom d'atribut"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -452,7 +453,7 @@ msgstr ""
 "S'ha trobat un caràcter estrany «%s». S'esperaven unes cometes d'obertura "
 "després del signe «=» en donar valor a l'atribut «%s» de l'element «%s»"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -461,7 +462,7 @@ msgstr ""
 "«%s» no és un caràcter vàlid després dels caracters «</»; «%s» no hauria "
 "d'iniciar un nom d'element"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -470,27 +471,27 @@ msgstr ""
 "«%s» no és un caràcter vàlid després del nom d'element de tancament «%s». El "
 "caràcter permès és «>»"
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "L'element «%s» estava tancat. Actualment no hi ha cap element obert"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "L'element «%s» estava tancat. L'element obert actualment és «%s»"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "El document era buit o només contenia espais en blanc"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr ""
 "El document ha acabat de manera inesperada immediatament després del símbol "
 "«<»"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -499,7 +500,7 @@ msgstr ""
 "El document ha acabat de manera inesperada amb elements encara oberts. «%s» "
 "era l'últim element obert"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -508,21 +509,21 @@ msgstr ""
 "El document ha acabat de manera inesperada. S'esperava trobar un símbol «>» "
 "que acabés l'etiqueta <%s/>"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "El document ha acabat de manera inesperada enmig d'un nom d'element"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "El document ha acabat de manera inesperada enmig d'un nom d'atribut"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr ""
 "El document ha acabat de manera inesperada enmig d'una etiqueta d'obertura "
 "d'un element."
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -530,407 +531,409 @@ msgstr ""
 "El document ha acabat de manera inesperada després d'un signe d'igual "
 "després d'un nom d'atribut. No hi ha cap valor d'atribut"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "El document ha acabat de manera inesperada enmig d'un valor d'atribut"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr ""
 "El document ha acabat de manera inesperada enmig de l'etiqueta de tancament "
 "de l'element «%s»"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "El document ha acabat de manera inesperada enmig d'un comentari o una "
 "instrucció de processament"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "objecte malmès"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "error intern o objecte malmès"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "no hi ha prou memòria"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "s'ha arribat al límit de tornades enrere"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr ""
 "el patró conté elements que no estan implementats en les concordances "
 "parcials"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "error intern"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr ""
 "no s'ha implementat l'ús de referències anteriors per a coincidències "
 "parcials"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "s'ha arribat al límit de recurrències"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "s'ha arribat al límit d'espais de treball per a subcadenes buides"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "la combinació de senyaladors de línia nova no és vàlida"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "error desconegut"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ al final del patró"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c al final del patró"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "caràcter no reconegut després de \\"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr "aquí no es permeten els escapaments (\\l,\\L, \\u, \\U)"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "nombres fora del rang en el quantificador {}"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "nombre massa gran en el quantificador {}"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "falta el «]» per a la classe de caràcter"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "la seqüència d'escapada en la classe de caràcter no és vàlida"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "s'ha sortit del rang en la classe de caràcter"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "no hi ha res a repetir"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "no es reconeix el caràcter després de «(?»"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "no es reconeix el caràcter després de «(?<»"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "no es reconeix el caràcter després de «(?P»"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr ""
 "només es permeten les classes amb nom de POSIX dins de la pròpia classe"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "falta un «)»"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr "hi ha un «)» sense el corresponent «(»"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "«(?R» o «(?[+-]digits» han d'anar seguits per «)»"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "referència a un subpatró que no existeix"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "falta un «)» després del comentari"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "l'expressió regular és massa llarga"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "no s'ha pogut obtenir memòria"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "l'asserció cap enrera no té llargada fixa"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "nombre o nom malformats després de «(?(»"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "el grup condicional conté més de dues branques"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "s'esperava una asserció després de «(?(»"
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "nom de classe POSIX desconeguda"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "no es poden utilitzar els elements d'ordenació de POSIX"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "el valor del caràcter a la seqüència «\\x{...}» és massa llarg"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "condició «(?(0)» no vàlida"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "no es permet \\C en assercions cap enrera"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "la crida recursiva podria buclar-se indefinidament"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "falta la finalització en el nom del subpatró"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "dos noms de subpatró tenen el mateix nom"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "la seqüència «\\P» o «\\p» és malformada"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "es desconeix el nom de la propietat després de «\\P» o «\\p»"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "el nom del subpatró és massa llarg (32 caràcters com a màxim)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "hi ha massa subpatrons amb nom (màxim de 10.000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "el valor octal és més gran que \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "el grup «DEFINE» conté més d'una branca"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "no es permet repetir un grup «DEFINE»"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "opcions «NEWLINE» inconsistents"
 
-#: glib/gregex.c:333
+#: ../glib/gregex.c:333
 msgid ""
 "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "«\\g» no és seguit per un nom entre claus o un nombre opcional diferent de "
 "zero entre claus"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "repetició no esperada"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "desbordament del codi"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "s'ha produït un desbordament en compilar l'espai de treball"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "no s'ha trobat el subpatró referenciat comprovat anteriorment"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "S'ha produït un error en fer coincidir l'expressió regular %s: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "La biblioteca PCRE no està compilada per a interpretar UTF8"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr ""
 "La biblioteca PCRE no està compilada per a interpretar les propietats UTF8"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr ""
 "S'ha produït un error en compilar l'expressió regular %s al caràcter %d: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "S'ha produït un error en optimitzar l'expressió regular %s: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "s'esperava un dígit hexadecimal o bé «}»"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "s'esperava un dígit hexadecimal"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "falta un «<» en la referència simbòlica"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "la referència simbòlica no està acabada"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "referència simbòlica de longitud zero"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "s'esperava un dígit"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "la referència simbòlica no és vàlida"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "«\\» final extraviat"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "no es reconeix la seqüència d'escapament"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr ""
 "S'ha produït un error en analitzar el text de reemplaçament «%s» al caràcter %"
 "lu: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "El text citat no comença amb cometes"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr ""
 "S'han trobat unes cometes desaparellades en una línia d'ordres o en un altre "
 "text entre cometes"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "El text acaba just després d'un caràcter «\\». (El text era «%s»)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr ""
 "El text ha acabat abans de trobar les cometes corresponents a %c. (El text "
 "era «%s»)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "El text era buit (o només contenia espais en blanc)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "No s'ha pogut llegir dades del procés fill"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr ""
 "No s'ha pogut crear el conducte per comunicar-se amb el procés fill (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "No s'ha pogut llegir des del conducte fill (%s)"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "No s'ha pogut canviar al directori «%s» (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "No s'ha pogut executar el procés fill (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "El nom del programa no és vàlid: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "La cadena en el vector d'argument no és vàlida a %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Cadena no vàlida a l'entorn: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "El directori de treball no és vàlid: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "No s'ha pogut executar el programa d'ajuda (%s)"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -938,140 +941,140 @@ msgstr ""
 "S'ha produït un error inesperat a g_io_chanel_win32_poll() en llegir dades "
 "d'un procés fill"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "No s'ha pogut llegir dades des del procés fill (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr ""
 "S'ha produït un error inesperat a select() en llegir dades des d'un procés "
 "fill (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "S'ha produït un error inesperat en waitpid() (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "No s'ha pogut bifurcar-se (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "No s'ha pogut executar el procés fill «%s» (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "No s'ha pogut redirigir l'entrada o la sortida del procés fill (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "No s'ha pogut bifurcar el procés fill (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "S'ha produït un error desconegut en executar el procés fill «%s»"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr ""
 "No s'han pogut llegir prou dades del conducte de l'identificador del procés "
 "fill (%s)"
 
-#: glib/gutf8.c:1038
+#: ../glib/gutf8.c:1038
 msgid "Character out of range for UTF-8"
 msgstr "El caràcter és fora del rang per a UTF-8"
 
-#: glib/gutf8.c:1132 glib/gutf8.c:1141 glib/gutf8.c:1273 glib/gutf8.c:1282
-#: glib/gutf8.c:1423 glib/gutf8.c:1519
+#: ../glib/gutf8.c:1132 ../glib/gutf8.c:1141 ../glib/gutf8.c:1273
+#: ../glib/gutf8.c:1282 ../glib/gutf8.c:1423 ../glib/gutf8.c:1519
 msgid "Invalid sequence in conversion input"
 msgstr "Seqüència no vàlida a l'entrada de la conversió"
 
-#: glib/gutf8.c:1434 glib/gutf8.c:1530
+#: ../glib/gutf8.c:1434 ../glib/gutf8.c:1530
 msgid "Character out of range for UTF-16"
 msgstr "El caràcter és fora del rang per a UTF-16"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Forma d'ús:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[OPCIÓ...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Opcions d'ajuda:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Mostra les opcions d'ajuda"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Mostra totes les opcions d'ajuda"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Opcions de l'aplicació:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "No es pot analitzar el valor enter «%s» per a %s"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "El valor enter «%s» per a %s és fora del rang"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "No es pot analitzar el valor doble «%s» per a %s"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "El valor doble «%s» per a %s és fora del rang"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "S'ha produït un error en analitzar l'opció %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Manca un argument per a %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Es desconeix l'opció %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "No s'ha pogut trobar cap fitxer de claus vàlid als directoris de cerca"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "No és un fitxer regular"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "El fitxer és buit"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
 msgid ""
 "Key file contains line '%s' which is not a key-value pair, group, or comment"
@@ -1079,49 +1082,49 @@ msgstr ""
 "El fitxer de claus conté la línia «%s» que no és una parella clau-valor, grup "
 "o comentari"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "El nom del grup no és vàlid: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "El fitxer de claus no comença amb un grup"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "El nom de la clau no és vàlid: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "El fitxer de claus conté la codificació no implementada «%s»"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "El fitxer de claus no té el grup «%s»"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "El fitxer de claus no té la clau «%s»"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "El fitxer de claus conté la clau «%s» amb el valor «%s» que no és UTF-8"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr ""
 "El fitxer de claus conté la clau «%s» que té un valor que no és interpretable."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1130,151 +1133,153 @@ msgstr ""
 "El fitxer de claus conté la clau «%s» en el grup «%s», que té un valor no "
 "interpretable."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "El fitxer de claus no conté una clau «%s» en el grup «%s»"
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "El fitxer de claus conté un caràcter d'escapada al final de línia"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "El fitxer de claus conté una seqüència d'escapada no vàlida «%s»"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "El valor «%s» no es pot interpretar com a un nombre."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "El valor enter «%s» és fora del rang"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "El valor «%s» no es pot interpretar com a un nombre en coma flotant."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "El valor «%s» no es pot interpretar com un booleà."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "El valor de comptatge passat a %s és massa llarg"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Ja està tancat el flux"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:627
-#: gio/gsimpleasyncresult.c:654
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:627 ../gio/gsimpleasyncresult.c:654
 msgid "Operation was cancelled"
 msgstr "S'ha cancel·lat l'operació"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Tipus desconegut"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "tipus de tixer %s"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "tipus %s"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "No s'esperava un final de flux tant aviat"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Sense nom"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "El fitxer d'escriptori no especificava el camp d'execucció"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "No s'ha pogut trobar el terminal que demanava l'aplicació"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr ""
 "No s'ha pogut crear el directori de configuració de l'aplicació de l'usuari %"
 "s: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr ""
 "No s'ha pogut crear el directori de configuració MIME de l'usuari %s: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "No s'ha pogut crear el fitxer d'escriptori de l'usuari %s"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "Definició personalitzada per a %s"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "la unitat no implementa l'expulsió"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "la unitat no implementa l'enquesta per si hi ha un medi"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
 msgstr "No es pot gestionar la versió %d de la codificació del GEmblem"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
 msgstr ""
 "Un nombre de testimonis (%d) de la codificació del GEmblem no són formats "
 "correctament"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
 msgstr "No es pot gestionar la versió %d de la codificació del GEmblemedIcon"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
 msgstr ""
 "Un nombre de testimonis (%d) en la codificació del GEmblemedIcon no són "
 "formats correctament"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
 msgstr "S'esperava un GEmblem per a un GEmblemedIcon"
 
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "L'operació no està implementada"
 
@@ -1286,132 +1291,132 @@ msgstr "L'operació no està implementada"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "No existeix el punt de muntatge contenidor"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "No es pot copiar al directori"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "No es pot copiar el directori al directori"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Ja existeix el fitxer de destinació"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "No es pot copiar el directori de forma recursiva"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "El valor donat per a l'enllaç simbòlic no és vàlid"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "No es pot utilitzar la paperera"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "En els noms de fitxers no pot haver-hi «%c»"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "el volum no implementa el muntatge"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr ""
 "No hi ha cap aplicació que s'hagi registrat per a gestionar aquest fitxer"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "L'enumerador està tancat"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "L'enumerador de fitxer té una operació pendent"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Ja està tancat l'enumerador de fitxer"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "fitxer"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "El fitxer que conté la icona"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
 msgstr "No es pot gestionar la versió %d de la codificació del GFileIcon"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
 msgstr "Les dades d'entrada pel GFileIcon no són formades correctament"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "El flux no implementa «query_info»"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "No està implementada la cerca en el flux"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "No es permet truncar en els fluxs d'entrada"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "No es permet trucar en els fluxs"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
 msgstr "Nombre de testimonis erroni (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
 msgstr "El nom de classe %s no té tipus"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
 msgstr "El tipus %s no implementa la interfície GIcon"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
 msgstr "El tipus %s no té classe"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
 msgstr "El número de versió no és format correctament: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
 msgstr "El tipus %s no implementa «from_tokens()» a la interfície GIcon"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
 msgstr ""
 "No es pot gestionar la versió proporcionada de la codificació de la icona"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "El flux d'entrada no té implementada la lectura"
 
@@ -1421,366 +1426,372 @@ msgstr "El flux d'entrada no té implementada la lectura"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "El flux té una operació pendent"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr ""
 "No s'ha pogut trobar el tipus de seguiment de directoris locals predeterminat"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "El nom del fitxer no és vàlid: %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr ""
 "S'ha produït un error en obtenir la informació del sistema de fitxers: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "No es pot canviar el nom del directori arrel"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "S'ha produït un error en canviar el nom del fitxer: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "No es pot canviar el nom del fitxer, ja existeix aquest nom"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:1009
 msgid "Invalid filename"
 msgstr "Nom de fitxer no vàlid"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "S'ha produït un error en obrir el fitxer: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "No s'ha pogut obrir el directori"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "S'ha produït un error en suprimir el fitxer: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "S'ha produït un error en enviar el fitxer a la paperera: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "No s'ha pogut crear el directori de la paperera %s: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "No s'ha pogut trobar el directori superior per a la paperera"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "No s'ha pogut trobar o crear el directori de la paperera"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "No s'ha pogut crear el fitxer d'informació d'enviar a la paperera: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "No s'ha pogut enviar el fitxer a la paperera: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "S'ha produït un error en crear el directori: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "S'ha produït un error en fer l'enllaç simbòlic: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "S'ha produït un error en moure el fitxer: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "No s'ha pogut moure el directori al directori"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:829
+#: ../gio/glocalfileoutputstream.c:843 ../gio/glocalfileoutputstream.c:858
+#: ../gio/glocalfileoutputstream.c:874 ../gio/glocalfileoutputstream.c:888
 msgid "Backup file creation failed"
 msgstr "Ha fallat la creació del fitxer de còpia de seguretat"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "S'ha produït un error en suprimir el fitxer objectiu: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "No està implementat el moure entre muntatges"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "El valor de l'atribut no pot ser nul"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Tipus d'atribut no vàlid (s'esperava una cadena)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "El nom de l'atribut estés no és vàlid"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "S'ha produït un error en establir l'atribut estés «%s»: %s"
 
-#: gio/glocalfileinfo.c:1466 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1466 ../gio/glocalfileoutputstream.c:713
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr ""
 "S'ha produït un error en executar la funció «stat()» en el fitxer «%s»: %s"
 
-#: gio/glocalfileinfo.c:1536
+#: ../gio/glocalfileinfo.c:1536
 msgid " (invalid encoding)"
 msgstr " (codificació no vàlida)"
 
-#: gio/glocalfileinfo.c:1704
+#: ../gio/glocalfileinfo.c:1704
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr ""
 "S'ha produït un error en executar la funció «stat()» al descriptor de fitxer: "
 "%s"
 
-#: gio/glocalfileinfo.c:1749
+#: ../gio/glocalfileinfo.c:1749
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Tipus d'atribut no vàlid (s'esperava un uint32)"
 
-#: gio/glocalfileinfo.c:1767
+#: ../gio/glocalfileinfo.c:1767
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Tipus d'atribut no vàlid (s'esperava un uint64)"
 
-#: gio/glocalfileinfo.c:1786 gio/glocalfileinfo.c:1805
+#: ../gio/glocalfileinfo.c:1786 ../gio/glocalfileinfo.c:1805
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Tipus d'atribut no vàlid (s'esperava una cadena de bytes)"
 
-#: gio/glocalfileinfo.c:1831
+#: ../gio/glocalfileinfo.c:1831
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "S'ha produït un error en establir els permisos: %s"
 
-#: gio/glocalfileinfo.c:1882 gio/glocalfileinfo.c:2050
+#: ../gio/glocalfileinfo.c:1882 ../gio/glocalfileinfo.c:2050
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "S'ha produït un error en establir el propietari: %s"
 
-#: gio/glocalfileinfo.c:1905
+#: ../gio/glocalfileinfo.c:1905
 msgid "symlink must be non-NULL"
 msgstr "l'enllaç simbòlic no pot ser nul"
 
-#: gio/glocalfileinfo.c:1915 gio/glocalfileinfo.c:1934
-#: gio/glocalfileinfo.c:1945
+#: ../gio/glocalfileinfo.c:1915 ../gio/glocalfileinfo.c:1934
+#: ../gio/glocalfileinfo.c:1945
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "S'ha produït un error en establir l'enllaç simbòlic: %s"
 
-#: gio/glocalfileinfo.c:1924
+#: ../gio/glocalfileinfo.c:1924
 msgid "Error setting symlink: file is not a symlink"
 msgstr ""
 "S'ha produït un error en establir l'enllaç simbòlic: el fitxer no és un "
 "enllaç simbòlic"
 
-#: gio/glocalfileinfo.c:2073
+#: ../gio/glocalfileinfo.c:2073
 msgid "SELinux context must be non-NULL"
 msgstr "El context del SELinux no pot ser nul"
 
-#: gio/glocalfileinfo.c:2088
+#: ../gio/glocalfileinfo.c:2088
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "S'ha produït un error en establir el context del SELinux: %s"
 
-#: gio/glocalfileinfo.c:2095
+#: ../gio/glocalfileinfo.c:2095
 msgid "SELinux is not enabled on this system"
 msgstr "Aquest sistema no té habilitat el SELinux"
 
-#: gio/glocalfileinfo.c:2156
+#: ../gio/glocalfileinfo.c:2156
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "No està implementat establir l'atribut %s"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "S'ha produït un error en llegir des del fitxer: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:906
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "S'ha produït un error en cercar en el fitxer: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "S'ha produït un error en tancar el fitxer: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr ""
 "No s'ha pogut trobar el tipus de monitorització de fitxer local predeterminat"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "S'ha produït un error en escriure al fitxer: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr ""
 "S'ha produït un error en suprimir l'enllaç de còpia de seguretat antic: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "S'ha produït un error en crear la còpia de seguretat: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "S'ha produït un error en canviar el nom del fitxer temporal: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:953
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "S'ha produït un error en truncar el fitxer: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:695 ../gio/glocalfileoutputstream.c:934
+#: ../gio/glocalfileoutputstream.c:1015
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "S'ha produït un error en obrir el fitxer «%s»: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:726
 msgid "Target file is a directory"
 msgstr "El fitxer objectiu és un directori"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:731
 msgid "Target file is not a regular file"
 msgstr "El fitxer objectiu no és un fitxer regular"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:743
 msgid "The file was externally modified"
 msgstr "El fitxer ha estat modificat des d'alguna aplicació externa"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/glocalfileoutputstream.c:922
+#, c-format
+msgid "Error removing old file: %s"
+msgstr "S'ha produït un error en suprimir el fitxer vell: %s"
+
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "El GSeekType proporcionat no és vàlid"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "La sol·licitud de cerca és invàlida"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "No es pot truncar el GMemoryInputStream"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "S'ha arribat al màxim del límit de la matriu de dades"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "El flux de sortida de memòria no és modificable"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Ha fallat el redimensionament de la memòria del flux de sortida"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "el muntatge no implementa el desmuntatge"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "el muntatge no implementa l'expulsió"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "el muntatge no implementa el tornar-se a muntar"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "el muntatge no implementa l'estimació de tipus de contingut"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "el muntatge no implementa l'estimació de tipus de contingut síncron"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "El flux de sortida no implementa l'escriptura"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "El flux font ja està tancat"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "nom"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "El nom de la icona"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "noms"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Una llista amb els noms de les icones"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "utilitza les alternatives predeterminades"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1789,86 +1800,86 @@ msgstr ""
 "escurçar el nom a «-» caràcters. Ignora els noms després del primer si es "
 "donen més múltiples noms."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
 msgstr "No es pot gestionar la versió %d de la codificació del GThemedIcon"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
 msgstr "Descriptor de fitxer"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
 msgstr "El descriptor de fitxer del qual llegir"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
 msgstr "Tanca el descriptor de fitxer"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
 msgstr "Si s'ha de tancar el descriptor de fitxer quan es tanqui el flux"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "S'ha produït un error en llegir des de UNIX: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "S'ha produït un error en tancar des de UNIX: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Arrel del sistema de fitxers"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
 msgstr "El descriptor de fitxer al qual escriure"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "S'ha produït un error en escriure a UNIX: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "el volum no implementa l'expulsió"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "No es pot trobar l'aplicació"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "S'ha produït un error en executar l'aplicació: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "No estan implementats els URI"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "els canvis associatius no estan implementats a win32"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "La creació associativa no està implementada a win32"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "no amaguis les entrades"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "utilitza un format de llistat llarg"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[FITXER...]"
 
diff --git a/po/fi.po b/po/fi.po
index 95d1192..c6c2853 100644
--- a/po/fi.po
+++ b/po/fi.po
@@ -9,8 +9,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-17 11:17-0500\n"
-"PO-Revision-Date: 2009-01-27 06:00+0300\n"
+"POT-Creation-Date: 2009-02-18 18:15+0300\n"
+"PO-Revision-Date: 2009-02-18 18:20+0300\n"
 "Last-Translator: Ilkka Tuohela <hile@iki.fi>\n"
 "Language-Team: Finnish <gnome-fi-laatu@lists.sourceforge.net>\n"
 "MIME-Version: 1.0\n"
@@ -18,304 +18,305 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=n == 1 ? 0 : 1;\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Odottamaton ominaisuus \"%s\" elementille \"%s\""
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "Ominaisuutta \"%s\" elementille \"%s\" ei löydy"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Odottamaton merkintä \"%s\", odotettiin merkintää \"%s\""
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Odottamaton merkintä \"%s\" kohdassa \"%s\""
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "Kelvollista kirjanmerkkitiedostoa ei löytynyt datahakemistoista"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "URI:lle \"%s\" on jo olemassa kirjanmerkki"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "URI:lle \"%s\" ei löydy kirjanmerkkiä"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "URI:n \"%s\" kirjanmerkissä ei ole määritelty MIME-tyyppiä"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "URI:n \"%s\" kirjanmerkissä ei ole määritelty yksityisyyslippua"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "URI:n \"%s\" kirjanmerkissä ei ole asetettu ryhmiä"
 
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
 msgstr ""
 "Sovellus nimeltä \"%s\" ei rekisteröinyt kirjanmerkkiä kohteelle \"%s\""
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Suoritettavaa riviä \"%s\" ei voitu laajentaa URI:lla \"%s\""
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "Muunnos merkistöstä \"%s\" merkistöön \"%s\" ei ole tuettu"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "Muunninta merkistöstä \"%s\" merkistöön \"%s\" ei voitu avata"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:964
-#: glib/gutf8.c:1413
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:964
+#: ../glib/gutf8.c:1413
 msgid "Invalid byte sequence in conversion input"
 msgstr "Virheellinen tavusarja muunnettavassa syötteessä"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Virhe muunnoksen aikana: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:960 glib/gutf8.c:1164 glib/gutf8.c:1305
-#: glib/gutf8.c:1409
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:960 ../glib/gutf8.c:1164
+#: ../glib/gutf8.c:1305 ../glib/gutf8.c:1409
 msgid "Partial character sequence at end of input"
 msgstr "Osittainen tavusarja syötteen lopussa"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Koodausmerkkijonoa \"%s\" ei voi muuntaa merkistöön \"%s\""
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "URI \"%s\" ei ole absoluuttinen URI \"file\"-muodossa"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "Paikallinen tiedosto-URI \"%s\" ei saa sisältää merkkiä \"#\""
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "URI \"%s\" on virheellinen"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "URI:n \"%s\" isäntänimi on virheellinen"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
 msgstr "URI \"%s\" sisältää virheellisesti suojattuja merkkejä"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "Polku \"%s\" ei ole absoluuttinen"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Virheellinen isäntänimi"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Virhe hakemiston \"%s\" avaamisessa: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Ei voitu varata %lu tavua muistia tiedoston \"%s\" lukemiseksi"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Virhe tiedoston \"%s\" lukemisessa: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "Tiedosto \"%s\" on liian suuri"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Tiedoston \"%s\" lukeminen epäonnistui: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Tiedoston \"%s\" avaaminen epäonnistui: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr ""
 "Tiedoston \"%s\" ominaisuuksien lukeminen epäonnistui: fstat() epäonnistui: %"
 "s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "Tiedoston \"%s\" avaaminen epäonnistui: fdopen() epäonnistui: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
 "Tiedoston \"%s\" uudelleen nimeäminen nimelle \"%s\" epäonnistui: g_rename() "
 "epäonnistui: %s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Tiedoston \"%s\" luominen epäonnistui: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
 msgstr ""
 "Tiedoston \"%s\" avaaminen kirjoitettavaksi epäonnistui: fdopen() "
 "epäonnistui: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Tiedoston \"%s\" kirjoittaminen epäonnistui: fwrite() epäonnistui: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Tiedoston \"%s\" sulkeminen epäonnistui: fclose() epäonnistui: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr ""
 "Olemassaolevan tiedoston \"%s\" poisto epäonnistui: g_unlink epäonnistui: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "Malli \"%s\" on virheellinen, se ei saa sisältää merkkijonoa \"%s\""
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "Malli \"%s\" ei sisällä merkkijonoa XXXXXX"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f kt"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f Mt"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f Gt"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Symbolisen linkin \"%s\" lukeminen epäonnistui: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "Symbolisia linkkejä ei tueta"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "Muunninta merkistöstä \"%s\" merkistöön \"%s\" ei voitu avata: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr ""
 "Funktiossa g_io_channel_read_line_string ei voi suorittaa raakalukemista"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Jäljelle jäänyt muuntamaton data lukupuskurissa"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "Kanava päättyy osittaiseen merkkiin"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "Funktiossa g_io_channel_read_to_end ei voi suorittaa raakalukemista"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Tiedoston \"%s\" avaaminen epäonnistui: open() epäonnistui: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Tiedoston \"%s\" mappaaminen epäonnistui: mmap() epäonnistui: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Virhe rivillä %d merkissä %d: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Virhe rivillä %d: %s"
 
-#: glib/gmarkup.c:493
+#: ../glib/gmarkup.c:493
 msgid ""
 "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "Havaittu tyhjä entiteetti \"&;\"; kelvolliset ovat: &amp; &quot; &lt; &gt; "
 "&apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -326,17 +327,17 @@ msgstr ""
 "entiteetin. Jos tämän &-merkin ei ole tarkoitus olla entiteetti, käytä "
 "merkintää &amp;"
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "Merkki \"%s\" ei ole kelvollinen entiteetin nimessä"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "Entiteetin nimi \"%s\" on tuntematon"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -344,7 +345,7 @@ msgstr ""
 "Entiteetti ei päättynyt puolipisteeseen; todennäköisesti käytit &-merkkiä "
 "aikomatta aloittaa entiteettiä - käytä merkintää &amp;"
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -353,16 +354,16 @@ msgstr ""
 "Merkkijonon \"%-.*s\" piti olla luku merkkiviitteen sisällä (esim. &#234;), "
 "mutta sen jäsentäminen epäonnistui - ehkä luku on liian suuri"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "Merkkiviite \"%-.*s\" ei ole sallitun merkin koodaus"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
 msgstr "Tyhjä merkkiviite; viitteen tulee sisältää luku, esim &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -371,32 +372,32 @@ msgstr ""
 "Merkkiviite ei päättynyt puolipisteeseen; todennäköisesti käytit &-merkkiä "
 "aikomatta aloittaa entiteettiä - käytä merkintää &amp;"
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Päättämätön entiteettiviite"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Päättämätön merkkiviite"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "Virheellinen UTF-8-koodattu teksti - ylipitkä sekvenssi"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "Virheellinen UTF-8-koodattu teksti - ei aloitusmerkki"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "Virheellinen UTF-8-koodattu teksti - epäkelpo \"%s\""
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Asiakirjan on alettava elementillä (esim. <kirja>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
@@ -405,7 +406,7 @@ msgstr ""
 "\"%s\" ei ole kelvollinen merkki \"<\"-merkin jälkeen; se ei voi aloittaa "
 "elementin nimeä"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -413,7 +414,7 @@ msgid ""
 msgstr ""
 "Pariton merkki \"%s\", odotettiin \">\"-merkkiä päättämään elementin \"%s\""
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
 msgid ""
 "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
@@ -421,7 +422,7 @@ msgstr ""
 "Pariton merkki \"%1$s\", odotettiin \"=\"-merkkiä elementin \"%3$s\" "
 "ominaisuuden \"%2$s\" jälkeen"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -432,7 +433,7 @@ msgstr ""
 "elementin \"%s\" aloituslippu, tai mahdollista ominaisuutta; käytit ehkä "
 "ominaisuuden nimessä siihen kelpaamatonta merkkiä"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -441,7 +442,7 @@ msgstr ""
 "Pariton merkki \"%1$s\", odotettiin avaavaa lainausmerkkiä yhtäsuuruusmerkin "
 "jälkeen annettaessa elementin \"%3$s\" ominaisuuden \"%2$s\" arvoa"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -450,7 +451,7 @@ msgstr ""
 "\"%s\" ei ole kelvollinen merkki merkkien \"</\" jälkeen; \"%s\" ei voi olla "
 "elementin nimen alussa"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -459,28 +460,28 @@ msgstr ""
 "\"%s\" ei ole kelvollinen merkki sulkuelementin \"%s\" jälkeen; sallittu "
 "merkki on \">\""
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "Elementti \"%s\" on suljettu, ei avoimia elementtejä"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr ""
 "Elementti \"%s\" on suljettu, mutta tällä hetkellä on avoinna elementti \"%s"
 "\""
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "Asiakirja oli tyhjä tai sisälsi vain tyhjiä merkkejä"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr ""
 "Asiakirja loppui odottamattomasti heti avoimen kulmasulkeen \"<\" jälkeen"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -489,7 +490,7 @@ msgstr ""
 "Asiakirja loppui odottamattomasti elementtien ollessa sulkematta - \"%s\" "
 "oli viimeinen avattu elementti"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -498,19 +499,19 @@ msgstr ""
 "Asiakirja loppui odottamattomasti, odotettiin lipun <%s/> sulkevaa "
 "kulmasuljetta"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Asiakirja loppui odottamattomasti elementin nimen kohdalla"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Asiakirja loppui odottamattomasti ominaisuuden nimen kohdalla"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "Asiakirja loppui odottamattomasti elementin avauslipun kohdalla"
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -518,395 +519,397 @@ msgstr ""
 "Asiakirja loppui odottamattomasti ominaisuuden nimen jälkeisen "
 "yhtäsuuruusmerkin jälkeen; ominaisuudella ei ole arvoa"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "Asiakirja loppui odottamattomasti ominaisuuden arvon kohdalla"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "Asiakirja loppui odottamattomasti elementin \"%s\" sulkulipun kohdalla"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "Asiakirja loppui odottamattomasti kommentin tai käsittelykomennon kohdalla"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "vioittunut kohde"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "sisäinen virhe tai vioittunut kohde"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "muisti loppui"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "taakseviittausten raja saavutettu"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
 msgstr ""
 "malli sisältää kohtia, jotka eivät ole tuettu osittaisessa täsmäyksessä"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "sisäinen virhe"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr "takaisinviittaukset ehtoina eivät ole tuettu osittaisissa täsmäyksissä"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "rekursion enimmäissyvyys saavutettiin"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "työtilan raja tyhjille alamerkkijonoille saavutettiin"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "virheellinen yhdistelmä rivinvaihtolippuja"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "tuntematon virhe"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ mallin lopussa"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c mallin lopussa"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "Tuntematon merkki \\:n jälkeen"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr "merkkikokoa muuttavia ohjaimia (\\l, \\L, \\u, \\U) ei sallita tässä"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "numerot epäjärjestyksessä {}-määreessä"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "numerot liian suuria {}-määreessä"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "merkkiluokasta puuttuu päättävä ]"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "virheellinen escape-jono merkkiluokassa"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "alue epäjärjestyksessä merkkijoukolle"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "ei mitään toistettavaa"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "tuntematon merkki (? jälkeen"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "tuntematon merkki (?< jälkeen"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "tuntmaton merkki (?P jälkeen"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "POSIX:in nimetyt luokat on tuettu vain luokan sisällä"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "päättävä ) puuttuu"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") ilman aloittavaa (-merkkiä"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "(?R tai (?[+-]numeroita täytyy seurata )"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "viittaus olemattomaan alitäsmäykseen"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "puuttuva ) kommentin jälkeen"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "säännöllinen lauseke on liian suuri"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "muistia ei voitu varata"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "lookbehind-tyyppinen assert-makro ei ole kiinteäpituinen"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "virheellinen numero tai nimi (?( jälkeen"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "ehdollisessa ryhmässä on enenmmän kuin kaksi haaraa"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "assert-makrotoiminto odotettu merkkien (?( jälkeen"
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "tuntematon POSIX-luokan nimi"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "POSIX-vertailuelementtejä ei tueta"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "Merkin arvo sekvenssissä \\x{...} on liian suuri"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "virheellinen ehto (?(0)"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "\\C ei ole sallittu lookbehind-tyyppisissä assert-makroissa"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "rekursiivinen kutsu voisi olla päättymätön"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "alimallin nimestä puuttuu päätösmerkki"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "kahdella nimetyllä alimallilla on sama nimi"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "väärin muotoiltu \\P- tai \\p-sekvenssi"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "tuntematon ominaisuuden nimi \\P- tai \\p-sekvenssin jälkeen"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "alimallin nimi on liian pitkä (enintään 32 merkkiä)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "liian monta nimettyä alimallia (enintään 10000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "oktaaliarvo on suurempi kuin \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "DEFINE-ryhmä sisältää useampia kuin yhden haaran"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "DEFINE-ryhmän toisto ei ole sallittu"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "epäyhtenäisiä NEWLINE-valitsimia"
 
-#: glib/gregex.c:333
+#: ../glib/gregex.c:333
 msgid ""
 "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "\\g:n jälkeen ei tule nimeä aaltosulkeissa tai nollasta poikeavaa numeroa "
 "valinnaisesti aaltosulkeissa"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "odottamaton toisto"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "koodin ylivuoto"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "käännöksen työalueen koko loppui kesken"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "aiemmin tarkistettua ja viitattua alimallia ei löydy"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Virhe täsmätessä säännöllistä lauseketta %s: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "PCRE-kirjasto on käännetty ilman UTF8-tukea"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
 msgstr "PCRE-kirjasto on käännetty ilman UTF8-ominaisuuksien tukea"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
 msgstr "Virhe säännöllisessä lausekkeessa %s kohdassa %d: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Virhe optimoitaessa säännöllistä lauseketta %s: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "odotettiin heksadesimaalista numeroa tai merkkiä \"}\""
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "odotettiin heksadesimaalista numeroa"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "merkki '<' puuttuu symbolisesta viitteestä"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "päättämätön symbolinen viite"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "nollan mittainen symbolinen viite"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "odotettiin numeroa"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "virheellinen symbolinen viite"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "ylimääräinen päättävä '\\'"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "tuntematon escape-jono"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
 msgstr "Virhe tulkittaessa korvaavaa tekstia \"%s\" kohdassa %lu: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Lainattu teksti ei ala lainausmerkillä"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr ""
 "Pariton lainausmerkki komentorivillä tai muussa kuorisuojatussa tekstissä"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "Teksti loppui aivan merkin \"\\\" jälkeen. (Teksti oli \"%s\")"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
 msgstr ""
 "Teksti loppui ennen kuin löytyi merkkiä %c vastaava lainausmerkki. (Teksti "
 "oli \"%s\")"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
 msgstr "Teksti oli tyhjä (tai sisälsi vain tyhjiä merkkejä)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Datan lukeminen lapsiprosessilta epäonnistui"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr ""
 "Putken luominen lapsiprosessin kanssa viestintää varten epäonnistui (%s)"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Lukeminen lapsiprosessin putkesta epäonnistui (%s)"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Hakemistoon \"%s\" siirtyminen epäonnistui (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Lapsiprosessin käynnistys epäonnistui (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Virheellinen ohjelman nimi: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Virheellinen merkkijono argumenttivektorin kohdassa %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Virheellinen merkkijono ympäristössä: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Virhe työhakemisto: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Apuohjelman suoritus epäonnistui (%s)"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -914,137 +917,137 @@ msgstr ""
 "Odottamaton virhe funktiossa g_io_channel_win32_poll() luettaessa dataa "
 "lapsiprosessilta"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Datan lukeminen lapsiprosessilta epäonnistui (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr ""
 "Odottamaton virhe funktiossa select() lapsiprosessilta dataa luettaessa (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Odottamaton virhe funktiossa waitpid() (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "Haarauttaminen epäonnistui (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Lapsiprosessin \"%s\" käynnistäminen epäonnistui (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "Lapsiprosessin tulosteen tai syötteen uudelleenohjaus epäonnistui (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Lapsiprosessin haarauttaminen epäonnistui (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Tuntematon virhe käynnistettäessä lapsiprosessia \"%s\""
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Lapsiprosessin pid-putkesta ei voitu lukea riittävästi dataa (%s)"
 
-#: glib/gutf8.c:1038
+#: ../glib/gutf8.c:1038
 msgid "Character out of range for UTF-8"
 msgstr "Merkki on sallitun UTF-8-välin ulkopuolella"
 
-#: glib/gutf8.c:1132 glib/gutf8.c:1141 glib/gutf8.c:1273 glib/gutf8.c:1282
-#: glib/gutf8.c:1423 glib/gutf8.c:1519
+#: ../glib/gutf8.c:1132 ../glib/gutf8.c:1141 ../glib/gutf8.c:1273
+#: ../glib/gutf8.c:1282 ../glib/gutf8.c:1423 ../glib/gutf8.c:1519
 msgid "Invalid sequence in conversion input"
 msgstr "Virheellinen sarja muunnettavassa syötteessä"
 
-#: glib/gutf8.c:1434 glib/gutf8.c:1530
+#: ../glib/gutf8.c:1434 ../glib/gutf8.c:1530
 msgid "Character out of range for UTF-16"
 msgstr "Merkki on sallitun UTF-16-välin ulkopuolella"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Käyttö:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[VALITSIN...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Ohjevalitsimet:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Näytä ohjevalitsimet"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Näytä kaikki ohjevalitsimet"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Sovelluksen valitsimet:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Kokonaislukua \"%s\" ei voida tulkita kohteelle %s"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "Kokonaisluku \"%s\" kohteelle %s on ylittää sallitun alueen"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Kokonaislukua \"%s\" ei voida tulkita kohteelle %s"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr "Double-arvo \"%s\" kohteelle %s ylittää sallitun alueen"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Virhe käsiteltäessä valitsinta %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Puuttuva argumentti kohteelle %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Tuntematon optio %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "Kelvollista avaintiedostoa ei löytynyt haetuista kansioista"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Ei tavallinen tiedosto"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "Tiedosto on tyhjä"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
 msgid ""
 "Key file contains line '%s' which is not a key-value pair, group, or comment"
@@ -1052,50 +1055,50 @@ msgstr ""
 "Avaintiedosto sisältää rivin \"%s\", joka ei ole avain-arvopari, ryhmä tai "
 "kommentti"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Virheellinen ryhmän nimi: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "Avaintiedosto ei ala ryhmällä"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Virheellinen avaimen nimi: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Avaintiedosto sisältää epäkelvon koodauksen \"%s\""
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Avaintiedostossa ei ole ryhmää \"%s\""
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "Avaintiedostossa ei ole avainta \"%s\""
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr ""
 "Avaintiedosto sisältää avaimen \"%s\" arvolla \"%s\", joka ei ole UTF-8 "
 "merkkijono"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr "Avaintiedosto sisältää avaimen \"%s\", jonka arvoa ei voida tulkita."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1104,144 +1107,146 @@ msgstr ""
 "Avaintiedosto sisältää avaimen \"%s\", jonka arvoa ei voida tulkita, "
 "ryhmässä \"%s\"."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "AVaintiedostossa ei ole avainta \"%s\" ryhmässä \"%s\""
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "Avaintiedosto sisältää escape-jonon rivin lopussa"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Avaintiedostossa on virheellinen escape-jono \"%s\""
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "Arvoa \"%s\" ei voida tulkita numeroksi."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Kokonaisluku \"%s\" on sallitun alueen ulkopuolella"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "Arvoa \"%s\" ei voida tulkita liukuluvuksi."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Arvoa \"%s\" ei voida turkita totuusarvoksi."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Liian suuri laskuriarvo välitetty kohteelle %s"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Virta on jo suljettu"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:627
-#: gio/gsimpleasyncresult.c:654
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:627 ../gio/gsimpleasyncresult.c:654
 msgid "Operation was cancelled"
 msgstr "Toiminto oli peruttu"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Tuntematon tyyppi"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "%s-tiedostotyyppi"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "%s-tyyppi"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Odottamaton aikainen virran loppu"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Nimeämätön"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "Työpöytätiedosto ei määrittele Exec-kenttää"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Sovelluksen vaatimaa päätettä ei löydy"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
 msgstr "Käyttäjän sovellusten asetuskansiota %s ei voi luoda: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Käyttäjän MIME-asetusten kansiota %s ei voi luoda: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Käyttäjän työpöytätiedostoa %s ei voi luoda"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "Oma määrittely kohteelle %s"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "asema ei toteuta aseman avausta"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "asema ei toteut median tarkkailua"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
 msgstr "GEmblem-koodauksen versiota %d ei voi käsitellä"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
 msgstr "Virheellinen määrä tunnisteita (%d) GEmblem-koodauksessa"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
 msgstr "GEmblemedIcon-koodauksen versiota %d ei voi käsitellä"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
 msgstr "Virheellinen määrä tunnisteita (%d) GEmblemedIcon-koodauksessa"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
 msgstr "Oletettiin GEmblen kohteelle GEmblemedIcon"
 
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "Toiminto ei ole tuettu"
 
@@ -1253,130 +1258,130 @@ msgstr "Toiminto ei ole tuettu"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "Ylläolevaa liitospistettä ei löydy"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Kansion päälle ei voi kopioida"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "Kansiota ei voi kopioida kansion päälle"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "Kohdetiedosto on olemassa"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "Kansiota ei voi kopioida rekursiivisesti"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Saatiin virheellinen symbolisen linkin arvo"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "Roskakori ei ole tuettu"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Tiedostonimi ei voi sisältää merkkiä \"%c\""
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "taltio ei toteuta liittämistä"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Tiedoston käsittelyyn ei ole rekisteröity mitään sovellusta"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Numeraattori on suljettu"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "Tiedoston numeraattorilla on odottavia toimintoja"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "Numeraattori on jo suljettu"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "tiedosto"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Kuvakkeiden sisältävä tiedosto"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
 msgstr "GFileIcon-koodauksen versiota %d ei voi käsitellä"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
 msgstr "Virheellistä syötetietoa GFileIcon-oliolle"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Virta ei tue komentoa query_info"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Virta ei tue siirtymistä"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "Syötevirtaa ei voi kutistaa"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Virta ei tue kutistamista"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
 msgstr "Väärä määrä tunnisteita (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
 msgstr "Luokan nimelle %s ei ole tyyppiä"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
 msgstr "Tyyppi %s ei toteuta GIcon-määritystä"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
 msgstr "Typpi %s ei ole luokkatyyppi"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
 msgstr "Virheellinen versionumero: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
 msgstr "Tyyppi %s ei toteuta GIcon-määrityksen kutsua from_tokens()"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
 msgstr "Annettua kuvakkeen koodauksen versiota ei voi käsitellä"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "Syötevirta ei toteuta lukua"
 
@@ -1386,358 +1391,364 @@ msgstr "Syötevirta ei toteuta lukua"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Virrassa on toiminto odottamassa"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Paikallista kansiontarkkailun oletustyyppiä ei voi selvittää"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Virheellinen tiedostonimi %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Virhe haettaessa tietoja tiedostojärjestelmästä: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Juurikansiota ei voi nimetä uudestaan"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Virhe nimettäessä tiedostoa uudestaan: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "Tiedostoa ei voi nimetä uudestaan, tiedosto on jo olemassa"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:1009
 msgid "Invalid filename"
 msgstr "Virheellinen tiedostonimi"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Virhe avattaessa tiedostoa: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "Kansiota ei voi avata"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Virhe poistettaessa tiedostoa: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Virhe siirrettäessä tiedostoa roskakoriin: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Roskakorikansiota %s ei voi luoda: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Päätasoa roskakoria varten ei löydy"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Roskakori kansiota ei löydy tai sitä ei voi luoda"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Roskakorin informaatiotiedostoa ei voi luoda: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Tiedosto ei voi siirtää roskakoriin: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Virhe luotaessa kansiota: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Virhe luotaessa symbolista linkkiä: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Virhe siirrettäessä tiedostoa: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "Kansiota ei voi siirtää kansion päälle"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:829
+#: ../gio/glocalfileoutputstream.c:843 ../gio/glocalfileoutputstream.c:858
+#: ../gio/glocalfileoutputstream.c:874 ../gio/glocalfileoutputstream.c:888
 msgid "Backup file creation failed"
 msgstr "Varmuuskopiotiedoston luonti epäonnistui"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Virhe poistettaessa kohdetiedostoa: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "Siirto liitospisteiden välillä ei ole tuettu"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Ominaisuuden arvo ei voi olla NULL"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Virheellinen ominaisuustyyppi (piti olla merkkijono)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Virheellinen laajennetun ominaisuuden nimi"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Virhe asetettaessa laajennettua ominaisuutta \"%s\": %s"
 
-#: gio/glocalfileinfo.c:1466 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1466 ../gio/glocalfileoutputstream.c:713
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Virhe tarkkailtaessa tiedostoa \"%s\": %s"
 
-#: gio/glocalfileinfo.c:1536
+#: ../gio/glocalfileinfo.c:1536
 msgid " (invalid encoding)"
 msgstr " (virheellinen merkistökoodaus)"
 
-#: gio/glocalfileinfo.c:1704
+#: ../gio/glocalfileinfo.c:1704
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "Virhe tarkkailtaessa tiedostokuvaajaa: %s"
 
-#: gio/glocalfileinfo.c:1749
+#: ../gio/glocalfileinfo.c:1749
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Virheellinen ominaisuuden tyyppi (piti olla uint32)"
 
-#: gio/glocalfileinfo.c:1767
+#: ../gio/glocalfileinfo.c:1767
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Virheellinen ominaisuuden tyyppi (piti olla uint64)"
 
-#: gio/glocalfileinfo.c:1786 gio/glocalfileinfo.c:1805
+#: ../gio/glocalfileinfo.c:1786 ../gio/glocalfileinfo.c:1805
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Virheellinen ominaisuuden tyyppi (piti olla tavujono)"
 
-#: gio/glocalfileinfo.c:1831
+#: ../gio/glocalfileinfo.c:1831
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Virhe asetettaessa oikeuksia: %s"
 
-#: gio/glocalfileinfo.c:1882 gio/glocalfileinfo.c:2050
+#: ../gio/glocalfileinfo.c:1882 ../gio/glocalfileinfo.c:2050
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Virhe asetettaessa omistajaa: %s"
 
-#: gio/glocalfileinfo.c:1905
+#: ../gio/glocalfileinfo.c:1905
 msgid "symlink must be non-NULL"
 msgstr "symbolinen linkki ei voi olla NULL"
 
-#: gio/glocalfileinfo.c:1915 gio/glocalfileinfo.c:1934
-#: gio/glocalfileinfo.c:1945
+#: ../gio/glocalfileinfo.c:1915 ../gio/glocalfileinfo.c:1934
+#: ../gio/glocalfileinfo.c:1945
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Virhe asetettaessa symbolista linkkiä: %s"
 
-#: gio/glocalfileinfo.c:1924
+#: ../gio/glocalfileinfo.c:1924
 msgid "Error setting symlink: file is not a symlink"
 msgstr ""
 "Virhe asetettaessa symbolista linkkiä: tiedosto ei ole symbolinen linkki"
 
-#: gio/glocalfileinfo.c:2073
+#: ../gio/glocalfileinfo.c:2073
 msgid "SELinux context must be non-NULL"
 msgstr "SELinux-konteksti ei voi olla NULL"
 
-#: gio/glocalfileinfo.c:2088
+#: ../gio/glocalfileinfo.c:2088
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Virhe asetettaessa SELinux-kontekstia: %s"
 
-#: gio/glocalfileinfo.c:2095
+#: ../gio/glocalfileinfo.c:2095
 msgid "SELinux is not enabled on this system"
 msgstr "SELinux ei ole käytössä tässä tietokoneessa"
 
-#: gio/glocalfileinfo.c:2156
+#: ../gio/glocalfileinfo.c:2156
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "Ominaisuuden %s asetus ei ole tuettu"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Virhe luettaessa tiedostosta: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:906
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Virhe siirryttäessä tiedostossa: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Virhe suljettaessa tiedostoa: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Paikallisen tiedostomonitorinnin oletustapaa ei voitu selvittää"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Virhe kirjoitettaessa tiedostoon: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Virhe poistettaessa vanhaa varmuuskopiolinkkiä: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Virhe luotaessa varmuuskopiota: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Virhe nimettäessä uudestaan väliaikaistiedostoa: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:953
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Virhe katkaistaessa tiedostoa: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:695 ../gio/glocalfileoutputstream.c:934
+#: ../gio/glocalfileoutputstream.c:1015
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Virhe avattaessa tiedostoa \"%s\": %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:726
 msgid "Target file is a directory"
 msgstr "Kohdetiedosto on kansio"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:731
 msgid "Target file is not a regular file"
 msgstr "Kohdetiedosto ei ole tavallinen tiedosto"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:743
 msgid "The file was externally modified"
 msgstr "Tiedostoa muokattiin muualta"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/glocalfileoutputstream.c:922
+#, c-format
+msgid "Error removing old file: %s"
+msgstr "Virhe poistettaessa vanhaa tiedostoa: %s"
+
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "Saatiin virheellinen GSeekType"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Virheellinen siirtymispyyntö"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "GMemoryInputStream-kohdetta ei voi kutistaa"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "Tietotaulukon suurin koko tuli vastaan"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "Muistin tulostevirran koko ei ole muutettavissa"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "Muistin tulostevirran koon muutos epäonnistui"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "mount ei toteuta irrottamista"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "mount ei toteuta aseman avaamista"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "mount ei toteuta uudestaanliittämistä"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "mount ei toteuta sisältötyypin arvausta"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "mount ei toteuta synkronista sisältötyypin arvausta"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "Tulostevirta ei toteuta kirjoitusta"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "Lähdevirta on jo suljettu"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "nimi"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Kuvakkeen nimi"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "nimet"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Kuvakkeiden nimiä sisältävä jono"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "käytä oletusvarmistuksia"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1746,86 +1757,86 @@ msgstr ""
 "merkkien kohdilta. Jättää huomiotta ensimmäisen jälkeiset nimet, jos useita "
 "on annettu."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
 msgstr "GThemeIcon-koodauksen versiota %d ei voi käsitellä"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
 msgstr "Tiedostokuvaaja"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
 msgstr "Tiedostokuvaaja, josta luetaan"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
 msgstr "Sulje tiedostokuvaaja"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
 msgstr "Suljetaanko tiedostokuvaaja, kun virta on suljettu"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Virhe luettaessa UNIX:ilta: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Virhe suljettaessa UNIX:ia: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Tiedostojärjestelmän juuri"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
 msgstr "Tiedostokuvaaja, johon kirjoitetaan"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Virhe käsiteltäessä UNIX:iin: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "taltio ei toteuta aseman avausta"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Ohjelmaa ei löydy"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Virhe käynnistettäessä ohjelmaa: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "URI:ja ei tueta"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "assosiaation muutokset eivät ole tuettu win32-alustalla"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "Assosiaation luonti ei ole tuettu win32-alustalla"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "älä piilota kohtia"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "käytä pitkää listausmuotoa"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[TIEDOSTO...]"
 
diff --git a/po/hu.po b/po/hu.po
index 9af6781..84849dd 100644
--- a/po/hu.po
+++ b/po/hu.po
@@ -8,8 +8,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib.HEAD\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-17 11:17-0500\n"
-"PO-Revision-Date: 2009-02-01 01:41+0100\n"
+"POT-Creation-Date: 2009-02-19 14:07+0100\n"
+"PO-Revision-Date: 2009-02-19 14:08+0100\n"
 "Last-Translator: Gabor Kelemen <kelemeng@gnome.hu>\n"
 "Language-Team: Hungarian <gnome@fsf.hu>\n"
 "MIME-Version: 1.0\n"
@@ -18,305 +18,298 @@ msgstr ""
 "X-Generator: KBabel 1.11.4\n"
 "Plural-Forms:  nplurals=2; plural=(n != 1);\n"
 
-#: glib/gbookmarkfile.c:737
+#: ../glib/gbookmarkfile.c:737
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Váratlan attribútum („%s”) a(z) „%s” elemhez"
 
-#: glib/gbookmarkfile.c:748 glib/gbookmarkfile.c:819 glib/gbookmarkfile.c:829
-#: glib/gbookmarkfile.c:936
+#: ../glib/gbookmarkfile.c:748 ../glib/gbookmarkfile.c:819
+#: ../glib/gbookmarkfile.c:829 ../glib/gbookmarkfile.c:936
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
 msgstr "A(z) „$2%s” elem „$1%s” attribútuma nem található"
 
-#: glib/gbookmarkfile.c:1106 glib/gbookmarkfile.c:1171
-#: glib/gbookmarkfile.c:1235 glib/gbookmarkfile.c:1245
+#: ../glib/gbookmarkfile.c:1106 ../glib/gbookmarkfile.c:1171
+#: ../glib/gbookmarkfile.c:1235 ../glib/gbookmarkfile.c:1245
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Váratlan címke: „%s” a várt „%s” helyett"
 
-#: glib/gbookmarkfile.c:1131 glib/gbookmarkfile.c:1145
-#: glib/gbookmarkfile.c:1213 glib/gbookmarkfile.c:1265
+#: ../glib/gbookmarkfile.c:1131 ../glib/gbookmarkfile.c:1145
+#: ../glib/gbookmarkfile.c:1213 ../glib/gbookmarkfile.c:1265
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Váratlan címke: „%s” a következőn belül: „%s”"
 
-#: glib/gbookmarkfile.c:1793
+#: ../glib/gbookmarkfile.c:1793
 msgid "No valid bookmark file found in data dirs"
 msgstr "Az adatkönyvtárakban nem található érvényes könyvjelzőfájl"
 
-#: glib/gbookmarkfile.c:1994
+#: ../glib/gbookmarkfile.c:1994
 #, c-format
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Már létezik könyvjelző a következő URI címhez: „%s”"
 
-#: glib/gbookmarkfile.c:2040 glib/gbookmarkfile.c:2198
-#: glib/gbookmarkfile.c:2283 glib/gbookmarkfile.c:2363
-#: glib/gbookmarkfile.c:2448 glib/gbookmarkfile.c:2531
-#: glib/gbookmarkfile.c:2609 glib/gbookmarkfile.c:2688
-#: glib/gbookmarkfile.c:2730 glib/gbookmarkfile.c:2827
-#: glib/gbookmarkfile.c:2953 glib/gbookmarkfile.c:3143
-#: glib/gbookmarkfile.c:3219 glib/gbookmarkfile.c:3384
-#: glib/gbookmarkfile.c:3473 glib/gbookmarkfile.c:3563
-#: glib/gbookmarkfile.c:3691
+#: ../glib/gbookmarkfile.c:2040 ../glib/gbookmarkfile.c:2198
+#: ../glib/gbookmarkfile.c:2283 ../glib/gbookmarkfile.c:2363
+#: ../glib/gbookmarkfile.c:2448 ../glib/gbookmarkfile.c:2531
+#: ../glib/gbookmarkfile.c:2609 ../glib/gbookmarkfile.c:2688
+#: ../glib/gbookmarkfile.c:2730 ../glib/gbookmarkfile.c:2827
+#: ../glib/gbookmarkfile.c:2953 ../glib/gbookmarkfile.c:3143
+#: ../glib/gbookmarkfile.c:3219 ../glib/gbookmarkfile.c:3384
+#: ../glib/gbookmarkfile.c:3473 ../glib/gbookmarkfile.c:3563
+#: ../glib/gbookmarkfile.c:3691
 #, c-format
 msgid "No bookmark found for URI '%s'"
 msgstr "Nem található könyvjelző a következő URI címhez: „%s”"
 
-#: glib/gbookmarkfile.c:2372
+#: ../glib/gbookmarkfile.c:2372
 #, c-format
 msgid "No MIME type defined in the bookmark for URI '%s'"
 msgstr "Nincs MIME típus meghatározva a következő URI könyvjelzőjéhez: „%s”"
 
-#: glib/gbookmarkfile.c:2457
+#: ../glib/gbookmarkfile.c:2457
 #, c-format
 msgid "No private flag has been defined in bookmark for URI '%s'"
 msgstr "Nincs magán jelző meghatározva a következő URI könyvjelzőjéhez: „%s”"
 
-#: glib/gbookmarkfile.c:2836
+#: ../glib/gbookmarkfile.c:2836
 #, c-format
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "Nincsenek csoportok beállítva a következő URI könyvjelzőjéhez: „%s”"
 
 # FIXME: hol jön ez elő?
-#: glib/gbookmarkfile.c:3237 glib/gbookmarkfile.c:3394
+#: ../glib/gbookmarkfile.c:3237 ../glib/gbookmarkfile.c:3394
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
-msgstr ""
-"Nincs „%s” nevű alkalmazás regisztrálva a következő könyvjelzőjéhez: „%s”"
+msgstr "Nincs „%s” nevű alkalmazás regisztrálva a következő könyvjelzőjéhez: „%s”"
 
-#: glib/gbookmarkfile.c:3417
+#: ../glib/gbookmarkfile.c:3417
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
-msgstr ""
-"Nem sikerült kiterjeszteni a(z) „%s” végrehajtási sort a(z) „%s” URL címmel"
+msgstr "Nem sikerült kiterjeszteni a(z) „%s” végrehajtási sort a(z) „%s” URL címmel"
 
-#: glib/gconvert.c:431 glib/gconvert.c:509 glib/giochannel.c:1230
+#: ../glib/gconvert.c:431 ../glib/gconvert.c:509 ../glib/giochannel.c:1230
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "A(z) „%s” és „%s” karakterkészletek közötti átalakítás nem támogatott"
 
-#: glib/gconvert.c:435 glib/gconvert.c:513
+#: ../glib/gconvert.c:435 ../glib/gconvert.c:513
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr ""
 "A(z) „%s” karakterkészletről „%s” karakterkészletre átalakító nem nyitható "
 "meg"
 
-#: glib/gconvert.c:632 glib/gconvert.c:1017 glib/giochannel.c:1402
-#: glib/giochannel.c:1444 glib/giochannel.c:2288 glib/gutf8.c:964
-#: glib/gutf8.c:1413
+#: ../glib/gconvert.c:632 ../glib/gconvert.c:1017 ../glib/giochannel.c:1402
+#: ../glib/giochannel.c:1444 ../glib/giochannel.c:2288 ../glib/gutf8.c:964
+#: ../glib/gutf8.c:1413
 msgid "Invalid byte sequence in conversion input"
 msgstr "Érvénytelen bájtsorrend az átalakítás bemenetében"
 
-#: glib/gconvert.c:638 glib/gconvert.c:944 glib/giochannel.c:1409
-#: glib/giochannel.c:2300
+#: ../glib/gconvert.c:638 ../glib/gconvert.c:944 ../glib/giochannel.c:1409
+#: ../glib/giochannel.c:2300
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Hiba az átalakítás során: %s"
 
-#: glib/gconvert.c:669 glib/gutf8.c:960 glib/gutf8.c:1164 glib/gutf8.c:1305
-#: glib/gutf8.c:1409
+#: ../glib/gconvert.c:669 ../glib/gutf8.c:960 ../glib/gutf8.c:1164
+#: ../glib/gutf8.c:1305 ../glib/gutf8.c:1409
 msgid "Partial character sequence at end of input"
 msgstr "Részleges karaktersorozat a bemenet végén"
 
-#: glib/gconvert.c:919
+#: ../glib/gconvert.c:919
 #, c-format
 msgid "Cannot convert fallback '%s' to codeset '%s'"
 msgstr "Nem alakítható át a tartalék „%s” a(z) „%s” kódkészletre"
 
-#: glib/gconvert.c:1737
+#: ../glib/gconvert.c:1737
 #, c-format
 msgid "The URI '%s' is not an absolute URI using the \"file\" scheme"
 msgstr "A(z) „%s” URI nem abszolút, a „file” sémát használó URI"
 
-#: glib/gconvert.c:1747
+#: ../glib/gconvert.c:1747
 #, c-format
 msgid "The local file URI '%s' may not include a '#'"
 msgstr "A(z) „%s” helyi fájl URI nem tartalmazhat „#” karaktert"
 
-#: glib/gconvert.c:1764
+#: ../glib/gconvert.c:1764
 #, c-format
 msgid "The URI '%s' is invalid"
 msgstr "A(z) „%s” URI érvénytelen"
 
-#: glib/gconvert.c:1776
+#: ../glib/gconvert.c:1776
 #, c-format
 msgid "The hostname of the URI '%s' is invalid"
 msgstr "A(z) „%s” gépneve érvénytelen"
 
-#: glib/gconvert.c:1792
+#: ../glib/gconvert.c:1792
 #, c-format
 msgid "The URI '%s' contains invalidly escaped characters"
-msgstr ""
-"A(z) „%s” URI érvénytelen, escape sorozatként megadott karaktereket tartalmaz"
+msgstr "A(z) „%s” URI érvénytelen, escape sorozatként megadott karaktereket tartalmaz"
 
-#: glib/gconvert.c:1887
+#: ../glib/gconvert.c:1887
 #, c-format
 msgid "The pathname '%s' is not an absolute path"
 msgstr "A(z) „%s” elérési út neve nem abszolút útvonal"
 
-#: glib/gconvert.c:1897
+#: ../glib/gconvert.c:1897
 msgid "Invalid hostname"
 msgstr "Érvénytelen gépnév"
 
-#: glib/gdir.c:110 glib/gdir.c:130
+#: ../glib/gdir.c:110 ../glib/gdir.c:130
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Hiba a(z) „%s” könyvtár megnyitásakor: %s"
 
-#: glib/gfileutils.c:532 glib/gfileutils.c:620
+#: ../glib/gfileutils.c:532 ../glib/gfileutils.c:620
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Nem sikerült %lu bájtot lefoglalni a(z) „%s” fájl olvasásához"
 
-#: glib/gfileutils.c:547
+#: ../glib/gfileutils.c:547
 #, c-format
 msgid "Error reading file '%s': %s"
 msgstr "Hiba a(z) „%s” fájl olvasása közben: %s"
 
-#: glib/gfileutils.c:561
+#: ../glib/gfileutils.c:561
 #, c-format
 msgid "File \"%s\" is too large"
 msgstr "A fájl („%s”) túl nagy"
 
-#: glib/gfileutils.c:644
+#: ../glib/gfileutils.c:644
 #, c-format
 msgid "Failed to read from file '%s': %s"
 msgstr "Nem sikerült olvasni a(z) „%s” fájlból: %s"
 
-#: glib/gfileutils.c:695 glib/gfileutils.c:782
+#: ../glib/gfileutils.c:695 ../glib/gfileutils.c:782
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Nem sikerült megnyitni a(z) „%s” fájlt: %s"
 
-#: glib/gfileutils.c:712 glib/gmappedfile.c:133
+#: ../glib/gfileutils.c:712 ../glib/gmappedfile.c:133
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
-msgstr ""
-"Nem sikerült lekérni a(z) „%s” fájl attribútumait. Az fstat() sikertelen: %s"
+msgstr "Nem sikerült lekérni a(z) „%s” fájl attribútumait. Az fstat() sikertelen: %s"
 
-#: glib/gfileutils.c:746
+#: ../glib/gfileutils.c:746
 #, c-format
 msgid "Failed to open file '%s': fdopen() failed: %s"
 msgstr "Nem sikerült megnyitni a(z) „%s” fájlt. Az fdopen() sikertelen: %s"
 
-#: glib/gfileutils.c:853
+#: ../glib/gfileutils.c:853
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
 msgstr ""
 "Nem sikerült átnevezni a(z) „%s” fájlt erre: „%s”. A g_rename() sikertelen: %"
 "s"
 
-#: glib/gfileutils.c:895 glib/gfileutils.c:1284
+#: ../glib/gfileutils.c:895 ../glib/gfileutils.c:1284
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Nem sikerült létrehozni a(z) „%s” fájlt: %s"
 
-#: glib/gfileutils.c:909
+#: ../glib/gfileutils.c:909
 #, c-format
 msgid "Failed to open file '%s' for writing: fdopen() failed: %s"
-msgstr ""
-"Nem sikerült írásra megnyitni a(z) „%s” fájlt: Az fdopen() sikertelen: %s"
+msgstr "Nem sikerült írásra megnyitni a(z) „%s” fájlt: Az fdopen() sikertelen: %s"
 
-#: glib/gfileutils.c:934
+#: ../glib/gfileutils.c:934
 #, c-format
 msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Nem sikerült írni a(z) „%s” fájlt: az fwrite() sikertelen: %s"
 
-#: glib/gfileutils.c:953
+#: ../glib/gfileutils.c:953
 #, c-format
 msgid "Failed to close file '%s': fclose() failed: %s"
 msgstr "Nem sikerült lezárni a(z) „%s” fájlt: az fclose() sikertelen: %s"
 
-#: glib/gfileutils.c:1071
+#: ../glib/gfileutils.c:1071
 #, c-format
 msgid "Existing file '%s' could not be removed: g_unlink() failed: %s"
 msgstr "A létező „%s” fájl nem távolítható el: a g_unlink() sikertelen: %s"
 
-#: glib/gfileutils.c:1246
+#: ../glib/gfileutils.c:1246
 #, c-format
 msgid "Template '%s' invalid, should not contain a '%s'"
 msgstr "A(z) „%s” sablon érvénytelen, „%s” nem lehet benne"
 
-#: glib/gfileutils.c:1259
+#: ../glib/gfileutils.c:1259
 #, c-format
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "A(z) „%s” sablon nem tartalmaz XXXXXX karaktersorozatot"
 
-#: glib/gfileutils.c:1698
+#: ../glib/gfileutils.c:1698
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f KB"
 
-#: glib/gfileutils.c:1703
+#: ../glib/gfileutils.c:1703
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: glib/gfileutils.c:1708
+#: ../glib/gfileutils.c:1708
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: glib/gfileutils.c:1751
+#: ../glib/gfileutils.c:1751
 #, c-format
 msgid "Failed to read the symbolic link '%s': %s"
 msgstr "Nem sikerült kiolvasni a(z) „%s” szimbolikus linket: %s"
 
-#: glib/gfileutils.c:1772
+#: ../glib/gfileutils.c:1772
 msgid "Symbolic links not supported"
 msgstr "A szimbolikus linkek használata nem támogatott"
 
-#: glib/giochannel.c:1234
+#: ../glib/giochannel.c:1234
 #, c-format
 msgid "Could not open converter from '%s' to '%s': %s"
 msgstr "Az átalakító a(z) „%s” elemről „%s” elemre nem nyitható meg: %s"
 
-#: glib/giochannel.c:1579
+#: ../glib/giochannel.c:1579
 msgid "Can't do a raw read in g_io_channel_read_line_string"
-msgstr ""
-"Nem lehet nyers (raw) olvasást végezni a g_io_channel_read_line_string-ben"
+msgstr "Nem lehet nyers (raw) olvasást végezni a g_io_channel_read_line_string-ben"
 
-#: glib/giochannel.c:1626 glib/giochannel.c:1884 glib/giochannel.c:1971
+#: ../glib/giochannel.c:1626 ../glib/giochannel.c:1884
+#: ../glib/giochannel.c:1971
 msgid "Leftover unconverted data in read buffer"
 msgstr "Át nem alakított adatok maradtak az olvasási pufferben"
 
-#: glib/giochannel.c:1707 glib/giochannel.c:1784
+#: ../glib/giochannel.c:1707 ../glib/giochannel.c:1784
 msgid "Channel terminates in a partial character"
 msgstr "A csatorna töredék karakterrel ér véget"
 
-#: glib/giochannel.c:1770
+#: ../glib/giochannel.c:1770
 msgid "Can't do a raw read in g_io_channel_read_to_end"
 msgstr "Nem lehet nyers (raw) olvasást végezni a g_io_channel_read_to_end-ben"
 
-#: glib/gmappedfile.c:116
+#: ../glib/gmappedfile.c:116
 #, c-format
 msgid "Failed to open file '%s': open() failed: %s"
 msgstr "Nem sikerült megnyitni a(z) „%s” fájlt: az open() sikertelen: %s"
 
-#: glib/gmappedfile.c:193
+#: ../glib/gmappedfile.c:193
 #, c-format
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Nem sikerült leképezni a(z) „%s” fájlt: Az mmap() sikertelen: %s"
 
-#: glib/gmarkup.c:255 glib/gmarkup.c:295
+#: ../glib/gmarkup.c:255 ../glib/gmarkup.c:295
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Hiba a(z) %d. sor %d. karakterénél: "
 
-#: glib/gmarkup.c:389
+#: ../glib/gmarkup.c:389
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Hiba a(z) %d. sorban: %s"
 
-#: glib/gmarkup.c:493
-msgid ""
-"Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
-msgstr ""
-"Üres „&;” entitás; az érvényes entitások: &amp; &quot; &lt; &gt; &apos;"
+#: ../glib/gmarkup.c:493
+msgid "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+msgstr "Üres „&;” entitás; az érvényes entitások: &amp; &quot; &lt; &gt; &apos;"
 
-#: glib/gmarkup.c:503
+#: ../glib/gmarkup.c:503
 #, c-format
 msgid ""
 "Character '%s' is not valid at the start of an entity name; the & character "
@@ -327,17 +320,17 @@ msgstr ""
 "nevét az & karakter kezdi. Ha ez az & karakter nem lehet entitás, akkor "
 "&amp; módon kell írni."
 
-#: glib/gmarkup.c:537
+#: ../glib/gmarkup.c:537
 #, c-format
 msgid "Character '%s' is not valid inside an entity name"
 msgstr "A(z) „%s” karakter nem érvényes egy entitás nevén belül"
 
-#: glib/gmarkup.c:574
+#: ../glib/gmarkup.c:574
 #, c-format
 msgid "Entity name '%s' is not known"
 msgstr "A(z) „%s” entitásnév ismeretlen"
 
-#: glib/gmarkup.c:585
+#: ../glib/gmarkup.c:585
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity - escape ampersand as &amp;"
@@ -345,7 +338,7 @@ msgstr ""
 "Az entitás neve nem pontosvesszővel ért véget; valószínűleg egy &-jelet "
 "használt anélkül, hogy entitást akart volna kezdeni - írja &amp; formában."
 
-#: glib/gmarkup.c:638
+#: ../glib/gmarkup.c:638
 #, c-format
 msgid ""
 "Failed to parse '%-.*s', which should have been a digit inside a character "
@@ -354,17 +347,16 @@ msgstr ""
 "Nem sikerült feldolgozni ezt: „%-.*s”. Valószínűleg számjegy lett volna egy "
 "karakterhivatkozáson (mint az &#234) belül - lehet, hogy túl nagy a számjegy"
 
-#: glib/gmarkup.c:660
+#: ../glib/gmarkup.c:660
 #, c-format
 msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "A(z) „%-.*s” karakterhivatkozás nem engedélyezett karaktert kódol"
 
-#: glib/gmarkup.c:675
+#: ../glib/gmarkup.c:675
 msgid "Empty character reference; should include a digit such as &#454;"
-msgstr ""
-"Üres karakterhivatkozás; számjegyet is kell tartalmaznia, például így: &#454;"
+msgstr "Üres karakterhivatkozás; számjegyet is kell tartalmaznia, például így: &#454;"
 
-#: glib/gmarkup.c:685
+#: ../glib/gmarkup.c:685
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity - escape ampersand "
@@ -373,40 +365,39 @@ msgstr ""
 "A karakterhivatkozás nem pontosvesszővel ért véget; valószínűleg egy &-jelet "
 "használt anélkül, hogy entitást akart volna kezdeni - írja &amp; formában."
 
-#: glib/gmarkup.c:771
+#: ../glib/gmarkup.c:771
 msgid "Unfinished entity reference"
 msgstr "Befejezetlen entitáshivatkozás"
 
-#: glib/gmarkup.c:777
+#: ../glib/gmarkup.c:777
 msgid "Unfinished character reference"
 msgstr "Befejezetlen karakterhivatkozás"
 
-#: glib/gmarkup.c:1063
+#: ../glib/gmarkup.c:1063
 msgid "Invalid UTF-8 encoded text - overlong sequence"
 msgstr "Érvénytelen UTF-8 kódolású szöveg - túl hosszú sorozat"
 
-#: glib/gmarkup.c:1091
+#: ../glib/gmarkup.c:1091
 msgid "Invalid UTF-8 encoded text - not a start char"
 msgstr "Érvénytelen UTF-8 kódolású szöveg - ez nem kezdőkarakter"
 
-#: glib/gmarkup.c:1130
+#: ../glib/gmarkup.c:1130
 #, c-format
 msgid "Invalid UTF-8 encoded text - not valid '%s'"
 msgstr "Érvénytelen UTF-8 kódolású szöveg - nem érvényes „%s”"
 
-#: glib/gmarkup.c:1168
+#: ../glib/gmarkup.c:1168
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "A dokumentumnak egy elemmel kell kezdődnie (például: <book>)"
 
-#: glib/gmarkup.c:1208
+#: ../glib/gmarkup.c:1208
 #, c-format
 msgid ""
 "'%s' is not a valid character following a '<' character; it may not begin an "
 "element name"
-msgstr ""
-"„%s” nem érvényes karakter a „<” karakter után; elem neve nem kezdődhet vele"
+msgstr "„%s” nem érvényes karakter a „<” karakter után; elem neve nem kezdődhet vele"
 
-#: glib/gmarkup.c:1276
+#: ../glib/gmarkup.c:1276
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' character to end the empty-element tag '%"
@@ -415,15 +406,14 @@ msgstr ""
 "Furcsa karakter („%s”), „>” karakternek kellett volna jönnie, hogy lezárja a"
 "(z) „%s” üres elemcímkét"
 
-#: glib/gmarkup.c:1365
+#: ../glib/gmarkup.c:1365
 #, c-format
-msgid ""
-"Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
+msgid "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
 msgstr ""
 "Furcsa karakter („%s”) - „=” karakternek kellett volna jönnie a(z) „%s” elem "
 "„%s” attribútumneve után"
 
-#: glib/gmarkup.c:1407
+#: ../glib/gmarkup.c:1407
 #, c-format
 msgid ""
 "Odd character '%s', expected a '>' or '/' character to end the start tag of "
@@ -434,7 +424,7 @@ msgstr ""
 "„%s” elem kezdő címkéje után, esetleg egy attribútumnak; lehet, hogy "
 "érvénytelen karaktert használt az attribútum nevében"
 
-#: glib/gmarkup.c:1493
+#: ../glib/gmarkup.c:1493
 #, c-format
 msgid ""
 "Odd character '%s', expected an open quote mark after the equals sign when "
@@ -443,7 +433,7 @@ msgstr ""
 "Furcsa karakter („%s”) - egy nyitó idézőjelnek kellene jönnie az "
 "egyenlőségjel után, ha értéket ad a(z) „%s” attribútumnak „%s” elemben"
 
-#: glib/gmarkup.c:1635
+#: ../glib/gmarkup.c:1635
 #, c-format
 msgid ""
 "'%s' is not a valid character following the characters '</'; '%s' may not "
@@ -452,7 +442,7 @@ msgstr ""
 "„%s” nem érvényes karakter a „</” karakterek után; „%s” karakterrel nem "
 "kezdődhet egy elem neve"
 
-#: glib/gmarkup.c:1675
+#: ../glib/gmarkup.c:1675
 #, c-format
 msgid ""
 "'%s' is not a valid character following the close element name '%s'; the "
@@ -461,26 +451,25 @@ msgstr ""
 "„%s” nem érvényes karakter a „%s” lezáró elemnév után; az engedélyezett "
 "karakter egyedül a „>”."
 
-#: glib/gmarkup.c:1686
+#: ../glib/gmarkup.c:1686
 #, c-format
 msgid "Element '%s' was closed, no element is currently open"
 msgstr "A(z) „%s” elem le lett lezárva, jelenleg egy elem sincs nyitva"
 
-#: glib/gmarkup.c:1695
+#: ../glib/gmarkup.c:1695
 #, c-format
 msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgstr "A(z) „%s” elem le lett lezárva, de a jelenleg nyitott elem a(z) „%s”"
 
-#: glib/gmarkup.c:1858
+#: ../glib/gmarkup.c:1858
 msgid "Document was empty or contained only whitespace"
 msgstr "A dokumentum üres volt, vagy csak üreshely karaktereket tartalmazott"
 
-#: glib/gmarkup.c:1872
+#: ../glib/gmarkup.c:1872
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
-msgstr ""
-"A dokumentum váratlanul véget ért egy nyitott hegyes zárójel („<”) után"
+msgstr "A dokumentum váratlanul véget ért egy nyitott hegyes zárójel („<”) után"
 
-#: glib/gmarkup.c:1880 glib/gmarkup.c:1925
+#: ../glib/gmarkup.c:1880 ../glib/gmarkup.c:1925
 #, c-format
 msgid ""
 "Document ended unexpectedly with elements still open - '%s' was the last "
@@ -489,7 +478,7 @@ msgstr ""
 "A dokumentum váratlanul véget ért, pedig még nyitva vannak elemek - „%s” az "
 "utoljára megnyitott elem"
 
-#: glib/gmarkup.c:1888
+#: ../glib/gmarkup.c:1888
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -498,19 +487,19 @@ msgstr ""
 "A dokumentum váratlanul véget ért; a(z) <%s/> elemet lezáró hegyes "
 "zárójelnek kellett volna következnie"
 
-#: glib/gmarkup.c:1894
+#: ../glib/gmarkup.c:1894
 msgid "Document ended unexpectedly inside an element name"
 msgstr "A dokumentum váratlanul véget ért egy elemnéven belül"
 
-#: glib/gmarkup.c:1900
+#: ../glib/gmarkup.c:1900
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "A dokumentum váratlanul véget ért egy attribútumnéven belül"
 
-#: glib/gmarkup.c:1905
+#: ../glib/gmarkup.c:1905
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "A dokumentum váratlanul véget ért egy elemnyitó címkén belül"
 
-#: glib/gmarkup.c:1911
+#: ../glib/gmarkup.c:1911
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -518,405 +507,400 @@ msgstr ""
 "A dokumentum váratlanul véget ért egy az attribútumnevet követő "
 "egyenlőségjel után; az attribútum értéke nem lett megadva"
 
-#: glib/gmarkup.c:1918
+#: ../glib/gmarkup.c:1918
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "A dokumentum váratlanul véget ért egy attribútumértéken belül"
 
-#: glib/gmarkup.c:1934
+#: ../glib/gmarkup.c:1934
 #, c-format
 msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgstr "A dokumentum váratlanul véget ért a(z) „%s” elem lezáró címkéjén belül"
 
-#: glib/gmarkup.c:1940
+#: ../glib/gmarkup.c:1940
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "A dokumentum váratlanul véget ért egy megjegyzésen vagy feldolgozási "
 "utasításon belül"
 
-#: glib/gregex.c:131
+#: ../glib/gregex.c:131
 msgid "corrupted object"
 msgstr "sérült objektum"
 
-#: glib/gregex.c:133
+#: ../glib/gregex.c:133
 msgid "internal error or corrupted object"
 msgstr "belső hiba vagy sérült objektum"
 
-#: glib/gregex.c:135
+#: ../glib/gregex.c:135
 msgid "out of memory"
 msgstr "elfogyott a memória"
 
-#: glib/gregex.c:140
+#: ../glib/gregex.c:140
 msgid "backtracking limit reached"
 msgstr "a visszakövetési korlát elérve"
 
-#: glib/gregex.c:152 glib/gregex.c:160
+#: ../glib/gregex.c:152 ../glib/gregex.c:160
 msgid "the pattern contains items not supported for partial matching"
-msgstr ""
-"a minta a részleges mintaillesztés esetén nem támogatott elemeket tartalmaz"
+msgstr "a minta a részleges mintaillesztés esetén nem támogatott elemeket tartalmaz"
 
-#: glib/gregex.c:154 gio/glocalfile.c:1999
+#: ../glib/gregex.c:154 ../gio/glocalfile.c:1999
 msgid "internal error"
 msgstr "belső hiba"
 
-#: glib/gregex.c:162
+#: ../glib/gregex.c:162
 msgid "back references as conditions are not supported for partial matching"
 msgstr ""
 "a visszahivatkozások használata feltételekként nem támogatott a részleges "
 "mintaillesztéshez"
 
-#: glib/gregex.c:171
+#: ../glib/gregex.c:171
 msgid "recursion limit reached"
 msgstr "az ismétlési korlát elérve"
 
-#: glib/gregex.c:173
+#: ../glib/gregex.c:173
 msgid "workspace limit for empty substrings reached"
 msgstr "az üres rész-karaktersorozatok munkaterület-korlátja elérve"
 
-#: glib/gregex.c:175
+#: ../glib/gregex.c:175
 msgid "invalid combination of newline flags"
 msgstr "újsor-jelzők érvénytelen kombinációja"
 
-#: glib/gregex.c:179
+#: ../glib/gregex.c:179
 msgid "unknown error"
 msgstr "ismeretlen hiba"
 
-#: glib/gregex.c:199
+#: ../glib/gregex.c:199
 msgid "\\ at end of pattern"
 msgstr "\\ a minta végén"
 
-#: glib/gregex.c:202
+#: ../glib/gregex.c:202
 msgid "\\c at end of pattern"
 msgstr "\\c a minta végén"
 
-#: glib/gregex.c:205
+#: ../glib/gregex.c:205
 msgid "unrecognized character follows \\"
 msgstr "ismeretlen karakter következik a \\ után"
 
-#: glib/gregex.c:212
+#: ../glib/gregex.c:212
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
 msgstr ""
 "itt nem engedélyezettek a kis-és nagybetűket átalakító escape-karakterek "
 "(\\l, \\L, \\u, \\U)"
 
-#: glib/gregex.c:215
+#: ../glib/gregex.c:215
 msgid "numbers out of order in {} quantifier"
 msgstr "a számok nincsenek sorrendben a {} kvantálóban"
 
-#: glib/gregex.c:218
+#: ../glib/gregex.c:218
 msgid "number too big in {} quantifier"
 msgstr "a szám túl nagy a a {} kvantálóban"
 
-#: glib/gregex.c:221
+#: ../glib/gregex.c:221
 msgid "missing terminating ] for character class"
 msgstr "a karakterosztály befejező ] jele hiányzik"
 
-#: glib/gregex.c:224
+#: ../glib/gregex.c:224
 msgid "invalid escape sequence in character class"
 msgstr "érvénytelen escape-sorozat a karakterosztályban"
 
-#: glib/gregex.c:227
+#: ../glib/gregex.c:227
 msgid "range out of order in character class"
 msgstr "a tartomány kívül esik a karakterosztály nagyságán"
 
-#: glib/gregex.c:230
+#: ../glib/gregex.c:230
 msgid "nothing to repeat"
 msgstr "nincs mit ismételni"
 
-#: glib/gregex.c:233
+#: ../glib/gregex.c:233
 msgid "unrecognized character after (?"
 msgstr "ismeretlen karakter a (? után"
 
-#: glib/gregex.c:237
+#: ../glib/gregex.c:237
 msgid "unrecognized character after (?<"
 msgstr "ismeretlen karakter a (?< után"
 
-#: glib/gregex.c:241
+#: ../glib/gregex.c:241
 msgid "unrecognized character after (?P"
 msgstr "ismeretlen karakter a (?P után"
 
-#: glib/gregex.c:244
+#: ../glib/gregex.c:244
 msgid "POSIX named classes are supported only within a class"
 msgstr "a POSIX elnevezett osztályok csak osztályon belül támogatottak"
 
-#: glib/gregex.c:247
+#: ../glib/gregex.c:247
 msgid "missing terminating )"
 msgstr "hiányzó befejező )"
 
-#: glib/gregex.c:251
+#: ../glib/gregex.c:251
 msgid ") without opening ("
 msgstr ") nyitó ( nélkül"
 
 #. translators: '(?R' and '(?[+-]digits' are both meant as (groups of)
 #. * sequences here, '(?-54' would be an example for the second group.
 #.
-#: glib/gregex.c:258
+#: ../glib/gregex.c:258
 msgid "(?R or (?[+-]digits must be followed by )"
 msgstr "a (?R vagy (?[+-]számjegyek elemeket )-nek kell követnie"
 
-#: glib/gregex.c:261
+#: ../glib/gregex.c:261
 msgid "reference to non-existent subpattern"
 msgstr "hivatkozás nem létező almintára"
 
-#: glib/gregex.c:264
+#: ../glib/gregex.c:264
 msgid "missing ) after comment"
 msgstr "a megjegyzés utáni ) hiányzik"
 
-#: glib/gregex.c:267
+#: ../glib/gregex.c:267
 msgid "regular expression too large"
 msgstr "a reguláris kifejezés túl nagy"
 
-#: glib/gregex.c:270
+#: ../glib/gregex.c:270
 msgid "failed to get memory"
 msgstr "a memóriakérés meghiúsult"
 
-#: glib/gregex.c:273
+#: ../glib/gregex.c:273
 msgid "lookbehind assertion is not fixed length"
 msgstr "a lookbehind kijelentés nem rögzített hosszúságú"
 
-#: glib/gregex.c:276
+#: ../glib/gregex.c:276
 msgid "malformed number or name after (?("
 msgstr "hibásan formázott szám vagy név a (?( után"
 
-#: glib/gregex.c:279
+#: ../glib/gregex.c:279
 msgid "conditional group contains more than two branches"
 msgstr "a feltételes csoport kettőnél több ágat tartalmaz"
 
-#: glib/gregex.c:282
+#: ../glib/gregex.c:282
 msgid "assertion expected after (?("
 msgstr "a (?( után kijelentésnek kellene állnia"
 
-#: glib/gregex.c:285
+#: ../glib/gregex.c:285
 msgid "unknown POSIX class name"
 msgstr "ismeretlen POSIX osztálynév"
 
-#: glib/gregex.c:288
+#: ../glib/gregex.c:288
 msgid "POSIX collating elements are not supported"
 msgstr "a POSIX leválogató elemek nem támogatottak"
 
-#: glib/gregex.c:291
+#: ../glib/gregex.c:291
 msgid "character value in \\x{...} sequence is too large"
 msgstr "a \\x{...} sorozaton belüli karakterérték túl nagy"
 
-#: glib/gregex.c:294
+#: ../glib/gregex.c:294
 msgid "invalid condition (?(0)"
 msgstr "érvénytelen feltétel: (?(0)"
 
-#: glib/gregex.c:297
+#: ../glib/gregex.c:297
 msgid "\\C not allowed in lookbehind assertion"
 msgstr "A \\C nem engedélyezett a lookbehind kijelentésben"
 
-#: glib/gregex.c:300
+#: ../glib/gregex.c:300
 msgid "recursive call could loop indefinitely"
 msgstr "a rekurzív hívás végtelen ciklushoz vezethet"
 
-#: glib/gregex.c:303
+#: ../glib/gregex.c:303
 msgid "missing terminator in subpattern name"
 msgstr "hiányzó befejező az alminta nevében"
 
-#: glib/gregex.c:306
+#: ../glib/gregex.c:306
 msgid "two named subpatterns have the same name"
 msgstr "két elnevezett alminta neve azonos"
 
-#: glib/gregex.c:309
+#: ../glib/gregex.c:309
 msgid "malformed \\P or \\p sequence"
 msgstr "rosszul formázott \\P vagy \\p sorozat"
 
-#: glib/gregex.c:312
+#: ../glib/gregex.c:312
 msgid "unknown property name after \\P or \\p"
 msgstr "ismeretlen tulajdonságnév a \\P vagy \\p után"
 
-#: glib/gregex.c:315
+#: ../glib/gregex.c:315
 msgid "subpattern name is too long (maximum 32 characters)"
 msgstr "az alminta neve túl hosszú (legfeljebb 32 karakter)"
 
-#: glib/gregex.c:318
+#: ../glib/gregex.c:318
 msgid "too many named subpatterns (maximum 10,000)"
 msgstr "túl sok elnevezett alminta (legfeljebb 10 000)"
 
-#: glib/gregex.c:321
+#: ../glib/gregex.c:321
 msgid "octal value is greater than \\377"
 msgstr "az oktális érték nagyobb, mint \\377"
 
-#: glib/gregex.c:324
+#: ../glib/gregex.c:324
 msgid "DEFINE group contains more than one branch"
 msgstr "a DEFINE csoport több ágat tartalmaz"
 
-#: glib/gregex.c:327
+#: ../glib/gregex.c:327
 msgid "repeating a DEFINE group is not allowed"
 msgstr "egy DEFINE csoport ismétlése nem engedélyezett"
 
-#: glib/gregex.c:330
+#: ../glib/gregex.c:330
 msgid "inconsistent NEWLINE options"
 msgstr "inkonzisztens NEWLINE beállítások"
 
-#: glib/gregex.c:333
-msgid ""
-"\\g is not followed by a braced name or an optionally braced non-zero number"
+#: ../glib/gregex.c:333
+msgid "\\g is not followed by a braced name or an optionally braced non-zero number"
 msgstr ""
 "a \\g után nem egy zárójelezett név vagy opcionálisan zárójelezett nem nulla "
 "szám áll"
 
-#: glib/gregex.c:338
+#: ../glib/gregex.c:338
 msgid "unexpected repeat"
 msgstr "váratlan ismétlés"
 
-#: glib/gregex.c:342
+#: ../glib/gregex.c:342
 msgid "code overflow"
 msgstr "kódtúlcsordulás"
 
-#: glib/gregex.c:346
+#: ../glib/gregex.c:346
 msgid "overran compiling workspace"
 msgstr "a fordítási munkaterület túlcsordult"
 
-#: glib/gregex.c:350
+#: ../glib/gregex.c:350
 msgid "previously-checked referenced subpattern not found"
 msgstr "a korábban ellenőrzött hivatkozott alminta nem található"
 
-#: glib/gregex.c:526 glib/gregex.c:1605
+#: ../glib/gregex.c:526 ../glib/gregex.c:1605
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Hiba a(z) %s reguláris kifejezés illesztésekor: %s"
 
-#: glib/gregex.c:1098
+#: ../glib/gregex.c:1098
 msgid "PCRE library is compiled without UTF8 support"
 msgstr "A PRCE programkönyvtár UTF-8 támogatás nélkül lett fordítva"
 
-#: glib/gregex.c:1107
+#: ../glib/gregex.c:1107
 msgid "PCRE library is compiled without UTF8 properties support"
-msgstr ""
-"A PRCE programkönyvtár az UTF-8 tulajdonságok támogatása nélkül lett fordítva"
+msgstr "A PRCE programkönyvtár az UTF-8 tulajdonságok támogatása nélkül lett fordítva"
 
-#: glib/gregex.c:1161
+#: ../glib/gregex.c:1161
 #, c-format
 msgid "Error while compiling regular expression %s at char %d: %s"
-msgstr ""
-"Hiba a(z) „%s” reguláris kifejezés fordításakor a(z) %d. karakternél: %s"
+msgstr "Hiba a(z) „%s” reguláris kifejezés fordításakor a(z) %d. karakternél: %s"
 
-#: glib/gregex.c:1197
+#: ../glib/gregex.c:1197
 #, c-format
 msgid "Error while optimizing regular expression %s: %s"
 msgstr "Hiba a(z) %s reguláris kifejezés optimalizálásakor: %s"
 
-#: glib/gregex.c:2033
+#: ../glib/gregex.c:2033
 msgid "hexadecimal digit or '}' expected"
 msgstr "a program hexadecimális számjegyet vagy „}” jelet várt"
 
-#: glib/gregex.c:2049
+#: ../glib/gregex.c:2049
 msgid "hexadecimal digit expected"
 msgstr "a program hexadecimális számjegyet várt"
 
-#: glib/gregex.c:2089
+#: ../glib/gregex.c:2089
 msgid "missing '<' in symbolic reference"
 msgstr "hiányzó „<” jel a szimbolikus hivatkozásban"
 
-#: glib/gregex.c:2098
+#: ../glib/gregex.c:2098
 msgid "unfinished symbolic reference"
 msgstr "befejezetlen szimbolikus hivatkozás"
 
-#: glib/gregex.c:2105
+#: ../glib/gregex.c:2105
 msgid "zero-length symbolic reference"
 msgstr "nulla hosszúságú szimbolikus hivatkozás"
 
-#: glib/gregex.c:2116
+#: ../glib/gregex.c:2116
 msgid "digit expected"
 msgstr "re rendszer számjegyet várt"
 
-#: glib/gregex.c:2134
+#: ../glib/gregex.c:2134
 msgid "illegal symbolic reference"
 msgstr "illegális szimbolikus hivatkozás"
 
-#: glib/gregex.c:2196
+#: ../glib/gregex.c:2196
 msgid "stray final '\\'"
 msgstr "a záró „\\” helye nem megfelelő"
 
-#: glib/gregex.c:2200
+#: ../glib/gregex.c:2200
 msgid "unknown escape sequence"
 msgstr "ismeretlen escape sorozat"
 
-#: glib/gregex.c:2210
+#: ../glib/gregex.c:2210
 #, c-format
 msgid "Error while parsing replacement text \"%s\" at char %lu: %s"
-msgstr ""
-"Hiba a(z) „%s” helyettesítőszöveg elemzésekor a(z) %lu. karakternél: %s"
+msgstr "Hiba a(z) „%s” helyettesítőszöveg elemzésekor a(z) %lu. karakternél: %s"
 
-#: glib/gshell.c:70
+#: ../glib/gshell.c:70
 msgid "Quoted text doesn't begin with a quotation mark"
 msgstr "Az idézett szöveg nem idézőjellel kezdődik"
 
-#: glib/gshell.c:160
+#: ../glib/gshell.c:160
 msgid "Unmatched quotation mark in command line or other shell-quoted text"
 msgstr ""
 "Pár nélküli idézőjel a parancssorban vagy más, parancsértelmezőből idézett "
 "szövegben"
 
-#: glib/gshell.c:538
+#: ../glib/gshell.c:538
 #, c-format
 msgid "Text ended just after a '\\' character. (The text was '%s')"
 msgstr "A szöveg egy „\\” karakter után véget ért. (A szöveg: „%s”)"
 
-#: glib/gshell.c:545
+#: ../glib/gshell.c:545
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
-msgstr ""
-"A szöveg véget ért, mielőtt %c idézőjelpárja meglett volna. (A szöveg: „%s”)"
+msgstr "A szöveg véget ért, mielőtt %c idézőjelpárja meglett volna. (A szöveg: „%s”)"
 
-#: glib/gshell.c:557
+#: ../glib/gshell.c:557
 msgid "Text was empty (or contained only whitespace)"
-msgstr ""
-"A szöveg üres volt (vagy legfeljebb üreshely-karaktereket tartalmazott)"
+msgstr "A szöveg üres volt (vagy legfeljebb üreshely-karaktereket tartalmazott)"
 
-#: glib/gspawn-win32.c:283
+#: ../glib/gspawn-win32.c:283
 msgid "Failed to read data from child process"
 msgstr "Nem sikerült adatokat kiolvasni a gyermekfolyamatból"
 
-#: glib/gspawn-win32.c:298 glib/gspawn.c:1468
+#: ../glib/gspawn-win32.c:298 ../glib/gspawn.c:1468
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr ""
 "Nem sikerült csővezetéket készíteni a gyermekfolyamattal (%s) való "
 "kommunikációhoz"
 
-#: glib/gspawn-win32.c:336 glib/gspawn-win32.c:344 glib/gspawn.c:1132
+#: ../glib/gspawn-win32.c:336 ../glib/gspawn-win32.c:344 ../glib/gspawn.c:1132
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Nem sikerült olvasni a gyermek csővezetékből (%s)"
 
-#: glib/gspawn-win32.c:367 glib/gspawn.c:1337
+#: ../glib/gspawn-win32.c:367 ../glib/gspawn.c:1337
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Nem sikerült átváltani a(z) „%s” könyvtárra (%s)"
 
-#: glib/gspawn-win32.c:373 glib/gspawn-win32.c:492
+#: ../glib/gspawn-win32.c:373 ../glib/gspawn-win32.c:492
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Nem sikerült végrehajtani a gyermekfolyamatot (%s)"
 
-#: glib/gspawn-win32.c:442
+#: ../glib/gspawn-win32.c:442
 #, c-format
 msgid "Invalid program name: %s"
 msgstr "Érvénytelen programnév: %s"
 
-#: glib/gspawn-win32.c:452 glib/gspawn-win32.c:720 glib/gspawn-win32.c:1276
+#: ../glib/gspawn-win32.c:452 ../glib/gspawn-win32.c:720
+#: ../glib/gspawn-win32.c:1276
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Érvénytelen karaktersorozat a paraméterben a következő helyen: %d: %s"
 
-#: glib/gspawn-win32.c:463 glib/gspawn-win32.c:735 glib/gspawn-win32.c:1309
+#: ../glib/gspawn-win32.c:463 ../glib/gspawn-win32.c:735
+#: ../glib/gspawn-win32.c:1309
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Érvénytelen karaktersorozat a környezetben: %s"
 
-#: glib/gspawn-win32.c:716 glib/gspawn-win32.c:1257
+#: ../glib/gspawn-win32.c:716 ../glib/gspawn-win32.c:1257
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Érvénytelen munkakönyvtár: %s"
 
-#: glib/gspawn-win32.c:781
+#: ../glib/gspawn-win32.c:781
 #, c-format
 msgid "Failed to execute helper program (%s)"
 msgstr "Nem sikerült végrehajtani a segítő programot (%s)"
 
-#: glib/gspawn-win32.c:995
+#: ../glib/gspawn-win32.c:995
 msgid ""
 "Unexpected error in g_io_channel_win32_poll() reading data from a child "
 "process"
@@ -924,193 +908,192 @@ msgstr ""
 "Váratlan hiba, miközben a g_io_channel_win32_poll() adatokat olvasott egy "
 "gyermekfolyamatból"
 
-#: glib/gspawn.c:188
+#: ../glib/gspawn.c:188
 #, c-format
 msgid "Failed to read data from child process (%s)"
 msgstr "Nem sikerült adatokat olvasni a gyermekfolyamatból (%s)"
 
-#: glib/gspawn.c:325
+#: ../glib/gspawn.c:325
 #, c-format
 msgid "Unexpected error in select() reading data from a child process (%s)"
 msgstr ""
 "Váratlan hiba, miközben a select() adatokat próbált olvasni egy "
 "gyermekfolyamatból (%s)"
 
-#: glib/gspawn.c:408
+#: ../glib/gspawn.c:408
 #, c-format
 msgid "Unexpected error in waitpid() (%s)"
 msgstr "Váratlan hiba a waitpid()-ben (%s)"
 
-#: glib/gspawn.c:1197
+#: ../glib/gspawn.c:1197
 #, c-format
 msgid "Failed to fork (%s)"
 msgstr "Nem sikerült folyamatot indítani (%s)"
 
-#: glib/gspawn.c:1347
+#: ../glib/gspawn.c:1347
 #, c-format
 msgid "Failed to execute child process \"%s\" (%s)"
 msgstr "Nem sikerült a gyermekfolyamat („%s”) végrehajtása (%s)"
 
-#: glib/gspawn.c:1357
+#: ../glib/gspawn.c:1357
 #, c-format
 msgid "Failed to redirect output or input of child process (%s)"
 msgstr "Nem sikerült a gyermekfolyamat ki- vagy bemenetének átirányítása (%s)"
 
-#: glib/gspawn.c:1366
+#: ../glib/gspawn.c:1366
 #, c-format
 msgid "Failed to fork child process (%s)"
 msgstr "Nem sikerült a gyermekfolyamat elindítása (%s)"
 
-#: glib/gspawn.c:1374
+#: ../glib/gspawn.c:1374
 #, c-format
 msgid "Unknown error executing child process \"%s\""
 msgstr "Ismeretlen hiba a gyermekfolyamat („%s”) végrehajtása közben"
 
-#: glib/gspawn.c:1396
+#: ../glib/gspawn.c:1396
 #, c-format
 msgid "Failed to read enough data from child pid pipe (%s)"
 msgstr "Nem sikerült elég adatot kiolvasni a gyermek pid csővezetékből (%s)"
 
-#: glib/gutf8.c:1038
+#: ../glib/gutf8.c:1038
 msgid "Character out of range for UTF-8"
 msgstr "A karakter az UTF-8 tartományon kívülre esik"
 
-#: glib/gutf8.c:1132 glib/gutf8.c:1141 glib/gutf8.c:1273 glib/gutf8.c:1282
-#: glib/gutf8.c:1423 glib/gutf8.c:1519
+#: ../glib/gutf8.c:1132 ../glib/gutf8.c:1141 ../glib/gutf8.c:1273
+#: ../glib/gutf8.c:1282 ../glib/gutf8.c:1423 ../glib/gutf8.c:1519
 msgid "Invalid sequence in conversion input"
 msgstr "Érvénytelen sorozat az átalakítási bemenetben"
 
-#: glib/gutf8.c:1434 glib/gutf8.c:1530
+#: ../glib/gutf8.c:1434 ../glib/gutf8.c:1530
 msgid "Character out of range for UTF-16"
 msgstr "A karakter az UTF-16 tartományon kívülre esik"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "Usage:"
 msgstr "Használat:"
 
-#: glib/goption.c:615
+#: ../glib/goption.c:615
 msgid "[OPTION...]"
 msgstr "[KAPCSOLÓ...]"
 
-#: glib/goption.c:719
+#: ../glib/goption.c:719
 msgid "Help Options:"
 msgstr "Súgólehetőségek:"
 
-#: glib/goption.c:720
+#: ../glib/goption.c:720
 msgid "Show help options"
 msgstr "Súgólehetőségek megjelenítése"
 
-#: glib/goption.c:726
+#: ../glib/goption.c:726
 msgid "Show all help options"
 msgstr "Minden súgólehetőség megjelenítése"
 
-#: glib/goption.c:788
+#: ../glib/goption.c:788
 msgid "Application Options:"
 msgstr "Alkalmazás kapcsolói:"
 
-#: glib/goption.c:850 glib/goption.c:920
+#: ../glib/goption.c:850 ../glib/goption.c:920
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Nem dolgozható fel a(z) „%s” egész érték a következőhöz: %s"
 
-#: glib/goption.c:860 glib/goption.c:928
+#: ../glib/goption.c:860 ../glib/goption.c:928
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "A(z) „%s” egész érték a tartományon kívülre esik a következőhöz: %s"
 
-#: glib/goption.c:885
+#: ../glib/goption.c:885
 #, c-format
 msgid "Cannot parse double value '%s' for %s"
 msgstr "Nem dolgozható fel a(z) „%s” dupla hosszúságú érték a következőhöz: %s"
 
-#: glib/goption.c:893
+#: ../glib/goption.c:893
 #, c-format
 msgid "Double value '%s' for %s out of range"
 msgstr ""
 "A(z) „%s” dupla hosszúságú érték a tartományon kívülre esik a következőhöz: %"
 "s"
 
-#: glib/goption.c:1156 glib/goption.c:1235
+#: ../glib/goption.c:1156 ../glib/goption.c:1235
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Hiba a kapcsoló feldolgozása során: %s"
 
-#: glib/goption.c:1266 glib/goption.c:1380
+#: ../glib/goption.c:1266 ../glib/goption.c:1380
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Hiányzó paraméter a következőhöz: %s"
 
-#: glib/goption.c:1773
+#: ../glib/goption.c:1773
 #, c-format
 msgid "Unknown option %s"
 msgstr "Ismeretlen kapcsoló: %s"
 
-#: glib/gkeyfile.c:358
+#: ../glib/gkeyfile.c:358
 msgid "Valid key file could not be found in search dirs"
 msgstr "A keresési könyvtárakban nem található érvényes kulcsfájl"
 
-#: glib/gkeyfile.c:393
+#: ../glib/gkeyfile.c:393
 msgid "Not a regular file"
 msgstr "Nem szabályos fájl"
 
-#: glib/gkeyfile.c:401
+#: ../glib/gkeyfile.c:401
 msgid "File is empty"
 msgstr "A fájl üres"
 
-#: glib/gkeyfile.c:761
+#: ../glib/gkeyfile.c:761
 #, c-format
-msgid ""
-"Key file contains line '%s' which is not a key-value pair, group, or comment"
+msgid "Key file contains line '%s' which is not a key-value pair, group, or comment"
 msgstr ""
 "A kulcsfájl tartalmazza a(z) „%s” sort, amelyik nem egy kulcs-érték pár, "
 "csoport, vagy megjegyzés"
 
-#: glib/gkeyfile.c:821
+#: ../glib/gkeyfile.c:821
 #, c-format
 msgid "Invalid group name: %s"
 msgstr "Érvénytelen csoportnév: %s"
 
-#: glib/gkeyfile.c:843
+#: ../glib/gkeyfile.c:843
 msgid "Key file does not start with a group"
 msgstr "A kulcsfájl nem csoporttal kezdődik"
 
-#: glib/gkeyfile.c:869
+#: ../glib/gkeyfile.c:869
 #, c-format
 msgid "Invalid key name: %s"
 msgstr "Érvénytelen kulcsnév: %s"
 
-#: glib/gkeyfile.c:896
+#: ../glib/gkeyfile.c:896
 #, c-format
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "A kulcsfájl a nem támogatott „%s” kódolást tartalmazza"
 
-#: glib/gkeyfile.c:1112 glib/gkeyfile.c:1274 glib/gkeyfile.c:2503
-#: glib/gkeyfile.c:2569 glib/gkeyfile.c:2704 glib/gkeyfile.c:2837
-#: glib/gkeyfile.c:2990 glib/gkeyfile.c:3177 glib/gkeyfile.c:3238
+#: ../glib/gkeyfile.c:1112 ../glib/gkeyfile.c:1274 ../glib/gkeyfile.c:2503
+#: ../glib/gkeyfile.c:2569 ../glib/gkeyfile.c:2704 ../glib/gkeyfile.c:2837
+#: ../glib/gkeyfile.c:2990 ../glib/gkeyfile.c:3177 ../glib/gkeyfile.c:3238
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "A kulcsfájlból hiányzik a(z) „%s” csoport"
 
-#: glib/gkeyfile.c:1286
+#: ../glib/gkeyfile.c:1286
 #, c-format
 msgid "Key file does not have key '%s'"
 msgstr "A kulcsfájlban nincs „%s” kulcs"
 
-#: glib/gkeyfile.c:1393 glib/gkeyfile.c:1508
+#: ../glib/gkeyfile.c:1393 ../glib/gkeyfile.c:1508
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr ""
 "A kulcsfájl tartalmazza a(z) „%s” kulcsot „%s” értékkel, amelyik azonban nem "
 "UTF-8"
 
-#: glib/gkeyfile.c:1413 glib/gkeyfile.c:1528 glib/gkeyfile.c:1907
+#: ../glib/gkeyfile.c:1413 ../glib/gkeyfile.c:1528 ../glib/gkeyfile.c:1907
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr ""
 "A kulcsfájl tartalmazza a(z) „%s” kulcsot, amelynek az értéke nem "
 "értelmezhető."
 
-#: glib/gkeyfile.c:2122 glib/gkeyfile.c:2334
+#: ../glib/gkeyfile.c:2122 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has value that cannot be "
@@ -1119,145 +1102,146 @@ msgstr ""
 "A kulcsfájl tartalmazza a(z) „%s” kulcsot a(z) „%s” csoportban, amelynek "
 "értéke nem értelmezhető."
 
-#: glib/gkeyfile.c:2518 glib/gkeyfile.c:2719 glib/gkeyfile.c:3249
+#: ../glib/gkeyfile.c:2518 ../glib/gkeyfile.c:2719 ../glib/gkeyfile.c:3249
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "A kulcsfájl nem tartalmazza a(z) „%s” kulcsot a(z) „%s” csoportban."
 
-#: glib/gkeyfile.c:3483
+#: ../glib/gkeyfile.c:3483
 msgid "Key file contains escape character at end of line"
 msgstr "A kulcsfájl escape sorozattal megadott karaktert tartalmaz a sor végén"
 
-#: glib/gkeyfile.c:3505
+#: ../glib/gkeyfile.c:3505
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "A kulcsfájl érvénytelen escape sorozatot tartalmaz („%s”)"
 
-#: glib/gkeyfile.c:3647
+#: ../glib/gkeyfile.c:3647
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "A(z) „%s” érték nem értelmezhető számként."
 
-#: glib/gkeyfile.c:3661
+#: ../glib/gkeyfile.c:3661
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "A(z) „%s” egész érték a tartományon kívülre esik"
 
-#: glib/gkeyfile.c:3694
+#: ../glib/gkeyfile.c:3694
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "A(z) „%s” érték nem értelmezhető lebegőpontos számként."
 
-#: glib/gkeyfile.c:3718
+#: ../glib/gkeyfile.c:3718
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "A(z) „%s” érték nem értelmezhető logikai értékként."
 
-#: gio/gbufferedinputstream.c:417 gio/gbufferedinputstream.c:498
-#: gio/ginputstream.c:193 gio/ginputstream.c:325 gio/ginputstream.c:566
-#: gio/ginputstream.c:691 gio/goutputstream.c:202 gio/goutputstream.c:656
+#: ../gio/gbufferedinputstream.c:417 ../gio/gbufferedinputstream.c:498
+#: ../gio/ginputstream.c:193 ../gio/ginputstream.c:325
+#: ../gio/ginputstream.c:566 ../gio/ginputstream.c:691
+#: ../gio/goutputstream.c:202 ../gio/goutputstream.c:656
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Túl nagy számérték került átadásra ennek: %s"
 
-#: gio/gbufferedinputstream.c:885 gio/ginputstream.c:901
-#: gio/goutputstream.c:1085
+#: ../gio/gbufferedinputstream.c:885 ../gio/ginputstream.c:901
+#: ../gio/goutputstream.c:1085
 msgid "Stream is already closed"
 msgstr "Az adatfolyam már le van zárva"
 
-#: gio/gcancellable.c:366 gio/glocalfile.c:1992 gio/gsimpleasyncresult.c:627
-#: gio/gsimpleasyncresult.c:654
+#: ../gio/gcancellable.c:366 ../gio/glocalfile.c:1992
+#: ../gio/gsimpleasyncresult.c:627 ../gio/gsimpleasyncresult.c:654
 msgid "Operation was cancelled"
 msgstr "A művelet megszakítva"
 
-#: gio/gcontenttype.c:180
+#: ../gio/gcontenttype.c:180
 msgid "Unknown type"
 msgstr "Ismeretlen típus"
 
-#: gio/gcontenttype.c:181
+#: ../gio/gcontenttype.c:181
 #, c-format
 msgid "%s filetype"
 msgstr "%s fájltípus"
 
-#: gio/gcontenttype.c:678
+#: ../gio/gcontenttype.c:678
 #, c-format
 msgid "%s type"
 msgstr "%s típus"
 
-#: gio/gdatainputstream.c:313
+#: ../gio/gdatainputstream.c:313
 msgid "Unexpected early end-of-stream"
 msgstr "Váratlan korai adatfolyam vége"
 
-#: gio/gdesktopappinfo.c:460 gio/gwin32appinfo.c:222
+#: ../gio/gdesktopappinfo.c:460 ../gio/gwin32appinfo.c:222
 msgid "Unnamed"
 msgstr "Névtelen"
 
-#: gio/gdesktopappinfo.c:696
+#: ../gio/gdesktopappinfo.c:696
 msgid "Desktop file didn't specify Exec field"
 msgstr "A desktop fájl nem adta meg az Exec mezőt"
 
-#: gio/gdesktopappinfo.c:990
+#: ../gio/gdesktopappinfo.c:990
 msgid "Unable to find terminal required for application"
 msgstr "Nem található az alkalmazáshoz szükséges terminál"
 
-#: gio/gdesktopappinfo.c:1222
+#: ../gio/gdesktopappinfo.c:1222
 #, c-format
 msgid "Can't create user application configuration folder %s: %s"
-msgstr ""
-"Nem hozható létre a(z) %s felhasználói alkalmazáskonfigurációs mappa: %s"
+msgstr "Nem hozható létre a(z) %s felhasználói alkalmazáskonfigurációs mappa: %s"
 
-#: gio/gdesktopappinfo.c:1226
+#: ../gio/gdesktopappinfo.c:1226
 #, c-format
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Nem hozható létre a(z) %s felhasználói MIME konfigurációs mappa: %s"
 
-#: gio/gdesktopappinfo.c:1630
+#: ../gio/gdesktopappinfo.c:1630
 #, c-format
 msgid "Can't create user desktop file %s"
 msgstr "Nem hozható létre a felhasználói desktop fájl (%s)"
 
-#: gio/gdesktopappinfo.c:1742
+#: ../gio/gdesktopappinfo.c:1742
 #, c-format
 msgid "Custom definition for %s"
 msgstr "%s egyéni meghatározása"
 
-#: gio/gdrive.c:381
+#: ../gio/gdrive.c:381
 msgid "drive doesn't implement eject"
 msgstr "a meghajtó nem valósítja meg a kiadást"
 
-#: gio/gdrive.c:451
+#: ../gio/gdrive.c:451
 msgid "drive doesn't implement polling for media"
 msgstr "a meghajtó nem valósítja meg a média lekérdezését"
 
-#: gio/gemblem.c:325
+#: ../gio/gemblem.c:325
 #, c-format
 msgid "Can't handle version %d of GEmblem encoding"
 msgstr "A GEmblem kódolás %d. verziója nem kezelhető"
 
-#: gio/gemblem.c:335
+#: ../gio/gemblem.c:335
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblem encoding"
 msgstr "A GEmblem kódolásban a jelsorok száma (%d) hibásan formált"
 
-#: gio/gemblemedicon.c:295
+#: ../gio/gemblemedicon.c:295
 #, c-format
 msgid "Can't handle version %d of GEmblemedIcon encoding"
 msgstr "A GEmblemedIcon kódolás %d. verziója nem kezelhető"
 
-#: gio/gemblemedicon.c:305
+#: ../gio/gemblemedicon.c:305
 #, c-format
 msgid "Malformed number of tokens (%d) in GEmblemedIcon encoding"
 msgstr "A GEmblemedIcon kódolásban a jelsorok száma (%d) hibásan formált"
 
-#: gio/gemblemedicon.c:328
+#: ../gio/gemblemedicon.c:328
 msgid "Expected a GEmblem for GEmblemedIcon"
 msgstr "Egy GEmblem kellene a GEmblemedIconhoz"
 
-#: gio/gfile.c:825 gio/gfile.c:1055 gio/gfile.c:1190 gio/gfile.c:1426
-#: gio/gfile.c:1480 gio/gfile.c:1537 gio/gfile.c:1620 gio/gfile.c:2694
-#: gio/gfile.c:2748 gio/gfile.c:2879 gio/gfile.c:2919 gio/gfile.c:3246
-#: gio/gfile.c:3648 gio/gfile.c:3732 gio/gfile.c:3815 gio/gfile.c:3895
-#: gio/gfile.c:4225 gio/win32/gwinhttpfile.c:428
+#: ../gio/gfile.c:825 ../gio/gfile.c:1055 ../gio/gfile.c:1190
+#: ../gio/gfile.c:1426 ../gio/gfile.c:1480 ../gio/gfile.c:1537
+#: ../gio/gfile.c:1620 ../gio/gfile.c:2694 ../gio/gfile.c:2748
+#: ../gio/gfile.c:2879 ../gio/gfile.c:2919 ../gio/gfile.c:3246
+#: ../gio/gfile.c:3648 ../gio/gfile.c:3732 ../gio/gfile.c:3815
+#: ../gio/gfile.c:3895 ../gio/gfile.c:4225 ../gio/win32/gwinhttpfile.c:428
 msgid "Operation not supported"
 msgstr "A művelet nem támogatott"
 
@@ -1269,131 +1253,130 @@ msgstr "A művelet nem támogatott"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: gio/gfile.c:1311 gio/glocalfile.c:1071 gio/glocalfile.c:1082
-#: gio/glocalfile.c:1095
+#: ../gio/gfile.c:1311 ../gio/glocalfile.c:1071 ../gio/glocalfile.c:1082
+#: ../gio/glocalfile.c:1095
 msgid "Containing mount does not exist"
 msgstr "A tartalmazó csatolás nem létezik"
 
-#: gio/gfile.c:1963 gio/glocalfile.c:2142
+#: ../gio/gfile.c:1963 ../gio/glocalfile.c:2142
 msgid "Can't copy over directory"
 msgstr "Nem lehet a könyvtárra másolni"
 
-#: gio/gfile.c:2023
+#: ../gio/gfile.c:2023
 msgid "Can't copy directory over directory"
 msgstr "A könyvtár nem másolható könyvtárba"
 
-#: gio/gfile.c:2031 gio/glocalfile.c:2151
+#: ../gio/gfile.c:2031 ../gio/glocalfile.c:2151
 msgid "Target file exists"
 msgstr "A célfájl létezik"
 
-#: gio/gfile.c:2049
+#: ../gio/gfile.c:2049
 msgid "Can't recursively copy directory"
 msgstr "A könyvtár nem másolható rekurzívan"
 
-#: gio/gfile.c:2869
+#: ../gio/gfile.c:2869
 msgid "Invalid symlink value given"
 msgstr "Érvénytelen szimbolikus link érték került megadásra"
 
-#: gio/gfile.c:2962
+#: ../gio/gfile.c:2962
 msgid "Trash not supported"
 msgstr "A Kuka nem támogatott"
 
-#: gio/gfile.c:3011
+#: ../gio/gfile.c:3011
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "A fájlnevek nem tartalmazhatnak „%c” karaktert"
 
-#: gio/gfile.c:4993 gio/gvolume.c:370
+#: ../gio/gfile.c:4993 ../gio/gvolume.c:370
 msgid "volume doesn't implement mount"
 msgstr "a kötet nem valósítja meg a csatolást"
 
-#: gio/gfile.c:5101
+#: ../gio/gfile.c:5101
 msgid "No application is registered as handling this file"
 msgstr "Nincs alkalmazás regisztrálva a fájl kezeléséhez"
 
-#: gio/gfileenumerator.c:206
+#: ../gio/gfileenumerator.c:206
 msgid "Enumerator is closed"
 msgstr "Az enumerátor le van zárva"
 
-#: gio/gfileenumerator.c:213 gio/gfileenumerator.c:272
-#: gio/gfileenumerator.c:372 gio/gfileenumerator.c:481
+#: ../gio/gfileenumerator.c:213 ../gio/gfileenumerator.c:272
+#: ../gio/gfileenumerator.c:372 ../gio/gfileenumerator.c:481
 msgid "File enumerator has outstanding operation"
 msgstr "A fájlenumerátor hátralévő művelettel rendelkezik"
 
-#: gio/gfileenumerator.c:362 gio/gfileenumerator.c:471
+#: ../gio/gfileenumerator.c:362 ../gio/gfileenumerator.c:471
 msgid "File enumerator is already closed"
 msgstr "A fájlenumerátor már le van zárva"
 
-#: gio/gfileicon.c:145
+#: ../gio/gfileicon.c:145
 msgid "file"
 msgstr "fájl"
 
-#: gio/gfileicon.c:146
+#: ../gio/gfileicon.c:146
 msgid "The file containing the icon"
 msgstr "Az ikont tartalmazó fájl"
 
-#: gio/gfileicon.c:237
+#: ../gio/gfileicon.c:237
 #, c-format
 msgid "Can't handle version %d of GFileIcon encoding"
 msgstr "A GFileIcon kódolás %d. verziója nem kezelhető"
 
-#: gio/gfileicon.c:247
+#: ../gio/gfileicon.c:247
 msgid "Malformed input data for GFileIcon"
 msgstr "A GFileIcon bemeneti adatai rosszul formáltak"
 
-#: gio/gfileinputstream.c:157 gio/gfileinputstream.c:424
-#: gio/gfileoutputstream.c:171 gio/gfileoutputstream.c:526
+#: ../gio/gfileinputstream.c:157 ../gio/gfileinputstream.c:424
+#: ../gio/gfileoutputstream.c:171 ../gio/gfileoutputstream.c:526
 msgid "Stream doesn't support query_info"
 msgstr "Az adatfolyam nem támogatja a query_info-t"
 
-#: gio/gfileinputstream.c:339 gio/gfileoutputstream.c:384
+#: ../gio/gfileinputstream.c:339 ../gio/gfileoutputstream.c:384
 msgid "Seek not supported on stream"
 msgstr "Az adatfolyam nem támogatja a pozicionálást"
 
-#: gio/gfileinputstream.c:383
+#: ../gio/gfileinputstream.c:383
 msgid "Truncate not allowed on input stream"
 msgstr "A bemeneti adatfolyam csonkítása nem engedélyezett"
 
-#: gio/gfileoutputstream.c:460
+#: ../gio/gfileoutputstream.c:460
 msgid "Truncate not supported on stream"
 msgstr "Az adatfolyam csonkítása nem engedélyezett"
 
-#: gio/gicon.c:324
+#: ../gio/gicon.c:324
 #, c-format
 msgid "Wrong number of tokens (%d)"
 msgstr "A jelsorok száma hibás (%d)"
 
-#: gio/gicon.c:344
+#: ../gio/gicon.c:344
 #, c-format
 msgid "No type for class name %s"
 msgstr "Nincs típus az osztálynévhez: %s"
 
-#: gio/gicon.c:354
+#: ../gio/gicon.c:354
 #, c-format
 msgid "Type %s does not implement the GIcon interface"
 msgstr "A típus (%s) nem valósítja meg a GIcon felületet"
 
-#: gio/gicon.c:365
+#: ../gio/gicon.c:365
 #, c-format
 msgid "Type %s is not classed"
 msgstr "A típus (%s) nem tartalmaz osztályokat"
 
-#: gio/gicon.c:379
+#: ../gio/gicon.c:379
 #, c-format
 msgid "Malformed version number: %s"
 msgstr "Rosszul formált verziószám: %s"
 
-#: gio/gicon.c:393
+#: ../gio/gicon.c:393
 #, c-format
 msgid "Type %s does not implement from_tokens() on the GIcon interface"
-msgstr ""
-"A típus (%s) nem valósítja meg a from_tokens() függvényt a GIcon felületen"
+msgstr "A típus (%s) nem valósítja meg a from_tokens() függvényt a GIcon felületen"
 
-#: gio/gicon.c:469
+#: ../gio/gicon.c:469
 msgid "Can't handle the supplied version the icon encoding"
 msgstr "Az ikonkódolás megadott verziója nem kezelhető"
 
-#: gio/ginputstream.c:202
+#: ../gio/ginputstream.c:202
 msgid "Input stream doesn't implement read"
 msgstr "A bemeneti adatfolyam nem valósítja meg az olvasást"
 
@@ -1403,357 +1386,363 @@ msgstr "A bemeneti adatfolyam nem valósítja meg az olvasást"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: gio/ginputstream.c:911 gio/goutputstream.c:1095
+#: ../gio/ginputstream.c:911 ../gio/goutputstream.c:1095
 msgid "Stream has outstanding operation"
 msgstr "Az adatfolyam hátralévő művelettel rendelkezik"
 
-#: gio/glocaldirectorymonitor.c:274
+#: ../gio/glocaldirectorymonitor.c:274
 msgid "Unable to find default local directory monitor type"
 msgstr "Nem található az alapértelmezett helyi könyvtárfigyelő típus"
 
-#: gio/glocalfile.c:608 gio/win32/gwinhttpfile.c:411
+#: ../gio/glocalfile.c:608 ../gio/win32/gwinhttpfile.c:411
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Érvénytelen fájlnév: %s"
 
-#: gio/glocalfile.c:979
+#: ../gio/glocalfile.c:979
 #, c-format
 msgid "Error getting filesystem info: %s"
 msgstr "Hiba a fájlrendszer-információk lekérése közben: %s"
 
-#: gio/glocalfile.c:1115
+#: ../gio/glocalfile.c:1115
 msgid "Can't rename root directory"
 msgstr "Nem nevezhető át a gyökérkönyvtár"
 
-#: gio/glocalfile.c:1135 gio/glocalfile.c:1161
+#: ../gio/glocalfile.c:1135 ../gio/glocalfile.c:1161
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Hiba a fájl átnevezése közben: %s"
 
-#: gio/glocalfile.c:1144
+#: ../gio/glocalfile.c:1144
 msgid "Can't rename file, filename already exist"
 msgstr "A fájl nem nevezhető át, a fájlnév már létezik"
 
-#: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
-#: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: ../gio/glocalfile.c:1157 ../gio/glocalfile.c:2021 ../gio/glocalfile.c:2050
+#: ../gio/glocalfile.c:2204 ../gio/glocalfileoutputstream.c:505
+#: ../gio/glocalfileoutputstream.c:550 ../gio/glocalfileoutputstream.c:1009
 msgid "Invalid filename"
 msgstr "Érvénytelen fájlnév"
 
-#: gio/glocalfile.c:1280
+#: ../gio/glocalfile.c:1280
 #, c-format
 msgid "Error opening file: %s"
 msgstr "Hiba a fájl megnyitása közben: %s"
 
-#: gio/glocalfile.c:1290
+#: ../gio/glocalfile.c:1290
 msgid "Can't open directory"
 msgstr "A könyvtár nem nyitható meg"
 
-#: gio/glocalfile.c:1350
+#: ../gio/glocalfile.c:1350
 #, c-format
 msgid "Error removing file: %s"
 msgstr "Hiba a fájl eltávolítása közben: %s"
 
-#: gio/glocalfile.c:1714
+#: ../gio/glocalfile.c:1714
 #, c-format
 msgid "Error trashing file: %s"
 msgstr "Hiba fájl kidobása közben: %s"
 
-#: gio/glocalfile.c:1737
+#: ../gio/glocalfile.c:1737
 #, c-format
 msgid "Unable to create trash dir %s: %s"
 msgstr "Nem sikerült létrehozni a(z) %s Kuka könyvtárat: %s"
 
-#: gio/glocalfile.c:1758
+#: ../gio/glocalfile.c:1758
 msgid "Unable to find toplevel directory for trash"
 msgstr "Nem található a Kuka felső szintű könyvtára"
 
-#: gio/glocalfile.c:1837 gio/glocalfile.c:1857
+#: ../gio/glocalfile.c:1837 ../gio/glocalfile.c:1857
 msgid "Unable to find or create trash directory"
 msgstr "Nem található vagy nem hozható létre a Kuka könyvtár"
 
-#: gio/glocalfile.c:1891
+#: ../gio/glocalfile.c:1891
 #, c-format
 msgid "Unable to create trashing info file: %s"
 msgstr "Nem sikerült létrehozni a kukainformációs fájlt: %s"
 
-#: gio/glocalfile.c:1916 gio/glocalfile.c:1991 gio/glocalfile.c:1998
+#: ../gio/glocalfile.c:1916 ../gio/glocalfile.c:1991 ../gio/glocalfile.c:1998
 #, c-format
 msgid "Unable to trash file: %s"
 msgstr "Nem lehet a Kukába dobni a fájlt: %s"
 
-#: gio/glocalfile.c:2025
+#: ../gio/glocalfile.c:2025
 #, c-format
 msgid "Error creating directory: %s"
 msgstr "Hiba a könyvtár létrehozásakor: %s"
 
-#: gio/glocalfile.c:2054
+#: ../gio/glocalfile.c:2054
 #, c-format
 msgid "Error making symbolic link: %s"
 msgstr "Hiba a szimbolikus link létrehozása során: %s"
 
-#: gio/glocalfile.c:2114 gio/glocalfile.c:2208
+#: ../gio/glocalfile.c:2114 ../gio/glocalfile.c:2208
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Hiba a fájl áthelyezésekor: %s"
 
-#: gio/glocalfile.c:2137
+#: ../gio/glocalfile.c:2137
 msgid "Can't move directory over directory"
 msgstr "A könyvtár nem helyezhető át könyvtárba"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: ../gio/glocalfile.c:2164 ../gio/glocalfileoutputstream.c:829
+#: ../gio/glocalfileoutputstream.c:843 ../gio/glocalfileoutputstream.c:858
+#: ../gio/glocalfileoutputstream.c:874 ../gio/glocalfileoutputstream.c:888
 msgid "Backup file creation failed"
 msgstr "A mentési fájl létrehozása meghiúsult"
 
-#: gio/glocalfile.c:2183
+#: ../gio/glocalfile.c:2183
 #, c-format
 msgid "Error removing target file: %s"
 msgstr "Hiba a célfájl eltávolításakor: %s"
 
-#: gio/glocalfile.c:2197
+#: ../gio/glocalfile.c:2197
 msgid "Move between mounts not supported"
 msgstr "A csatolások közti áthelyezés nem támogatott"
 
-#: gio/glocalfileinfo.c:719
+#: ../gio/glocalfileinfo.c:719
 msgid "Attribute value must be non-NULL"
 msgstr "Az attribútum értéke nem lehet NULL"
 
-#: gio/glocalfileinfo.c:726
+#: ../gio/glocalfileinfo.c:726
 msgid "Invalid attribute type (string expected)"
 msgstr "Érvénytelen attribútumtípus (a várt karakterlánc helyett)"
 
-#: gio/glocalfileinfo.c:733
+#: ../gio/glocalfileinfo.c:733
 msgid "Invalid extended attribute name"
 msgstr "Érvénytelen kiterjesztett attribútumnév"
 
-#: gio/glocalfileinfo.c:773
+#: ../gio/glocalfileinfo.c:773
 #, c-format
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Hiba a(z) „%s” kiterjesztett attribútum beállításakor: %s"
 
-#: gio/glocalfileinfo.c:1466 gio/glocalfileoutputstream.c:706
+#: ../gio/glocalfileinfo.c:1466 ../gio/glocalfileoutputstream.c:713
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Hiba a(z) „%s” fájl elérése közben: %s"
 
-#: gio/glocalfileinfo.c:1536
+#: ../gio/glocalfileinfo.c:1536
 msgid " (invalid encoding)"
 msgstr " (érvénytelen kódolás)"
 
-#: gio/glocalfileinfo.c:1704
+#: ../gio/glocalfileinfo.c:1704
 #, c-format
 msgid "Error stating file descriptor: %s"
 msgstr "Hiba a fájlleíró elérésekor: %s"
 
-#: gio/glocalfileinfo.c:1749
+#: ../gio/glocalfileinfo.c:1749
 msgid "Invalid attribute type (uint32 expected)"
 msgstr "Érvénytelen attribútumtípus (a várt uint32 helyett)"
 
-#: gio/glocalfileinfo.c:1767
+#: ../gio/glocalfileinfo.c:1767
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Érvénytelen attribútumtípus (a várt uint64 helyett)"
 
-#: gio/glocalfileinfo.c:1786 gio/glocalfileinfo.c:1805
+#: ../gio/glocalfileinfo.c:1786 ../gio/glocalfileinfo.c:1805
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Érvénytelen attribútumtípus (a várt bájtkarakterlánc helyett)"
 
-#: gio/glocalfileinfo.c:1831
+#: ../gio/glocalfileinfo.c:1831
 #, c-format
 msgid "Error setting permissions: %s"
 msgstr "Hiba a jogosultságok beállításakor: %s"
 
-#: gio/glocalfileinfo.c:1882 gio/glocalfileinfo.c:2050
+#: ../gio/glocalfileinfo.c:1882 ../gio/glocalfileinfo.c:2050
 #, c-format
 msgid "Error setting owner: %s"
 msgstr "Hiba a tulajdonos beállításakor: %s"
 
-#: gio/glocalfileinfo.c:1905
+#: ../gio/glocalfileinfo.c:1905
 msgid "symlink must be non-NULL"
 msgstr "a szimbolikus link nem lehet NULL"
 
-#: gio/glocalfileinfo.c:1915 gio/glocalfileinfo.c:1934
-#: gio/glocalfileinfo.c:1945
+#: ../gio/glocalfileinfo.c:1915 ../gio/glocalfileinfo.c:1934
+#: ../gio/glocalfileinfo.c:1945
 #, c-format
 msgid "Error setting symlink: %s"
 msgstr "Hiba a szimbolikus link beállításakor: %s"
 
-#: gio/glocalfileinfo.c:1924
+#: ../gio/glocalfileinfo.c:1924
 msgid "Error setting symlink: file is not a symlink"
 msgstr "Hiba a szimbolikus link beállításakor: a fájl nem szimbolikus link"
 
-#: gio/glocalfileinfo.c:2073
+#: ../gio/glocalfileinfo.c:2073
 msgid "SELinux context must be non-NULL"
 msgstr "A SELinux környezet nem lehet NULL"
 
-#: gio/glocalfileinfo.c:2088
+#: ../gio/glocalfileinfo.c:2088
 #, c-format
 msgid "Error setting SELinux context: %s"
 msgstr "Hiba a SELinux környezet beállításakor: %s"
 
-#: gio/glocalfileinfo.c:2095
+#: ../gio/glocalfileinfo.c:2095
 msgid "SELinux is not enabled on this system"
 msgstr "A SELinux nem engedélyezett ezen rendszeren"
 
-#: gio/glocalfileinfo.c:2156
+#: ../gio/glocalfileinfo.c:2156
 #, c-format
 msgid "Setting attribute %s not supported"
 msgstr "A(z) %s attribútum beállítása nem támogatott"
 
-#: gio/glocalfileinputstream.c:160 gio/glocalfileoutputstream.c:603
+#: ../gio/glocalfileinputstream.c:160 ../gio/glocalfileoutputstream.c:603
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Hiba a fájl olvasásakor: %s"
 
-#: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
-#: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: ../gio/glocalfileinputstream.c:191 ../gio/glocalfileinputstream.c:203
+#: ../gio/glocalfileinputstream.c:312 ../gio/glocalfileoutputstream.c:405
+#: ../gio/glocalfileoutputstream.c:906
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Hiba a fájlban kereséskor: %s"
 
-#: gio/glocalfileinputstream.c:233 gio/glocalfileoutputstream.c:208
-#: gio/glocalfileoutputstream.c:303
+#: ../gio/glocalfileinputstream.c:233 ../gio/glocalfileoutputstream.c:208
+#: ../gio/glocalfileoutputstream.c:303
 #, c-format
 msgid "Error closing file: %s"
 msgstr "Hiba a fájl lezárásakor: %s"
 
-#: gio/glocalfilemonitor.c:198
+#: ../gio/glocalfilemonitor.c:198
 msgid "Unable to find default local file monitor type"
 msgstr "Nem található az alapértelmezett helyi fájlfigyelő típus"
 
-#: gio/glocalfileoutputstream.c:172 gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:172 ../gio/glocalfileoutputstream.c:624
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Hiba a fájl írásakor: %s"
 
-#: gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:235
 #, c-format
 msgid "Error removing old backup link: %s"
 msgstr "Hiba a régi mentési link eltávolításakor: %s"
 
-#: gio/glocalfileoutputstream.c:249 gio/glocalfileoutputstream.c:262
+#: ../gio/glocalfileoutputstream.c:249 ../gio/glocalfileoutputstream.c:262
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Hiba a mentés létrehozásakor: %s"
 
-#: gio/glocalfileoutputstream.c:280
+#: ../gio/glocalfileoutputstream.c:280
 #, c-format
 msgid "Error renaming temporary file: %s"
 msgstr "Hiba az ideiglenes fájl átnézésekor: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: ../gio/glocalfileoutputstream.c:451 ../gio/glocalfileoutputstream.c:953
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Hiba a fájl csonkításakor: %s"
 
-#: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: ../gio/glocalfileoutputstream.c:511 ../gio/glocalfileoutputstream.c:556
+#: ../gio/glocalfileoutputstream.c:695 ../gio/glocalfileoutputstream.c:934
+#: ../gio/glocalfileoutputstream.c:1015
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Hiba a(z) „%s” fájl megnyitásakor: %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: ../gio/glocalfileoutputstream.c:726
 msgid "Target file is a directory"
 msgstr "A célfájl egy könyvtár"
 
-#: gio/glocalfileoutputstream.c:724
+#: ../gio/glocalfileoutputstream.c:731
 msgid "Target file is not a regular file"
 msgstr "A célfájl nem szabályos fájl"
 
-#: gio/glocalfileoutputstream.c:736
+#: ../gio/glocalfileoutputstream.c:743
 msgid "The file was externally modified"
 msgstr "A fájlt külső program módosította"
 
-#: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
+#: ../gio/glocalfileoutputstream.c:922
+#, c-format
+msgid "Error removing old file: %s"
+msgstr "Hiba a régi fájl eltávolítása közben: %s"
+
+#: ../gio/gmemoryinputstream.c:487 ../gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "A megadott GSeekType nem támogatott"
 
-#: gio/gmemoryinputstream.c:497 gio/gmemoryoutputstream.c:555
+#: ../gio/gmemoryinputstream.c:497 ../gio/gmemoryoutputstream.c:555
 msgid "Invalid seek request"
 msgstr "Érvénytelen keresési kérés"
 
-#: gio/gmemoryinputstream.c:521
+#: ../gio/gmemoryinputstream.c:521
 msgid "Cannot truncate GMemoryInputStream"
 msgstr "A GMemoryInputStream nem csonkítható"
 
-#: gio/gmemoryoutputstream.c:288
+#: ../gio/gmemoryoutputstream.c:288
 msgid "Reached maximum data array limit"
 msgstr "A maximális adattömbkorlát elérve"
 
-#: gio/gmemoryoutputstream.c:323
+#: ../gio/gmemoryoutputstream.c:323
 msgid "Memory output stream not resizable"
 msgstr "A memóriakimeneti adatfolyam nem méretezhető át"
 
-#: gio/gmemoryoutputstream.c:339
+#: ../gio/gmemoryoutputstream.c:339
 msgid "Failed to resize memory output stream"
 msgstr "A memóriakimeneti adatfolyam átméretezése meghiúsult"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement unmount.
-#: gio/gmount.c:360
+#: ../gio/gmount.c:360
 msgid "mount doesn't implement unmount"
 msgstr "A csatolás nem valósítja meg a leválasztást"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement eject.
-#: gio/gmount.c:435
+#: ../gio/gmount.c:435
 msgid "mount doesn't implement eject"
 msgstr "A csatolás nem valósítja meg a kiadást"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement remount.
-#: gio/gmount.c:517
+#: ../gio/gmount.c:517
 msgid "mount doesn't implement remount"
 msgstr "A csatolás nem valósítja meg az újracsatolást"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:601
+#: ../gio/gmount.c:601
 msgid "mount doesn't implement content type guessing"
 msgstr "A csatolás nem valósítja meg a tartalomtípus meghatározását"
 
 #. Translators: This is an error
 #. * message for mount objects that
 #. * don't implement content type guessing.
-#: gio/gmount.c:690
+#: ../gio/gmount.c:690
 msgid "mount doesn't implement synchronous content type guessing"
 msgstr "A csatolás nem valósítja meg a tartalomtípus szinkron meghatározását"
 
-#: gio/goutputstream.c:211 gio/goutputstream.c:412
+#: ../gio/goutputstream.c:211 ../gio/goutputstream.c:412
 msgid "Output stream doesn't implement write"
 msgstr "A kimeneti adatfolyam nem valósítja meg az írást"
 
-#: gio/goutputstream.c:372 gio/goutputstream.c:780
+#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:780
 msgid "Source stream is already closed"
 msgstr "A forrás adatfolyam már le van zárva"
 
-#: gio/gthemedicon.c:211
+#: ../gio/gthemedicon.c:211
 msgid "name"
 msgstr "név"
 
-#: gio/gthemedicon.c:212
+#: ../gio/gthemedicon.c:212
 msgid "The name of the icon"
 msgstr "Az ikon neve"
 
-#: gio/gthemedicon.c:223
+#: ../gio/gthemedicon.c:223
 msgid "names"
 msgstr "nevek"
 
-#: gio/gthemedicon.c:224
+#: ../gio/gthemedicon.c:224
 msgid "An array containing the icon names"
 msgstr "Az ikonneveket tartalmazó tömb"
 
-#: gio/gthemedicon.c:249
+#: ../gio/gthemedicon.c:249
 msgid "use default fallbacks"
 msgstr "alapértelmezett tartalékok használata"
 
-#: gio/gthemedicon.c:250
+#: ../gio/gthemedicon.c:250
 msgid ""
 "Whether to use default fallbacks found by shortening the name at '-' "
 "characters. Ignores names after the first if multiple names are given."
@@ -1762,85 +1751,86 @@ msgstr ""
 "rövidítésével talált tartalékok. Több név megadása esetén az első utániakat "
 "figyelmen kívül hagyja."
 
-#: gio/gthemedicon.c:499
+#: ../gio/gthemedicon.c:499
 #, c-format
 msgid "Can't handle version %d of GThemedIcon encoding"
 msgstr "A GThemedIcon kódolás %d. verziója nem kezelhető"
 
-#: gio/gunixinputstream.c:161 gio/gunixoutputstream.c:147
+#: ../gio/gunixinputstream.c:161 ../gio/gunixoutputstream.c:147
 msgid "File descriptor"
 msgstr "Fájlleíró"
 
-#: gio/gunixinputstream.c:162
+#: ../gio/gunixinputstream.c:162
 msgid "The file descriptor to read from"
 msgstr "Az olvasandó fájlleíró"
 
-#: gio/gunixinputstream.c:176 gio/gunixoutputstream.c:162
+#: ../gio/gunixinputstream.c:176 ../gio/gunixoutputstream.c:162
 msgid "Close file descriptor"
 msgstr "Fájlleíró lezárása"
 
-#: gio/gunixinputstream.c:177 gio/gunixoutputstream.c:163
+#: ../gio/gunixinputstream.c:177 ../gio/gunixoutputstream.c:163
 msgid "Whether to close the file descriptor when the stream is closed"
 msgstr "A fájlleíró lezárandó-e az adatfolyam lezárásakor"
 
-#: gio/gunixinputstream.c:358 gio/gunixinputstream.c:378
-#: gio/gunixinputstream.c:456 gio/gunixoutputstream.c:443
+#: ../gio/gunixinputstream.c:358 ../gio/gunixinputstream.c:378
+#: ../gio/gunixinputstream.c:456 ../gio/gunixoutputstream.c:443
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Hiba a unix olvasásakor: %s"
 
-#: gio/gunixinputstream.c:411 gio/gunixinputstream.c:593
-#: gio/gunixoutputstream.c:398 gio/gunixoutputstream.c:549
+#: ../gio/gunixinputstream.c:411 ../gio/gunixinputstream.c:593
+#: ../gio/gunixoutputstream.c:398 ../gio/gunixoutputstream.c:549
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Hiba a unix lezárásakor: %s"
 
-#: gio/gunixmounts.c:1781 gio/gunixmounts.c:1818
+#: ../gio/gunixmounts.c:1781 ../gio/gunixmounts.c:1818
 msgid "Filesystem root"
 msgstr "Fájlrendszer gyökere"
 
-#: gio/gunixoutputstream.c:148
+#: ../gio/gunixoutputstream.c:148
 msgid "The file descriptor to write to"
 msgstr "Az írandó fájlleíró"
 
-#: gio/gunixoutputstream.c:344 gio/gunixoutputstream.c:365
+#: ../gio/gunixoutputstream.c:344 ../gio/gunixoutputstream.c:365
 #, c-format
 msgid "Error writing to unix: %s"
 msgstr "Hiba a unix írásakor: %s"
 
-#: gio/gvolume.c:444
+#: ../gio/gvolume.c:444
 msgid "volume doesn't implement eject"
 msgstr "a kötet nem valósítja meg a kiadást"
 
-#: gio/gwin32appinfo.c:277
+#: ../gio/gwin32appinfo.c:277
 msgid "Can't find application"
 msgstr "Nem található az alkalmazás"
 
-#: gio/gwin32appinfo.c:300
+#: ../gio/gwin32appinfo.c:300
 #, c-format
 msgid "Error launching application: %s"
 msgstr "Hiba az alkalmazás indításakor: %s"
 
-#: gio/gwin32appinfo.c:336
+#: ../gio/gwin32appinfo.c:336
 msgid "URIs not supported"
 msgstr "Az URI címek nem támogatottak"
 
-#: gio/gwin32appinfo.c:358
+#: ../gio/gwin32appinfo.c:358
 msgid "association changes not supported on win32"
 msgstr "a társításmódosítások nem támogatottak win32 rendszeren"
 
-#: gio/gwin32appinfo.c:370
+#: ../gio/gwin32appinfo.c:370
 msgid "Association creation not supported on win32"
 msgstr "A társítás létrehozása nem támogatott win32 rendszeren"
 
-#: tests/gio-ls.c:27
+#: ../tests/gio-ls.c:27
 msgid "do not hide entries"
 msgstr "ne rejtse el a bejegyzéseket"
 
-#: tests/gio-ls.c:29
+#: ../tests/gio-ls.c:29
 msgid "use a long listing format"
 msgstr "hosszú felsorolási formátum használata"
 
-#: tests/gio-ls.c:37
+#: ../tests/gio-ls.c:37
 msgid "[FILE...]"
 msgstr "[FÁJL...]"
+
diff --git a/po/th.po b/po/th.po
index e5ff6a6..a1c689b 100644
--- a/po/th.po
+++ b/po/th.po
@@ -8,8 +8,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib 2.14.1\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-02-17 11:17-0500\n"
-"PO-Revision-Date: 2009-02-06 18:11+0700\n"
+"POT-Creation-Date: 2009-02-19 16:11+0700\n"
+"PO-Revision-Date: 2009-02-19 16:14+0700\n"
 "Last-Translator: Theppitak Karoonboonyanan <thep@linux.thai.net>\n"
 "Language-Team: Thai <thai-l10n@googlegroups.com>\n"
 "MIME-Version: 1.0\n"
@@ -1372,7 +1372,7 @@ msgstr "ไม่สามารถเปลี่ยนชื่อแฟ้ม
 
 #: gio/glocalfile.c:1157 gio/glocalfile.c:2021 gio/glocalfile.c:2050
 #: gio/glocalfile.c:2204 gio/glocalfileoutputstream.c:505
-#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:967
+#: gio/glocalfileoutputstream.c:550 gio/glocalfileoutputstream.c:1009
 msgid "Invalid filename"
 msgstr "ชื่อแฟ้มผิดรูปแบบ"
 
@@ -1437,9 +1437,9 @@ msgstr "เกิดข้อผิดพลาดขณะย้ายแฟ้
 msgid "Can't move directory over directory"
 msgstr "ไม่สามารถย้ายไดเรกทอรีทับไดเรกทอรี"
 
-#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:819
-#: gio/glocalfileoutputstream.c:833 gio/glocalfileoutputstream.c:848
-#: gio/glocalfileoutputstream.c:864 gio/glocalfileoutputstream.c:878
+#: gio/glocalfile.c:2164 gio/glocalfileoutputstream.c:829
+#: gio/glocalfileoutputstream.c:843 gio/glocalfileoutputstream.c:858
+#: gio/glocalfileoutputstream.c:874 gio/glocalfileoutputstream.c:888
 msgid "Backup file creation failed"
 msgstr "สร้างแฟ้มสำรองไม่สำเร็จ"
 
@@ -1469,7 +1469,7 @@ msgstr "ชื่อแอตทริบิวต์ส่วนขยายเ
 msgid "Error setting extended attribute '%s': %s"
 msgstr "เกิดข้อผิดพลาดขณะกำหนดแอตทริบิวต์ส่วนขยาย '%s': %s"
 
-#: gio/glocalfileinfo.c:1466 gio/glocalfileoutputstream.c:706
+#: gio/glocalfileinfo.c:1466 gio/glocalfileoutputstream.c:713
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "เกิดข้อผิดพลาดขณะ stat แฟ้ม '%s': %s"
@@ -1544,7 +1544,7 @@ msgstr "เกิดข้อผิดพลาดขณะอ่านข้อ
 
 #: gio/glocalfileinputstream.c:191 gio/glocalfileinputstream.c:203
 #: gio/glocalfileinputstream.c:312 gio/glocalfileoutputstream.c:405
-#: gio/glocalfileoutputstream.c:896
+#: gio/glocalfileoutputstream.c:906
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "เกิดข้อผิดพลาดขณะเลื่อนตำแหน่งอ่านเขียนแฟ้ม: %s"
@@ -1579,29 +1579,35 @@ msgstr "เกิดข้อผิดพลาดขณะสร้างสำ
 msgid "Error renaming temporary file: %s"
 msgstr "เกิดข้อผิดพลาดขณะเปลี่ยนชื่อแฟ้มสำรอง: %s"
 
-#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:913
+#: gio/glocalfileoutputstream.c:451 gio/glocalfileoutputstream.c:953
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "เกิดข้อผิดพลาดขณะตัดท้ายแฟ้มทิ้ง: %s"
 
 #: gio/glocalfileoutputstream.c:511 gio/glocalfileoutputstream.c:556
-#: gio/glocalfileoutputstream.c:688 gio/glocalfileoutputstream.c:973
+#: gio/glocalfileoutputstream.c:695 gio/glocalfileoutputstream.c:934
+#: gio/glocalfileoutputstream.c:1015
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "เกิดข้อผิดพลาดขณะเปิดแฟ้ม '%s': %s"
 
-#: gio/glocalfileoutputstream.c:719
+#: gio/glocalfileoutputstream.c:726
 msgid "Target file is a directory"
 msgstr "แฟ้มปลายทางเป็นไดเรกทอรี"
 
-#: gio/glocalfileoutputstream.c:724
+#: gio/glocalfileoutputstream.c:731
 msgid "Target file is not a regular file"
 msgstr "แฟ้มปลายทางไม่ใช่แฟ้มปกติ"
 
-#: gio/glocalfileoutputstream.c:736
+#: gio/glocalfileoutputstream.c:743
 msgid "The file was externally modified"
 msgstr "แฟ้มถูกแก้ไขโดยโปรแกรมอื่น"
 
+#: gio/glocalfileoutputstream.c:922
+#, c-format
+msgid "Error removing old file: %s"
+msgstr "เกิดข้อผิดพลาดขณะลบแฟ้มเดิม: %s"
+
 #: gio/gmemoryinputstream.c:487 gio/gmemoryoutputstream.c:545
 msgid "Invalid GSeekType supplied"
 msgstr "ได้รับค่า GSeekType ที่ใช้การไม่ได้"
